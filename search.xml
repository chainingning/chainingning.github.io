<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Idea快速入门指南]]></title>
    <url>%2F2019%2F08%2F28%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FIDE%2Fidea%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Idea快速入门指南1.安装1.1.安装我们使用的是最新的2017.3.4版本： 双击打开， 选择一个目录，最好不要中文和空格： 然后选择桌面快捷方式，请选择64位： 然后选择安装： 开始安装： 然后勾选安装后运行，Finish： 1.2.首次配置 然后是UI界面选择，有白色和黑色两款，总有一款适合你： 把不需要的组件禁用： 插件暂时不选择安装，以后有需求还可以来安装： 然后进入运行界面： 激活Idea： 这里有三种激活方式： 第一种:购买正版用户(如果有资金最好选择正版) 第二种:激活码(这种方法在下面有讲解) 第三种:在线激活(有一个过期时间，这个时间一过就必须再次联网授权服务器请求激活) 土豪请选择第一种，每年大概不到$700 非土豪，请参考：http://idea.lanyus.com/ 中的教程。 激活完成，就可以开始撸代码了： 2.配置我们在启动界面打开配置页面： 进入idea以后，我们可以进行一系列配置。 2.1.字体和主题： 另外，主题也可以到网上下载，但是建议大家不要去浪费时间了。 2.2.启动项： 2.3.快捷键类名自动补全： 默认并不是Alt + /。而大家玩eclipse比较熟悉了，所以我们改成Alt + / 代码生成： 默认的代码生成快捷键：Alt + insert。很多同学电脑中没有 Insert 按键。 因此这里需要修改，大家自己选择。我设置的是Alt + I 还有快捷弹出 New菜单： 默认是Alt+Insert，没有Insert按键的同学，可以修改。我设置的也是Alt+ I 2.4.代码联想 2.5.编辑器字体： 2.6.编码 2.7.mavenidea自带的maven版本是3.3.9，我们一般不需要指定自己的。不过我们可以指定settings.xml来修改自己的仓库地址。 2.8.ES6语法支持 2.9.Vue插件安装 3.常用快捷键 快捷键 作用 Ctrl + Y 删除一行 Ctrl + D 复制一行 Ctrl + Alt + L 格式化 Ctrl + Alt + O 导包 Alt+Insert（可修改） New菜单\代码生成菜单（生成getter和setter，maven依赖等） Ctrl + / 注释 Ctrl + Shift + / 多行注释 Ctrl + Alt + 左/右 回退到上一次操作的地方，等于eclipse中的 Alt+左/右 Shift + Alt + 上/下 将代码上移或下移一行 Ctry + H ：罗列类的继承关系 4.代码补全idea有很多的代码自动补全功能，有两个地方可以设置： 还有一个： 其作用演示： 通过后缀的方式快速完成一些代码的补全，一般写完后缀，按tab或回车即可。罗列一些比较常用的： 代码 效果 psvm 自动生成main函数 .var 自动为对象生成声明 sout 输出：System.out.println() .if 生成if判断 .for 生成循环，默认是高级for fori 用普通for进行遍历 .try 生成try … catch 5.project与module5.1.idea的maven理念在Idea中，没有工作空间的概念，每一个Project就是一个独立的文件夹，也是一个独立的窗口。然后我们可以在Project中创建多个Module。 是不是感觉与maven的项目结构完全一致？ 说对了，idea就是完全贯彻了maven的理念。 5.2.小技巧熟悉eclipse的同学会觉得很不方便，无法在一个界面中创建很多的工程。 不过有一个取巧的办法：我们可以创建一个empty的工程： 然后选择empty工程： 然后填写名称： 点击Finish： 但是接下来，就不要再新建Project了，而是新建Module，Module就类似原来的工程的概念： 然后创建一个maven工程： 然后填写项目信息： 填写项目位置信息： 界面结构： 6.打开springboot的run dashboard先看下run dashboard是什么： 可以看到，这里可以同时显示多个springboot项目，非常方便。 默认情况下，idea的run dashboard是关闭的，当检测到你有多个springboot项目时会弹出提示框，询问是否打开。 如果我们想要自己打开，需要修改配置。 在你的idea的项目目录中，有一个.idea目录： 其中，有一个workspace.xml： 打开，搜索Rundashboard，找到下面这段： 然后在Component中添加下面的内容： 12345&lt;option name="configurationTypes"&gt; &lt;set&gt; &lt;option value="SpringBootApplicationConfigurationType" /&gt; &lt;/set&gt; &lt;/option&gt; 7.注释模板7.1 class1234567/** * @ClassName $&#123;NAME&#125; * @Description: xxx * @Author ningning.chai * @Date $&#123;DATE&#125; * @Version V1.0**/]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>软件工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter9-基础综合案例]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter9-%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 9 章 基础综合案例 Vue.js Vue Router Vue CLI axios 使用 Vue CLI 创建项目1$ vue create 项目名称 导入 Bootstrap 安装 1$ npm i bootstrap 在 src/main.js 中导入 123...import 'bootstrap/dist/css/bootstrap.css'... VueCLI 自动将该文件内容生成 style 节点插入了页面的 head 中 不需要像以前一样在页面中通过 link 标签去加载这个样式了 一切皆模块！ 创建视图组件列表页 src/views/home.vue12345678910111213141516&lt;template&gt;&lt;div&gt; &lt;p&gt;Home Component&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 添加页 src/views/add.vue12345678910111213141516&lt;template&gt;&lt;div&gt; &lt;p&gt;Add Component&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 编辑页 src/views/edit.vue12345678910111213141516&lt;template&gt;&lt;div&gt; &lt;p&gt;Edit Component&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 导入并配置 Vue Router 安装 1npm install vue-router 创建 src/router.js 文件并写入以下内容 12345678910import VueRouter from 'vue-router'import Vue from 'vue'Vue.use(VueRouter)// 等价于 module.exports = new VueRouter(&#123;...&#125;)export default new VueRouter(&#123; routes: [ ]&#125;) 根据你的需要配置路由表，例如下面分别配置了 Home、Add、Edit 三个路由组件导航规则 12345678910111213141516171819202122232425import Vue from 'vue'import VueRouter from 'vue-router'import Home from './views/Home.vue'import Add from './views/Add.vue'import Edit from './views/Edit.vue'Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ // 路由表 &#123; // 首页 path: '/', component: Home &#125;, &#123; // 添加 path: '/add', component: Add &#125;, &#123; // 修改 path: '/edit', component: Edit &#125;, ]&#125;) 在 src/main.js 中将路由实例配置到 Vue 实例中 12345678910...import router from './router'...new Vue(&#123; render: h =&gt; h(App), // router: router, // es6简写 router&#125;).$mount('#app') 键名 router 是 Vue 实例选项成员（就像 data、methods 一样，固定语法），值 router 是我们在 router.js 中 new 出来的 VueRouter 路由实例 最后，在 src/App.vue 中设置路由的出口 123456&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 路由出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 回到浏览器中访问不同的路由路径进行测试 接口服务查看 第4章 和服务端交互/学习准备 功能实现列表展示和删除安装 axios 1$ npm i axios 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt;&lt;div&gt; &lt;div class="header"&gt; &lt;!-- &lt;button type="button" class="btn btn-primary"&gt;Add Hero&lt;/button&gt; --&gt; &lt;!-- router-link 把 class 传给了自己内部封装的 a 标签了 --&gt; &lt;router-link class="btn btn-primary" to="/add"&gt;Add Hero&lt;/router-link&gt; &lt;/div&gt; &lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope="col"&gt;ID&lt;/th&gt; &lt;th scope="col"&gt;名称&lt;/th&gt; &lt;th scope="col"&gt;性别&lt;/th&gt; &lt;th scope="col"&gt;定位&lt;/th&gt; &lt;th scope="col"&gt;简介&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in heros"&gt; &lt;th scope="row"&gt;&#123;&#123; item.id &#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.gender &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.type &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.bio &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="handleDelete(item)"&gt;删除&lt;/a&gt; &lt;router-link :to="'/edit/' + item.id"&gt;修改&lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1. npm install axios// 2. 哪里使用 axios，哪里就 import axios from 'axios'import axios from 'axios'export default &#123; data () &#123; return &#123; heros: [] &#125; &#125;, created () &#123; this.loadHeros() // axios(&#123; // method: 'GET', // url: 'http://localhost:3000/heros' // &#125;).then(res =&gt; &#123; // this.heros = res.data // &#125;) &#125;, methods: &#123; loadHeros () &#123; axios(&#123; method: 'GET', url: 'http://localhost:3000/heros' &#125;).then(res =&gt; &#123; this.heros = res.data &#125;) &#125;, handleDelete (item) &#123; if (!window.confirm('Are you sure?')) &#123; return &#125; axios(&#123; method: 'DELETE', url: `http://localhost:3000/heros/$&#123;item.id&#125;` &#125;).then(res =&gt; &#123; this.loadHeros() &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.header &#123; padding: 10px;&#125;&lt;/style&gt; 添加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt;&lt;div&gt; &lt;form class="form"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;名称&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp" placeholder="Enter email" v-model="formData.name" &gt; &lt;small id="emailHelp" class="form-text text-muted"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;性别&lt;/label&gt; &lt;input type="radio" value="男" v-model="formData.gender"&gt; 男 &lt;input type="radio" value="女" v-model="formData.gender"&gt; 女 &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;定位&lt;/label&gt; &lt;select v-model="formData.type"&gt; &lt;option value="刺客"&gt;刺客&lt;/option&gt; &lt;option value="战士"&gt;战士&lt;/option&gt; &lt;option value="辅助"&gt;辅助&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;简介&lt;/label&gt; &lt;textarea cols="30" rows="10" v-model="formData.bio"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" @click.prevent="handleSubmit"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default &#123; data () &#123; return &#123; formData: &#123; name: '', gender: '', type: '', bio: '' &#125; &#125; &#125;, methods: &#123; handleSubmit () &#123; axios(&#123; method: 'POST', url: 'http://localhost:3000/heros', data: this.formData &#125;).then(res =&gt; &#123; // 跳转到指令路由路径 // VueRouter 提供的 API，专门用于 JavaScript 导航 this.$router.push('/') &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.form &#123; padding: 10px;&#125;&lt;/style&gt; 动态展示编辑页面 修改路由表编辑页面的导航路径 12345678routes: [ ... &#123; path: '/edit/:id', component: Edit &#125;, ...] 在 Home.vue 中处理修改按钮的导航地址 123456...&lt;td&gt; &lt;a href="#" @click.prevent="handleDelete(item)"&gt;删除&lt;/a&gt; &lt;router-link :to="'/edit/' + item.id"&gt;修改&lt;/router-link&gt;&lt;/td&gt;... 在 Edit.vue 编辑页面获取动态路径参数，请求加载数据更新视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt;&lt;div&gt; &lt;form class="form"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;名称&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp" placeholder="Enter email" v-model="formData.name" &gt; &lt;small id="emailHelp" class="form-text text-muted"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;性别&lt;/label&gt; &lt;input type="radio" value="男" v-model="formData.gender"&gt; 男 &lt;input type="radio" value="女" v-model="formData.gender"&gt; 女 &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;定位&lt;/label&gt; &lt;select v-model="formData.type"&gt; &lt;option value="刺客"&gt;刺客&lt;/option&gt; &lt;option value="战士"&gt;战士&lt;/option&gt; &lt;option value="辅助"&gt;辅助&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;简介&lt;/label&gt; &lt;textarea cols="30" rows="10" v-model="formData.bio"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default &#123; data () &#123; return &#123; formData: &#123; name: '', gender: '', type: '', bio: '' &#125; &#125; &#125;, created () &#123; // console.log(this.$route.params.id) // 不建议在生命周期中写大量的业务代码，最好都封装成 methods 函数 // 需要的时候直接调用 this.loadHero() &#125;, methods: &#123; loadHero () &#123; const id = this.$route.params.id axios(&#123; method: 'GET', url: `http://localhost:3000/heros/$&#123;id&#125;` &#125;).then(res =&gt; &#123; console.log(res.data) this.formData = res.data &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.form &#123; padding: 10px;&#125;&lt;/style&gt; 提交编辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;template&gt;&lt;div&gt; &lt;form class="form"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;名称&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp" placeholder="Enter email" v-model="formData.name" &gt; &lt;small id="emailHelp" class="form-text text-muted"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;性别&lt;/label&gt; &lt;input type="radio" value="男" v-model="formData.gender"&gt; 男 &lt;input type="radio" value="女" v-model="formData.gender"&gt; 女 &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;定位&lt;/label&gt; &lt;select v-model="formData.type"&gt; &lt;option value="刺客"&gt;刺客&lt;/option&gt; &lt;option value="战士"&gt;战士&lt;/option&gt; &lt;option value="辅助"&gt;辅助&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;简介&lt;/label&gt; &lt;textarea cols="30" rows="10" v-model="formData.bio"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" @click.prevent="handleSubmit"&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default &#123; data () &#123; return &#123; formData: &#123; name: '', gender: '', type: '', bio: '' &#125; &#125; &#125;, created () &#123; // console.log(this.$route.params.id) // 不建议在生命周期中写大量的业务代码，最好都封装成 methods 函数 // 需要的时候直接调用 this.loadHero() &#125;, methods: &#123; loadHero () &#123; const id = this.$route.params.id axios(&#123; method: 'GET', url: `http://localhost:3000/heros/$&#123;id&#125;` &#125;).then(res =&gt; &#123; console.log(res.data) this.formData = res.data &#125;) &#125;, handleSubmit () &#123; const id = this.$route.params.id axios(&#123; method: 'PATCH', url: `http://localhost:3000/heros/$&#123;id&#125;`, data: this.formData &#125;).then(res =&gt; &#123; // 跳转到指令路由路径 // VueRouter 提供的 API，专门用于 JavaScript 导航 this.$router.push('/') &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.form &#123; padding: 10px;&#125;&lt;/style&gt; 编译打包项目开发完成后，面临的就是如何将项目进行打包上线，放到服务器中。 1npm run build 打包结果会生成存储到 dist 目录中 dist 目录 css js img … index.html 最后把打包的结果（dist）交给公司负责运维部署人员 运维人员 后端人员 负责部署的人员会把打包结果放到一个 Web 服务器容器中去运行 nginx Apache tomcat 等常见服务器软件 我们可以在本地预览一下打包结果 安装一个全局命令行工具，这个工具可以启动一个静态文件服务器 npm install -g serve serve -s dist 启动服务 然后预览打包结果文件 本地预览测试没有问题之后，把 dist 压缩一下发给负责部署的人员 注意：如果打包结果有问题，不要去修改 dist 中的文件，而是修改 src 源码，完了重新打包生成 dist。 路由懒加载参考文档：官方文档 - 路由懒加载 默认情况下你第1次访问这个网站，就会把所有的组件资源都下载好 好处：切换其它组件页面速度非常快 缺点：如果组件页面比较多，会导致第1次加载速度慢 如果你想提高第1次的加载速度，就是不要让它一次性的下载所有资源，解决方式就是配置路由懒加载 说白了就是我看哪个页面，才下载哪个页面 总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter8-Vue CLI]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter8-Vue%20CLI%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 8 章 Vue CLIVue CLI 是 Vue 的脚手架工具，它可以帮助我们快速生成 Vue 基础项目代码，提供开箱即用的功能特性。 基础代码目录结构 开发服务 本地调试 代码部署 热加载 单元测试 … Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。 官方文档：https://cli.vuejs.org/ GitHub：https://github.com/vuejs/vue-cli 安装 依赖要求： Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。 123$ npm install -g @vue/cli# OR$ yarn global add @vue/cli 使用 vue --version 确认是否安装成功。 注意：仅需安装一次就可以了，以后直接使用即可。 使用 vue --help 查看使用帮助。 创建项目运行以下命令来创建一个新项目 1$ vue create my-project 注意： 如果你在 Windows 上使用 Git Bash ，上面的命令运行之后的创建过程中的交互提示符不会正常工作。你必须通过 winpty vue.cmd create hello-world 来启动这个命令。 选择 default，然后等待安装 继续等待… 安装成功。 最后会提示你使用 cd 命令进入刚刚创建生成的项目中。 启动开发模式： 1npm run serve 等待启动开发服务。。。 开发期间不要关闭，如果关了，就重新 npm run serve 启动开发服务成功。 然后打开浏览器，访问提示的地址。 如果能看到上面的页面，则说明初始化创建成功了。 目录结构 名称 说明 node_modules 第三方包存储目录 public 静态资源，已被托管 src 源代码 .gitignore git 忽略文件，暂时不关心，我们还没有在项目中使用 git babel.config.js 先不关心 package.json 包说明文件 README.md 项目说明文件 package-lock.json 包的版本锁定文件 src 目录结构 名称 说明 chapter8-Vue CLI 资源目录，存储静态资源，例如图片等 components 存储其它组件的目录 App.vue 根组件 main.js 入口文件 程序的启动 找到 main.js 入口 加载 Vue 加载 App 组件 创建 Vue 实例 将 App 组件替换到入口节点 接下来，我们就不再去 html 页面中写模板了，而是一切皆组件。 .vue 单文件组件template 作用：组件的模板 注意：只能有一个根节点（template 本身不算） script 作用：组件的 JavaScript ，用来配置组件的选项（data、methods、watch。。。） 写法规则： 123456789101112&lt;script&gt; // 1. 使用一个普通对象配置组件的选项 const componentOptions = &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125; &#125; // 2. 将这个对象导出（组件的选项对象必须显式的导出，否则不会生效） export default componentOptions&lt;/script&gt; 为了方便，我们可以直接在定义的同时直接导出 12345678&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt; style当 &lt;style&gt; 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。 123456789&lt;style scoped&gt; .example &#123; color: red; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example"&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果： 123456789&lt;style&gt; .example[data-v-f3f3eg9] &#123; color: red; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example" data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 你可以在一个组件中同时使用有 scoped 和非 scoped 样式： 1234567&lt;style&gt; /* 全局样式 */&lt;/style&gt;&lt;style scoped&gt; /* 本地样式 */&lt;/style&gt; 使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。 如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符： 12345&lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; 上述代码将会编译成： 123.a[data-v-f3f3eg9] .b &#123; /* ... */&#125; 单文件组件的定义和使用创建单文件组件 推荐把通用组件创建到 components 目录中 把视图组件定义到 views 目录中 单文件组件只是承载组件的容器而已，既不是全局也不是局部，如果要使用这个单文件组件，必须 注册 全局注册使用，可以在任何组件中使用 局部注册使用，只能在注册的组件中被使用 123456789101112131415&lt;template&gt; &lt;div&gt; foo 组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123;&#125;, methods: &#123;&#125; // ... &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 全局注册使用在 main.js 文件中 1234567...import Vue from 'vue'import Com1 from './components/Com1.vue'...Vue.component('Com1', Com1) 接下来就可以在任何组件中使用 Com1 组件了。 局部注册使用在某个组价中局部注册使用 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;!-- 使用 Com2 组件 --&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Com2 from './components/Com2' export default &#123; components: &#123; Com2 &#125; &#125;&lt;/script&gt; 热重载当使用脚手架工具 vue-cli 时，热重载是开箱即用的。 “热重载”不只是当你修改文件的时候简单重新加载页面。启用热重载后，当你修改 .vue 文件时，该组件的所有实例将在不刷新页面的情况下被替换。它甚至保持了应用程序和被替换组件的当前状态！当你调整模版或者修改样式时，这极大地提高了开发体验。 状态保留规则 当编辑一个组件的 &lt;template&gt; 时，这个组件实例将就地重新渲染，并保留当前所有的私有状态。能够做到这一点是因为模板被编译成了新的无副作用的渲染函数。 当编辑一个组件的 &lt;script&gt; 时，这个组件实例将就地销毁并重新创建。(应用中其它组件的状态将会被保留) 是因为 &lt;script&gt; 可能包含带有副作用的生命周期钩子，所以将重新渲染替换为重新加载是必须的，这样做可以确保组件行为的一致性。这也意味着，如果你的组件带有全局副作用，则整个页面将会被重新加载。 会通过 vue-style-loader 自行热重载，所以它不会影响应用的状态。 函数式组件在一个 *.vue 文件中以单文件形式定义的函数式组件，现在对于模板编译、scoped CSS 和热重载也有了良好的支持。 要声明一个应该编译为函数式组件的模板，请将 functional 特性添加到模板块中。这样做以后就可以省略 &lt;script&gt; 块中的 functional 选项。 模板中的表达式会在函数式渲染上下文中求值。这意味着在模板中，prop 需要以 props.xxx 的形式访问： 123&lt;template functional&gt; &lt;div&gt;&#123;&#123; props.foo &#125;&#125;&lt;/div&gt;&lt;/template&gt; 你可以在 parent 上访问 Vue.prototype 全局定义的属性： 123&lt;template functional&gt; &lt;div&gt;&#123;&#123; parent.$someProperty &#125;&#125;&lt;/div&gt;&lt;/template&gt; 代码校验ECMAScript 6 Module 建议学习文档：http://es6.ruanyifeng.com/#docs/module 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD（require.js 库，专门用于在浏览器中进行模块化开发，几乎已经淘汰了） 两种。前者用于服务器（Node.js），后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 学习准备环境目前无论是 Node.js 还是浏览器都还无法直接原生支持 ECMAScript 6 模块 API（import、export）。 但是对于浏览器来说我们可以使用构建工具将模块代码转换为浏览器能识别的代码。 Node.js 中可以开启实验功能来支持该功能。 为了学习方便，我们这里使用 Node 环境来学习 ES6 模块规则。 首先将你的文件后缀名定义为 .mjs，然后执行这个脚本文件的时候加上 --experimental-modules 选项。 例如我有一个 main.mjs，则执行命令是： 1node --experimental-modules main.mjs 这里只是用于测试学习，不要在生产环境中使用这个模块规则。 foo.js 1234567891011121314151617181920// export 也用于导出// 但是可以多次使用export const a = 1export const b = 2export const c = 3export const d = 4function add(x, y) &#123; return x + y&#125;// 等价于 module.exports = add// export default 只能使用一次export default add// 模块中有多个成员，一般都使用 export xxx// 如果只有一个成员，那就 export default// 有时候也会混搭// 既有 export default 成员（只能有一个）// 也有 export xxx成员（多个） main.js 123456789101112131415161718192021222324// 加载 export default 导出的成员// import foo from './foo'// console.log(foo)// 按需加载 export 导出的成员// import &#123; a, b &#125; from './foo.mjs'// console.log(a, b)// 一次性加载所有成员(包括 default 成员)// import * as foo from './foo.mjs'// console.log(foo)// console.log(foo.a)// console.log(foo.default(10, 3)) // 很少这样去访问 default 成员// 为了方便，先加载默认 default 成员，然后加载 其它 export 成员// import abc, &#123; a, b &#125; from './foo'// console.log(abc) // export default 成员// console.log(a, b) //// 可以使用 as 起别名import &#123; a as aa &#125; from './foo'console.log(aa)// console.log(foo(1, 2)) 导出 export如果模块只有一个成员，建议 export default 1export default 数字|字符串|数组|对象|函数。。。 注意：export default 只能有一次，重复会报错 如果一个模块有多个成员 12345export default &#123; 成员1: 值, 成员2: 值2, 成员3...&#125; 如果成员之间没有依赖关系，不是用于某个数据的完整整体，不推荐，你可能只使用其中某个成员，而必须加载整体数据对象 除非这个对象是一个完整的整体，例如 Vue 组件的实例选项对象，这样是可以的 ECMAScript 6 提供了一种更优化的方案，当多个成员没有具体的依赖关系的时候，我们推荐使用 export 语法进行导出，因为它支持按需加载，就是说你用什么就只加载什么，其它多余的都不要，这样有利于程序的执行效率。 12export const a = 1export const b = 2 也可以集中按需导出多个成员 1234567891011121314151617const a = 1const b = 2const c = 3// 语法就是这样，后面的成员也不是对象的简写方式， &#123;&#125; 中的成员必须当前模块能够访问的成员名称export &#123; // 不是 a: a 的简写，必须 a // a 必须是当前模块中的某个成员 a, b, c&#125;// 以上写法等价于// export const a = 1// export const b = 2// export const c = 3 有时候模块中有很多成员的时候，我们会 export default 和 export 一起使用。 我们把最常用的使用 export default 导出，把不太常用的使用 export 导出（用于按需加载）。 123456export const a = 1export const b = 2export default function(x, y) &#123; return x + y&#125; 导入 import加载 export default 成员 1import xxx from '模块路径' 按需加载 export 成员 1import &#123; 成员1 as 别名, 成员2... &#125; from '模块路径' 混着加载 export default 和 export 成员 1import xxx, &#123; 成员1, 成员2... &#125; from '模块路径' 一次性加载所有成员 1import * as xxx from '模块路径' 包括 export default 和 export 所有成员 export default 就是一个名字叫 default 的成员，知道即可，不推荐这样来使用 xxx.default 相关命令12345678# 启动开发服务npm run serve# 项目打包npm run build# 代码检查npm run lint]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter7-Vue Router]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter7-Vue%20Router%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 7 章 Vue Router单页面应用程序几个比较典型的单页面应用程序网站： 网易云音乐 CODING 。。。 单页应用（英语：single-page application，缩写SPA）是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。 单页应用的出现不可考。从 Wikipedia 上可以看到，起源很早，甚至可以追溯到2002年。你可能会说，这不是什么新概念，Google 的 Gmail 就是一个单页应用，可追溯到2004年到2005年。但这个概念火热起来在2010年，Backbone 问世之后。随着后来的 Knockout、Ember.js、AngularJS 的兴起，单页应用开始家喻户晓起来。2015年 React 的出现，Virtual DOM 横扫了各种 MV* 框架，单页应用框架甚至进入到了一个新的时代。目前主流的前端开发框架都可以让你轻松的构建单页面应用程序。 SPA技术将逻辑从服务器转移到了客户端。这导致Web服务器发展为一个纯数据API或Web服务。这种架构的转变在一些圈子中被称为“瘦服务器架构”，以强调复杂性已从服务端转移到客户端，并认为这最终降低了系统的整体复杂性。 下面是单页面应用和传统的多页面应用各自的交互方式： 多页面应用，多页面跳转刷新所有资源： 在传统的网页应用中，浏览器更多的是充当一个展示层，路由处理、服务调用、页面跳转流程都由服务端来处理。即 MVC 都放在服务器端，而 V 作为用户界面则通过网络发送到浏览器端，作为 UI 与用户交互。 这样的范式有以下特点： 重服务端，由于 MVC 都存在于服务器上，因此这类应用在开发资源和开发的重心都偏向后端，往往是后端工程师来主导整个项目开发； 页面频繁刷新，由于浏览器端只是一个展现层，当页面功能有所变化的时，页面就刷新，这会导致资源的浪费，用户需要花费额外的时间等待页面刷新，用户体验不佳。 单页面应用，只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次： 优缺点优点： 增强用户体验，这个应该是最显著的有点，由于路由分发直接在浏览器端完成，页面是不刷新，对用户的响应非常及时，因此提升了用户体验 减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍 完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整 良好的前后端分离开发，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起 缺点： 不利于 SEO，单页页面，数据在前端渲染，就意味着没有 SEO，或者需要使用变通的方案 不过目前可以配置服务端渲染来解决这个问题，但还不够足够成熟 初次加载耗时相对增多，要在一个页面上为用户提供产品的所有功能，在这个页面加载的时候，首先要加载大量的静态资源，这个加载时间相对比较长 较高的前端开发门槛，对开发人员技能水平要求较高，不再是『切切图，画画页面这么简单』 低版本浏览器兼容差 单页面导航路径 概念 路径 一般使用锚点，也就是 hash 作为页面导航的路径标识 为什么？因为正常的 url 地址会发请求，而 hash 锚点不会发请求刷新页面 VueRouter 内部监视了 hash 的改变 window.onhashchange 然后根据 hash 的改变去展示路由规则中配置的组件 Vue Router 默认要求 hash 导航路径都以 #/ 开头 为什么？ 主要是为了和正常的 hash 锚点（网页内部定位，id）作区别 例如我们使用锚点内部定位的时候，需要给元素起 id，我们几乎不会给这个 id 起名为 /xxx 如果 VueRouter 没有 #/ 的规则，例如直接 #foo 就可能会和你锚点的那个 id foo 冲突。 有人会说，能不能让 url 漂亮点儿，不要使用 hash 呢？ 可以。 我们可以利用 HTML5 history 的的方式使用传统的 url。（我们可以用 JavaScript 代码控制 url）。 VueRouter 默认是 hash 路径模式 它也支持传统的 url 模式（HTML5 history）https://router.vuejs.org/zh/guide/#html 需要额外的服务器配置 工作原理 HTML5 History API 优雅 同构应用友好 Hash 兼容性好 History API onpopstate 响应历史记录改变的一个事件 pushState 创建历史记录 前进，后退，控制 一共两个需求： 执行打开页面的操作 历史操作记录 Hash hashchange location.hash 安装直接下载 / CDNhttps://unpkg.com/vue-router/dist/vue-router.js 在 Vue 后面加载 vue-router，它会自动安装的： 12&lt;script src="/path/to/vue.js"&gt;&lt;/script&gt;&lt;script src="/path/to/vue-router.js"&gt;&lt;/script&gt; NPM1npm install vue-router 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能： 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) 如果使用全局的 script 标签，则无须如此 (手动安装)。 Hello World用 Vue.js + Vue Router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。下面是个基本例子： 12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！ 动态路由匹配 https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html 嵌套路由 https://router.vuejs.org/zh/guide/essentials/nested-routes.html 编程式导航 https://router.vuejs.org/zh/guide/essentials/navigation.html 命名路由 命名视图 重定向和别名 相关 API路由对象 this.\$route一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。 路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象。 路由对象出现在多个地方: 在组件内，即 this.$route 在 $route 观察者回调内 router.match(location) 的返回值 \$route.path 类型: string 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 \$route.params 类型: Object 一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 \$route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 \$route.hash 类型: string 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 \$route.fullPath 类型: string 完成解析后的 URL，包含查询参数和 hash 的完整路径。 \$route.matched 类型: Array&lt;RouteRecord&gt; 一个数组，包含当前路由的所有嵌套路径片段的路由记录 。路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。 12345678910111213const router = new VueRouter(&#123; routes: [ // 下面的对象就是路由记录 &#123; path: '/foo', component: Foo, children: [ // 这也是个路由记录 &#123; path: 'bar', component: Bar &#125; ] &#125; ]&#125;) 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象 (副本)。 \$route.name 当前路由的名称，如果有的话。(查看命名路由) \$route.redirectedFrom 如果存在重定向，即为重定向来源的路由的名字。(参阅重定向和别名) Router 实例 我们在组件中访问的 this.\$router 就是路由文件中创建的路由实例 API 作用 备注 push 跳转，会形成历史记录 想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。 replace 路径替换 跳过去，别回来了 go 跳转到指定步骤的路由 back 后退一步 forward 前进一步]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter6-过渡&动画]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter6-%E8%BF%87%E6%B8%A1%26%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 6 章 过渡&amp;动画 https://www.jianshu.com/p/109f532928b0 https://github.com/daneden/animate.css https://segmentfault.com/a/1190000012919963 概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 在这里，我们只会讲到进入、离开和列表的过渡，你也可以看下一节的 管理过渡状态。 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 这里是一个典型的例子： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;过渡和动画&lt;/title&gt; &lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s; &#125; .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; show: true &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同) 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。 CSS 过渡常用的过渡都是使用 CSS 过渡。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter5-组件基础]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter5-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 5 章 组件基础 学习目标 了解组件的概念 掌握组件的定义 了解组件的组织方式 掌握组件通信 组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。 通过 Element 感受组件Element 是饿了么前端团队基于 Vue 开发的一个知名的第三方组件库，它能帮助我们更加快速的构建应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;感受组件的威力&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;!-- 引入组件库样式 --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h1&gt;感受组件的威力&lt;/h1&gt; &lt;h2&gt;Button 按钮&lt;/h2&gt; &lt;el-button&gt;默认按钮&lt;/el-button&gt; &lt;el-button type="primary"&gt;主要按钮&lt;/el-button&gt; &lt;el-button type="success"&gt;成功按钮&lt;/el-button&gt; &lt;el-button type="info"&gt;信息按钮&lt;/el-button&gt; &lt;el-button type="warning"&gt;警告按钮&lt;/el-button&gt; &lt;el-button type="danger"&gt;危险按钮&lt;/el-button&gt; &lt;h2&gt;文本框&lt;/h2&gt; &lt;el-input v-model="input" placeholder="请输入内容" clearable&gt;&lt;/el-input&gt; &lt;el-input-number v-model="num" :min="1" :max="10" label="描述文字"&gt;&lt;/el-input-number&gt; &lt;h2&gt;日期选择器&lt;/h2&gt; &lt;el-date-picker v-model="value1" type="date" placeholder="选择日期"&gt; &lt;/el-date-picker&gt; &lt;/div&gt; &lt;!-- 引入 VUe.js --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; input: '', num: 1, value1: '' &#125;, methods: &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 体验： 体验总结： 组件就是对局部视图的封装（HTML、CSS、JavaScript）；从使用角度，组件就是一个自定义标签 开发效率高 每个组件的代码都是独立的，不会因为所有代码都混在一起查找麻烦而导致开发效率低下 简单易用，快速完成任务 便于团队分工协作 可维护性高 哪里有问题，就找哪个组件 可重用性好 组件化开发不是 Vue 独创，早期的 Angular 在自定义指令中有了一点组件化的概念，但还不够彻底，直到 React 的诞生，一种完全基于组件化开发方式的前端框架。随后 Angular 等其它框架都纷纷效仿提供了组件化的开发模式，Vue 的诞生也是吸取了 Angular 和 React 等其他框架的一些核心概念，所以从诞生之初就具有组件化的开发支持。 目前主流框架的开发模式都是组件化开发。 基本语法示例定义一个名为 button-counter 的组件：12345678Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 123&lt;div id="app"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 1new Vue(&#123; el: '#app' &#125;) 123456&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;lipengzhou&quot; data-slug-hash=&quot;ZdWOep&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;组件示例&quot;&gt; &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/lipengzhou/pen/ZdWOep/&quot;&gt; 组件示例&lt;/a&gt; by LPZ (&lt;a href=&quot;https://codepen.io/lipengzhou&quot;&gt;@lipengzhou&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;&lt;script async src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt; 123456&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;js,result&quot; data-user=&quot;lipengzhou&quot; data-slug-hash=&quot;wLGGxY&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;wLGGxY&quot;&gt; &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/lipengzhou/pen/wLGGxY/&quot;&gt; wLGGxY&lt;/a&gt; by LPZ (&lt;a href=&quot;https://codepen.io/lipengzhou&quot;&gt;@lipengzhou&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;&lt;script async src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt; 组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 组件的复用你可以将组件进行任意次数的复用：12345&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 组件的 data 必须是函数当我们定义这个 &lt;button-counter&gt; 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象： 123data: &#123;count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到其它所有实例： 私有作用域 内部无法访问外部 外部无法访问内部 组件注册方式组件的注册方式有两种方式 全局组件 定义在全局，在任意组件中都可以直接使用 局部组件 定义在组件内部，只能在当前组件使用 建议把通用的组件定义在全局，把不通用的组件定义在局部。 全局注册注册：12345678Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;);// 创建根实例new Vue(&#123; el: '#example'&#125;); 在模板中使用组件：123&lt;div id="example"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 渲染结果：123&lt;div id="example"&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 总结： 可以在任何组件中被使用的组件（就好比全局变量） 如果应用中把所有组件都定义成全局组件，名字就不能冲突 使用场景：多个页面都需要使用的组件建议定义成全局 局部注册你不必把每个组件都注册到全局。你可以通过某个 Vue 实例/组件的实例选项 components 注册仅在其作用域中可用的组件： 注册：123456789new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父组件模板中可用 'my-component': &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' &#125; &#125;&#125;) 使用： 1234&lt;div id="example"&gt; &lt;div&gt;A custom component!&lt;/div&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 总结： 只能在它的父组件(定义所属的组件)中被使用，不会污染全局（就好比函数内定义的变量） 使用组件的时候，会先在自己的 components 中找，如果找不到，直奔 全局找 局部组件 只能 在父组件中被使用，爷爷、后代。。。都不行 使用场景：不需要在其它组件中被使用的组件建议定义成局部 小结 组件的模板组件的 tempalte 支持以下三种使用方式： 字符串(例如：template: &#39;…&#39;) .vue 单文件组件中的 template 模板 script 标签模板(了解) 字符串123Vue.component('hello-world', &#123; template: `&lt;p&gt;Hello World!&lt;/p&gt;`&#125;) .vue 单文件12345678910111213141516171819202122232425262728293031&lt;!-- 组件的模板 --&gt;&lt;template&gt; &lt;div class="count-box"&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;button @click="handleIncrement"&gt;点击+1&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;!-- 组件的行为 --&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; handleIncrement () &#123; this.count++ &#125; &#125; &#125;&lt;/script&gt;&lt;!-- 组件的样式 --&gt;&lt;style&gt;.count-box &#123; padding: 5px; border: 1px solid #000;&#125;&lt;/style&gt; 注意：该文件无法直接运行在浏览器中，需要使用 webpack 或 Vue 官方提供的 VueCLI 等构建工具将其编译打包才可以运行到浏览器中。 script 标签模板（了解即可）123&lt;script type="text/x-template" id="xxx"&gt; 模板字符串&lt;/script&gt; 123Vue.component('组件名字', &#123; template: '#xxx' // script 标签id&#125;) 小结 字符串模板 优点：适合快速学习测试，方便快捷 缺点：编辑器无法提供高亮显示、智能提示等功能 .vue 单文件组件 优点：更好的语法高亮、智能提示等功能 缺点：需要配合打包工具使用 script 标签模板（了解） 总结： 学习测试使用字符串模板就可以了 真正做项目当然是 .vue 单文件组件了 script 标签模板了解即可 组件通信组件就像零散的积木，我们需要把这些积木按照一定的规则拼装起来，而且要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。 在真实的应用中，组件最终会构成树形结构，就像人类社会中的家族树一样： 在树形结构里面，组件之间有几种典型的关系：父子关系、兄弟关系、没有直接关系。 相应地，组件之间有以下几种典型的通讯方案： 直接的父子关系 父组件通过 this.$refs 访问子组件 子组件 this.$parent 访问其父组件 直接父子关系 父组件通过 Props 给子组件下发数据 子组件通过事件方式给父组件发送消息 没有直接关系 简单场景：借助于事件机制进行通讯 复杂场景：使用状态管理容器（例如 Vue 生态中的 Vuex、React 生态中的 Redux、Mobx 等） 利用 cookie 和 localstorage 进行通讯 利用 session 进行通讯 无论你使用什么前端框架，组件之间的通讯都离开不以上几种方案，这些方案与具体框架无关。 父子组件通信组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。 父传子(Props Down)1. 在父组件中通过子组件标签属性传递数据 1&lt;child message="hello!"&gt;&lt;/child&gt; 2. 在子组件显式地用 props 选项声明它预期的数据并使用 1234567Vue.component('child', &#123; // 必须显式的声明接收 props props: ['message'], // 就像 data 一样，prop 也可以在模板中使用 // 同样也可以在 vm 实例中通过 this.message 来使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;); camelCase vs. kebab-caseHTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)。 12345Vue.component('child', &#123; // 在 JavaScript 中使用 camelCase props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;); 12&lt;!-- 在 HTML 中使用 kebab-case --&gt;&lt;child my-message="hello!"&gt;&lt;/child&gt; 如果你使用字符串模板，则没有这些限制。 动态 Prop与绑定到任何普通的 HTML 特性相类似，我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件： 12345&lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt;&lt;/div&gt; 你也可以使用 v-bind 的缩写语法： 1&lt;child :my-message="parentMsg"&gt;&lt;/child&gt; 字面量语法 vs 动态语法初学者常犯的一个错误是使用字面量语法传递数值： 12&lt;!-- 传递了一个字符串 "1" --&gt;&lt;comp some-prop="1"&gt;&lt;/comp&gt; 因为它是一个字面量 prop，它的值是字符串 “1” 而不是一个数值。如果想传递一个真正的 JavaScript 数值，则需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算： 12&lt;!-- 传递真正的数值 --&gt;&lt;comp v-bind:some-prop="1"&gt;&lt;/comp&gt; 单向数据流Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。 在两种情况下，我们很容易忍不住想去修改 prop 中数据： Prop 作为初始值传入后，子组件想把它当作局部数据来用 Prop 作为原始数据传入，由子组件处理成其它数据输出 对这两种情况，正确的应对方式是： 1. 定义一个局部变量，并用 prop 的值初始化它： 12345678910props: ['initialCounter'],data: function () &#123; // var a = 1 // var b = a // a = 123 // b ? // b 456 // a ? return &#123; counter: this.initialCounter &#125;&#125; 2. 定义一个计算属性，处理 prop 的值并返回：1234567// ...props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125;, 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。即便引用类型可以，也不要利用这个特性，记住一个原则：组件的数据状态在组件内部管理维护，不要在其他位置去修改它。 Prop 验证我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 指允许任何类型) propA: Number, // 可能是多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数值且有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;); type 可以是下面原生构造器： String Number Boolean Function Object Array Symbol type 也可以是一个自定义构造器函数，使用 instanceof 检测。 当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 子传父(Events Up)我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。 1. 在子组件中调用 $emit() 方法发布一个事件123456789101112131415Vue.component('button-counter', &#123; template: '&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1 // 发布一个名字叫 increment 的事件 this.$emit('increment') &#125; &#125;,&#125;); 2. 在父组件中提供一个子组件内部发布的事件处理函数 1234567891011new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;); 3. 在使用子组件的模板的标签上订阅子组件内部发布的事件 12345678&lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;!-- 订阅子组件内部发布的 increment 事件 当子组件内部 $commit('increment') 发布的时候，就会调用到父组件中的 incrementTotal 方法 --&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt; 给组件绑定原生事件有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如： 12当做自定义事件去绑定&lt;my-component v-on:click="doTheThing"&gt;&lt;/my-component&gt; 12将 click 事件注册到组件的根元素&lt;my-component v-on:click.native="doTheThing"&gt;&lt;/my-component&gt; .sync 修饰符在一些情况下，我们可能会需要对一个 prop 进行“双向绑定”。就是当一个子组件改变了一个带 .sync 的 prop 的值时，这个变化也会同步到父组件中所绑定的值。 在使用子组件的时候加上 .sync 修饰符： 1&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; 在子组件内部更新 foo 的值时，显示的触发一个更新事件： 1this.$emit(&apos;update:foo&apos;, newValue); 非父子组件通信简单场景：Event Bus有时候，非父子关系的两个组件之间也需要通信。在简单的场景下，可以使用一个空的 Vue 实例作为事件总线： 1var bus = new Vue(); 12// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1); 1234// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) &#123; // ...&#125;); 复杂场景：Vuex在复杂的情况下，我们应该考虑使用专门的 状态管理模式。 使用插槽分发内容组件其它]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter4-和服务端通信]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter4-%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 4 章 和服务端通信概述Vue 不像 jQuery 内置了 ajax 请求函数，在 Vue 中没有提供这样的功能。所以当我们需要在 Vue 中和服务端进行通信的时候可选择的方式会更灵活一些。 注意：Vue 不提供的原因是为了让 Vue 本身更专注于视图部分，保持其渐进灵活的特性。 所以 Vue 给了我们更多的选择空间，例如我们可以使用下面的可选方案： 原生的 XMLHttpRequest 原生的 Fetch 也可以结合使用 jQuery 自带的 Ajax 请求函数 早期大家开发 Vue 应用喜欢使用一个第三方插件：Vue Resource 目前主流的方案是使用社区中知名的第三方库 axios … 学习准备启动接口服务Windows 用户： 双击 03-与服务端通信/api-server 目录中的 启动服务.bat 文件启动服务。 非 Windows 用户： 123# 在终端中进入 api-server 目录# 使用下面的命令启动服务$ npm start 启动成功会看到如下提示： 接口说明 接口默认占用 3000端口 所有请求的基准路径都是 http://localhost:3000 获取所有英雄列表 请求方法 GET 请求路径 /heros 请求参数 name 根据英雄名称查询英雄列表，可选的 例如：/heros?name=李白 添加英雄 请求方法 POST 请求路径 /heros 请求体 123456&#123; "name": "名字", "gender": "性别", "type": "定位", "bio": "简介"&#125; 修改英雄 请求方法 PATCH 请求路径 /heros/数据id 例如：/heros/1、/heros/2 请求体 1234&#123; "name": "名字", "bio": "简介"&#125; 被修改的 name 和 bio 都是可选的 删除英雄 请求方法 DELETE 请求路径 /heros/数据id 例如 /heros/1、/heros/2 axios是什么axios 是一个基于 Promise 的第三方 HTTP 客户端请求库，可以用于浏览器或者 Node.js。axios 本身和 Vue 没有一毛钱关系，只是简单纯粹的封装了 HTTP 请求功能。可以运行在任何支持 JavaScript 环境的平台。 Github 仓库 特色 在浏览器端使用的是 XMLHttpRequest 在 Node 中使用的是 http 支持 Promise 支持请求拦截和响应拦截 支持转换请求和响应数据 支持取消请求 自动转换 JSON 数据 客户端支持防止 XSRF 兼容性 axios 依赖原生的 ECMAScript 6 Promise 支持。 如果浏览器不支持 ECMAScript 6 Promise，可以使用 es6-promise 进行兼容处理。 起步安装使用 npm: 1$ npm install axios 使用 bower（一个类似于 npm 的包管理工具，几乎已经淘汰）: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 执行一个 GET 请求12345678910111213141516171819202122232425262728293031323334353637383940414243const axios = require('axios')// Make a request for a user with a given IDaxios .get('/user?ID=12345') .then(function(response) &#123; // handle success console.log(response) &#125;) .catch(function(error) &#123; // handle error console.log(error) &#125;) .then(function() &#123; // always executed &#125;)// Optionally the request above could also be done asaxios .get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function(response) &#123; console.log(response) &#125;) .catch(function(error) &#123; console.log(error) &#125;) .then(function() &#123; // always executed &#125;)// Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345') console.log(response) &#125; catch (error) &#123; console.error(error) &#125;&#125; 执行一个 POST 请求1234567891011axios .post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function(response) &#123; console.log(response) &#125;) .catch(function(error) &#123; console.log(error) &#125;) 执行多个并发请求12345678910111213function getUserAccount() &#123; return axios.get('/user/12345')&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions')&#125;axios.all([getUserAccount(), getUserPermissions()]).then( axios.spread(function(acct, perms) &#123; // Both requests are now complete &#125;)) axios APIaxios(config)我们可以像使用 $.ajax() 一样来使用 axios。 123456789// Send a POST requestaxios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;) 12345678// GET request for remote imageaxios(&#123; method: 'get', url: 'http://bit.ly/2mTM3nY', responseType: 'stream'&#125;).then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;) axios(url[, config])12// Send a GET request (default method)axios('/user/12345') 请求方法别名为了方便，axios 为所有的请求方法都提供了别名支持。 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意：当使用了这些别名方法时，url, method 和 data 属性不需要声明在配置对象中。 并发请求axios 提供了辅助函数用来处理并发请求。 axios.all(iterable) axios.spread(callback) axios 实例可以创建一个新的 axios 实例进行自定义配置。 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123; 'X-Custom-Header': 'foobar' &#125;&#125;) 实例方法实例拥有和 axios 基本一样的能力。 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#options(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) axios#getUri([config]) 请求配置对象下面是所有的可参考配置项。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&#123; // `url` is the server URL that will be used for the request "url": "/user", // `method` is the request method to be used when making the request "method": "get", // default // `baseURL` will be prepended to `url` unless `url` is absolute. // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs // to methods of that instance. "baseURL": "https://some-domain.com/api/", // `transformRequest` allows changes to the request data before it is sent to the server // This is only applicable for request methods 'PUT', 'POST', and 'PATCH' // The last function in the array must return a string or an instance of Buffer, ArrayBuffer, // FormData or Stream // You may modify the headers object. "transformRequest": [ function(data, headers) &#123; // Do whatever you want to transform the data return data &#125; ], // `transformResponse` allows changes to the response data to be made before // it is passed to then/catch "transformResponse": [ function(data) &#123; // Do whatever you want to transform the data return data &#125; ], // `headers` are custom headers to be sent "headers": &#123; "X-Requested-With": "XMLHttpRequest" &#125;, // `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object "params": &#123; "ID": 12345 &#125;, // `paramsSerializer` is an optional function in charge of serializing `params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) "paramsSerializer": function(params) &#123; return Qs.stringify(params, &#123; "arrayFormat": "brackets" &#125;) &#125;, // `data` is the data to be sent as the request body // Only applicable for request methods 'PUT', 'POST', and 'PATCH' // When no `transformRequest` is set, must be of one of the following types: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer "data": &#123; "firstName": "Fred" &#125;, // `timeout` specifies the number of milliseconds before the request times out. // If the request takes longer than `timeout`, the request will be aborted. "timeout": 1000, // default is `0` (no timeout) // `withCredentials` indicates whether or not cross-site Access-Control requests // should be made using credentials "withCredentials": false, // default // `adapter` allows custom handling of requests which makes testing easier. // Return a promise and supply a valid response (see lib/adapters/README.md). "adapter": function(config) &#123; /* ... */ &#125;, // `auth` indicates that HTTP Basic auth should be used, and supplies credentials. // This will set an `Authorization` header, overwriting any existing // `Authorization` custom headers you have set using `headers`. "auth": &#123; "username": "janedoe", "password": "s00pers3cret" &#125;, // `responseType` indicates the type of data that the server will respond with // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' "responseType": "json", // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of 'stream' or client-side requests "responseEncoding": "utf8", // default // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token "xsrfCookieName": "XSRF-TOKEN", // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value "xsrfHeaderName": "X-XSRF-TOKEN", // default // `onUploadProgress` allows handling of progress events for uploads "onUploadProgress": function(progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` allows handling of progress events for downloads "onDownloadProgress": function(progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength` defines the max size of the http response content in bytes allowed "maxContentLength": 2000, // `validateStatus` defines whether to resolve or reject the promise for a given // HTTP response status code. If `validateStatus` returns `true` (or is set to `null` // or `undefined`), the promise will be resolved; otherwise, the promise will be // rejected. "validateStatus": function(status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300 // default &#125;, // `maxRedirects` defines the maximum number of redirects to follow in node.js. // If set to 0, no redirects will be followed. "maxRedirects": 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. "socketPath": null, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. "httpAgent": new http.Agent(&#123; "keepAlive": true &#125;), "httpsAgent": new https.Agent(&#123; "keepAlive": true &#125;), // 'proxy' defines the hostname and port of the proxy server. // You can also define your proxy using the conventional `http_proxy` and // `https_proxy` environment variables. If you are using environment variables // for your proxy configuration, you can also define a `no_proxy` environment // variable as a comma-separated list of domains that should not be proxied. // Use `false` to disable proxies, ignoring environment variables. // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and // supplies credentials. // This will set an `Proxy-Authorization` header, overwriting any existing // `Proxy-Authorization` custom headers you have set using `headers`. "proxy": &#123; "host": "127.0.0.1", "port": 9000, "auth": &#123; "username": "mikeymike", "password": "rapunz3l" &#125; &#125;, // `cancelToken` specifies a cancel token that can be used to cancel the request // (see Cancellation section below for details) "cancelToken": new CancelToken(function(cancel) &#123;&#125;)&#125; 响应体结构请求的响应包含以下信息。 12345678910111213141516171819202122&#123; // `data` is the response that was provided by the server "data": &#123;&#125;, // `status` is the HTTP status code from the server response "status": 200, // `statusText` is the HTTP status message from the server response "statusText": "OK", // `headers` the headers that the server responded with // All header names are lower cased "headers": &#123;&#125;, // `config` is the config that was provided to `axios` for the request "config": &#123;&#125;, // `request` is the request that generated this response // It is the last ClientRequest instance in node.js (in redirects) // and an XMLHttpRequest instance the browser "request": &#123;&#125;&#125; 当使用 then 方法时，将收到如下结果 1234567axios.get('/user/12345').then(function(response) &#123; console.log(response.data) console.log(response.status) console.log(response.statusText) console.log(response.headers) console.log(response.config)&#125;) 默认配置全局 axios 配置1234axios.defaults.baseURL = 'https://api.example.com'axios.defaults.headers.common['Authorization'] = AUTH_TOKENaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded' 自定义 axios 实例配置1234567// Set config defaults when creating the instanceconst instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;)// Alter defaults after instance has been createdinstance.defaults.headers.common['Authorization'] = AUTH_TOKEN 配置的优先级当全局、实例、请求出现相同的 config 配置项时，优先级如下 请求的 config 实例的 config 全局的 config 自上而下 例如下面的情况： 123456789101112// Create an instance using the config defaults provided by the library// At this point the timeout config value is `0` as is the default for the libraryconst instance = axios.create()// Override timeout default for the library// Now all requests using this instance will wait 2.5 seconds before timing outinstance.defaults.timeout = 2500// Override timeout for this request as it's known to take a long timeinstance.get('/longRequest', &#123; timeout: 5000&#125;) 拦截器axios 支持在处理请求或响应之前拦截请求或响应。 1234567891011121314151617181920212223// Add a request interceptoraxios.interceptors.request.use( function(config) &#123; // Do something before request is sent return config &#125;, function(error) &#123; // Do something with request error return Promise.reject(error) &#125;)// Add a response interceptoraxios.interceptors.response.use( function(response) &#123; // Do something with response data return response &#125;, function(error) &#123; // Do something with response error return Promise.reject(error) &#125;) 也可以删除拦截器 1234const myInterceptor = axios.interceptors.request.use(function() &#123; /*...*/&#125;)axios.interceptors.request.eject(myInterceptor) 也可以为自定义 axios 实例添加拦截器 1234const instance = axios.create()instance.interceptors.request.use(function() &#123; /*...*/&#125;) 处理错误123456789101112131415161718axios.get('/user/12345').catch(function(error) &#123; if (error.response) &#123; // The request was made and the server responded with a status code // that falls out of the range of 2xx console.log(error.response.data) console.log(error.response.status) console.log(error.response.headers) &#125; else if (error.request) &#123; // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js console.log(error.request) &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message) &#125; console.log(error.config)&#125;) 可以使用 validateStatus 配置选项定义自定义 HTTP 状态代码错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function(status) &#123; return status &lt; 500 // Reject only if the status code is greater than or equal to 500 &#125;&#125;) 取消请求可以使用取消令牌取消 token。 可以使用 CancelToken.source 工厂函数创建取消令牌，如下所示： 123456789101112131415161718192021222324252627const CancelToken = axios.CancelTokenconst source = CancelToken.source()axios .get('/user/12345', &#123; cancelToken: source.token &#125;) .catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message) &#125; else &#123; // handle error &#125; &#125;)axios.post( '/user/12345', &#123; name: 'new name' &#125;, &#123; cancelToken: source.token &#125;)// cancel the request (the message parameter is optional)source.cancel('Operation canceled by the user.') 还可以通过将函数执行程序传递给 Cancel Token 构造函数来创建取消令牌： 123456789101112const CancelToken = axios.CancelTokenlet cancelaxios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // An executor function receives a cancel function as a parameter cancel = c &#125;)&#125;)// cancel the requestcancel() 注意：可以使用相同的取消令牌取消多个请求。 使用 application/x-www-form-urlencoded默认情况下，axios 将 JavaScript 对象序列化为 JSON。要以 application / x-www-form-urlencoded 格式发送数据，您可以使用以下选项之一。 浏览器端在浏览器中，您可以使用 URLSearchParams API，如下所示： 1234const params = new URLSearchParams()params.append('param1', 'value1')params.append('param2', 'value2')axios.post('/foo', params) 有些浏览器还不支持 URLSearchParms，可以使用这个 polyfill 做兼容处理。 另外也可以使用 qs 来进行处理 12const qs = require('qs')axios.post('/foo', qs.stringify(&#123; bar: 123 &#125;)) 或者在 ECMAScript 6 中 123456789import qs from 'qs'const data = &#123; bar: 123 &#125;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url&#125;axios(options) Node.js在 node.js 中，您可以使用 querystring 模块，如下所示： 12const querystring = require('querystring')axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)) 你也可以使用 qs。 注意：querystring 模块不支持嵌套对象，qs 模块支持。 发送文件axios 支持发送 XHR 2.0 中新增的 FormData 对象。 12345678910const formData = new FormData()formData.append('file', document.getElementById('file').files[0])axops(&#123; method: 'POST', url: 'xxx', data: formData&#125;).then(res =&gt; &#123; console.log(res)&#125;) axios 会自动识别数据对象 FormData，并将请求头中的 Content-Type 设置为 multipart/form-data。 在 Vue 中配合使用 axiosCRUD 练习列表加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CRUD案例-英雄管理&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;!-- --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;CRUD案例-英雄管理&lt;/h1&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;简介&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in heros&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.bio &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button&gt;删除&lt;/button&gt; &lt;button&gt;编辑&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; heros: [] &#125;, methods: &#123;&#125;, // Vue 初始化完成以后会自动调用这个函数 // 例如我们需要页面加载好去发请求的操作就建议写到这里 created () &#123; axios(&#123; method: &apos;GET&apos;, url: &apos;http://localhost:3000/heros&apos; &#125;).then(res =&gt; &#123; // 模板只能使用 Vue 实例中的数据 // 所以我们要做的就是把请求得到的数据放到 Vue 实例中 this.heros = res.data &#125;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除添加RESTful 接口规范 参考阅读： 理解 RESTful 架构 RESTful API 设计指南 RESTful API 最佳实践 接口测试 Postman查询添加删除修改其它Content-Typeapplication/x-www-form-urlencodedmultipart/form-datatext/plainapplication/json跨域问题JSONP服务器代理跨域CORS 后端跨域 后端跨域 HTTP访问控制（CORS） 其它]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter3-基础案例]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter3-%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 3 章 基础案例 学习目标： 掌握 Vue.js 基础语法 案例基本会涵盖到以下内容知识点： 数据绑定 计算属性 computed 侦听器 watch Class 与 Style 样式处理 条件渲染 列表渲染 事件处理 表单输入双向数据绑定 组件… 案例介绍 TodoMVC 官网 TodoMVC 模板 需求说明 TodoMVC 需求说明 脑图整理的需求说明 [ ] 列表展示 有数据渲染内容区域 无数据隐藏内容区域 添加任务 删除任务 任务项 切换单个任务项的完成状态 任务项的完成状态样式 切换所有任务的完成状态 显式剩余任务数量 清除所有已完成任务项 初始化下载模板123456789$ git clone https://github.com/tastejs/todomvc-app-template.git# 切换到 todomvc-vue 目录中，安装依赖项cd todomvc-vue# 安装依赖npm install# 安装完成，打开 index.html 预览模板。 导入 Vue 安装 Vue 到项目中 1$ npm i vue 在页面中引入 vue.js 脚本文件 在 js/app.js 中 1234567new Vue(&#123; el: '#app', data: &#123; foo: 'bar' &#125;, methods: &#123;&#125;&#125;) 任务列表12345678&lt;li class="completed" v-for="item in todos"&gt; &lt;div class="view"&gt; &lt;input class="toggle" type="checkbox" checked /&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class="destroy"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class="edit" value="Create a TodoMVC template" /&gt;&lt;/li&gt; 状态处理 12345678&lt;li :class="&#123; completed: item.completed &#125;" v-for="item in todos"&gt; &lt;div class="view"&gt; &lt;input class="toggle" type="checkbox" v-model="item.completed" /&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class="destroy"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class="edit" value="Create a TodoMVC template" /&gt;&lt;/li&gt; 没有数据的时候隐藏内容区域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template v-if="todos.length &gt; 0"&gt; &lt;!-- This section should be hidden by default and shown when there are todos --&gt; &lt;section class="main"&gt; &lt;input id="toggle-all" class="toggle-all" type="checkbox" /&gt; &lt;label for="toggle-all"&gt;Mark all as complete&lt;/label&gt; &lt;ul class="todo-list"&gt; &lt;!-- These are here just to show the structure of the list items --&gt; &lt;!-- List items should get the class `editing` when editing and `completed` when marked as completed --&gt; &lt;!-- 任务项 completed 已完成 editing 编辑中 空 未完成 --&gt; &lt;li :class="&#123; completed: item.completed &#125;" v-for="item in todos"&gt; &lt;div class="view"&gt; &lt;input class="toggle" type="checkbox" v-model="item.completed" /&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button class="destroy"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class="edit" value="Create a TodoMVC template" /&gt; &lt;/li&gt; &lt;!-- &lt;li&gt; &lt;div class="view"&gt; &lt;input class="toggle" type="checkbox"&gt; &lt;label&gt;Buy a unicorn&lt;/label&gt; &lt;button class="destroy"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class="edit" value="Rule the web"&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/section&gt; &lt;!-- This footer should hidden by default and shown when there are todos --&gt; &lt;footer class="footer"&gt; &lt;!-- This should be `0 items left` by default --&gt; &lt;span class="todo-count"&gt;&lt;strong&gt;0&lt;/strong&gt; item left&lt;/span&gt; &lt;!-- Remove this if you don't implement routing --&gt; &lt;ul class="filters"&gt; &lt;li&gt; &lt;a class="selected" href="#/"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/completed"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- Hidden if no completed items are left ↓ --&gt; &lt;button class="clear-completed"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt;&lt;/template&gt; &#123;2,15&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445...&lt;template v-if="todos.length &gt; 0"&gt; &lt;section class="main"&gt; &lt;input id="toggle-all" class="toggle-all" type="checkbox" v-bind:checked="getToggleAllStatus()" @change="handleToggleAll" /&gt; &lt;label for="toggle-all"&gt;Mark all as complete&lt;/label&gt; &lt;ul class="todo-list"&gt; &lt;!-- These are here just to show the structure of the list items --&gt; &lt;!-- List items should get the class `editing` when editing and `completed` when marked as completed --&gt; &lt;li v-for="(item, index) in todos" v-bind:class="&#123;completed: item.done&#125;"&gt; &lt;div class="view"&gt; &lt;input class="toggle" type="checkbox" v-model="item.done" /&gt; &lt;label&gt;&#123;&#123; item.title &#125;&#125;&lt;/label&gt; &lt;button @click="handleRemoveTodo(index)" class="destroy"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class="edit" value="Rule the web" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;!-- This footer should hidden by default and shown when there are todos --&gt; &lt;footer class="footer"&gt; &lt;!-- This should be `0 items left` by default --&gt; &lt;span class="todo-count"&gt;&lt;strong&gt;0&lt;/strong&gt; item left&lt;/span&gt; &lt;!-- Remove this if you don't implement routing --&gt; &lt;ul class="filters"&gt; &lt;li&gt; &lt;a class="selected" href="#/"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#/completed"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- Hidden if no completed items are left ↓ --&gt; &lt;button class="clear-completed"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt;&lt;/template&gt;... 添加任务HTML： JavaScript： 切换所有任务的完成状态&#123;6,7&#125;123456789...&lt;input id="toggle-all" class="toggle-all" type="checkbox" v-bind:checked="getToggleAllStatus()" @change="handleToggleAll"/&gt;... &#123;4,11&#125;12345678910111213141516171819202122...methods: &#123; ... handleToggleAll (e) &#123; const checked = e.target.checked this.todos.forEach((item) =&gt; &#123; item.done = checked &#125;) &#125;, getToggleAllStatus () &#123; let status = true this.todos.forEach(item =&gt; &#123; if (item.done === false) &#123; status = false &#125; &#125;) return status &#125;, ...&#125;... 删除单个任务 删除所有已完成任务处理显示状态 删除 显示所有剩余未完成任务数JavaScript： HTML： 编辑任务双击获得编辑状态 完成编辑数据过滤（自行参考源码学习）持久化存储（自行参考源码学习）优化使用 vcloak 解决表达式闪烁]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter2-Vue 基础]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter2-vue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 2 章 Vue 基础 安装 Vue.js 不支持 IE8 及其以下版本 因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 最新稳定版本：2.6.10 每个版本的更新日志见 Github Releases 直接下载 开发版本：https://vuejs.org/js/vue.js 生产版本：https://vuejs.org/js/vue.min.js CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 最新稳定版 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;&gt;&lt;/script&gt; 指定版本 使用 npm 下载 npm install vue 最新稳定版 npm install vue@版本号 指定版本 12345678910我们建议你的项目如果使用了 npm ，则最好创建一个 package.json 文件，用来存储第三方包依赖信息。当我需要把项目放到 Git 远程仓库的时候，没有必要放到 node_modules，如果我要分享给你，我只需要给你仓库地址就可以了。你要去下载仓库，里面没有第三方包，你也无法运行示例代码？怎么办？这个时候，你就可以：npm install 像使用模板引擎一样使用 Vue需求：下面的数据如何显示到页面中？ 123456789const data = &#123; message: 'Hello Vue.js!', user: &#123; name: '张三', age: 18, gender: 0 &#125;, todos: ['吃饭', '睡觉', '打豆豆']&#125; 1234567&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;姓名：&lt;/p&gt;&lt;p&gt;年龄：&lt;/p&gt;&lt;p&gt;性别：&lt;/p&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 方式一：操作 DOM 方式二：模板引擎 12345678910111213141516171819&lt;div id="app"&gt;&lt;/div&gt;&lt;scrit type="text/html" id="tpl"&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;p&gt;姓名：&#123;&#123; user.name &#125;&#125;&lt;/p&gt; &lt;p&gt;年龄：&lt;/p&gt; &lt;p&gt;性别：&#123;&#123; user.gender === 0 ? '女' : '男' &#125;&#125;&lt;/p&gt; &lt;ul&gt; &#123;&#123; each &#125;&#125; &lt;li&gt;&#123;&#123; $value &#125;&#125;&lt;/li&gt; &#123;&#123; /each &#125;&#125; &lt;/ul&gt;&lt;/scrit&gt;&lt;script src="模板引擎.js"&gt;&lt;/script&gt;&lt;script&gt; var htmlStr = template('tpl', data) document.getElementById('app').innerHTML = htmlStr&lt;/script&gt; 方式三：使用 Vue 12 数据驱动视图提问？ 如果我需要修改 h1、用户名、年龄、todos列表 视图。 方式一：操作 DOM 方式二：模板引擎 修改数据 重新调用编译渲染，然后把结果替换到容器中 方式三：Vue：数据驱动视图 实例选项 - el 不能是 html、body 节点 el 只能作用到单一节点上 实例选项 - data 模板中访问的数据必须初始化到 data 中 模板无法访问 Vue 实例之外的数据 除非你手动将外部数据添加为 data 数据成员了 123456789101112const a = 1const c = 2new Vue(&#123; el: '#app', data: &#123; // a: a, // 等价于 a: a，ECMAScript 6 简写方式 a, b: c &#125;&#125;) 模板语法 - 插值文本123&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;strong&gt;&#123;&#123; message &#125;&#125;&lt;/strong&gt; JavaScript 表达式1234&lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; number + 1 &gt; 10 ? 'number大于10' : 'number小于10' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; arr &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt; 属性12&lt;p v-bind:title="message"&gt;花括号不能使用在属性中&lt;/p&gt;&lt;a v-bind:href="url"&gt;去百度&lt;/a&gt; 可以简写 12&lt;p :title="message"&gt;花括号不能使用在属性中&lt;/p&gt;&lt;a :href="url"&gt;去百度&lt;/a&gt; 1属性值中的写法和 &#123;&#123;&#125;&#125;中的写法一致，也是 JavaScript 表达式 123&lt;p :title="message.split('').reverse().join('')"&gt;Hello World&lt;/p&gt;&lt;p :title="1 + 1"&gt;属性中的表达式&lt;/p&gt;&lt;p :title="number + 1 &gt; 10 ? 'number大于10' : 'number小于10'"&gt;属性中的表达式&lt;/p&gt; 原始 HTML 字符串123&lt;div&gt;&#123;&#123; htmlStr &#125;&#125;&lt;/div&gt;&lt;!-- 使用 v-html 指令渲染 html 标签内容字符串 --&gt;&lt;div v-html="htmlStr"&gt;&lt;/div&gt; v-html 中绑定的 html 内容数据不能使用数据绑定 列表渲染数组 v-for=&quot;item in todos&quot; v-for=&quot;(item, index) in todos&quot; 数组的更新数据中的数据的变化会触发视图更新。哪些数据修改操作会影响视图更新？ 12345678push()pop()shift()unshift()splice()sort()reverse()直接替换数组的方式，就是直接为数组进行重新赋值 注意： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 通过索引为数组元素重新赋值不会触发视图更新 但是：vm.toods[index].title = &#39;哈哈哈&#39; 是可以的 正确方式：Vue.set(数组, 索引, 数据) Vue 是通过 vue.js 提供的全局构造函数 在实例中你可以 vue实例.$set(数组, 索引, 数据) vue实例 是你通过 new Vue 得到的实例对象 当你修改数组的长度时，例如：vm.items.length = newLength 12345678910var obj = &#123; a: 1, b: 2&#125;// 重新赋值obj = xxx// 修改obj.a = 3 v-if 和 key例如我有这样一段代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vfor和key&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;!-- --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;vfor和key&lt;/h1&gt; &lt;button @click=&quot;todos.reverse()&quot;&gt;改变数组顺序&lt;/button&gt; &lt;ul&gt; &lt;!-- 不要使用 index，因为即便数据项的位置发生改变，但是索引不会变 --&gt; &lt;!-- 索引不变，也就意味着 key 的顺序没有改变，那么 Vue 就不会处理 --&gt; &lt;li v-for=&quot;(item, index) in todos&quot;&gt; &#123;&#123; item.title &#125;&#125; &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; todos: [ &#123; id: 1, title: &apos;吃饭&apos; &#125;, &#123; id: 2, title: &apos;睡觉&apos; &#125;, &#123; id: 3, title: &apos;打豆豆&apos; &#125; ] &#125;, methods: &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 修改代码如下： 结果演示： 总结： 官方文档说明：https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&quot;$index&quot;。 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： 123&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。 注意： 不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 不要使用遍历索引 index 作为唯一的 key 值 一般使用数据中的 id 作为唯一值 对象 v-for=&quot;value in 对象&quot; v-for=&quot;(value, key) in 对象&quot; 对象的更新 对象.属性 = 数据 对象 = 数据 注意： 不能通过 对象.xxx = xxx 为对象添加一个未初始化的成员 解决方式： Vue.set(对象, &#39;属性名&#39;, 属性值) 也可以 vue实例.$set(对象, 属性名, 属性值) 建议做法：尽量把你需要的数据都一次性初始化好，哪怕这个数据默认为空 值范围遍历 v-for=&quot;n in 10&quot; 条件渲染v-ifv-else、v-else-ifv-showv-if 和 v-show 区别 v-if true 渲染 DOM false 不渲染 DOM v-show true 渲染 DOM false 渲染 DOM，不显示（display: none） 不能和 v-else、v-else-if 结合使用 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 和 template事件处理基本语法函数简写指令简写 @事件类型 默认参数 event 事件对象 自定义传参123v-on=&quot;函数(参数)&quot;v-on=&quot;函数(参数, $event)&quot; 表单输入绑定样式处理Vue DevTools 官网：https://github.com/vuejs/vue-devtools 下载安装 方式一：Get the Chrome Extension 方式二：手动下载安装 下面是手动下载的方式： 下载并编译生成安装文件 123456789101112# 下载到任何位置都可以$ git clone https://github.com/vuejs/vue-devtools.git# 进入下载的目录中$ cd vue-devtools# 安装依赖$ npm install# 构建扩展包# 它会将离线安装文件生成到 vue-devtools/shells/chrome 中$ npm run build 安装 Chrome 扩展管理 右上角自定义及控制 Chrome -&gt; 更多工具 -&gt; 扩展程序 启动开发者模式 选择加载已解压的扩展程序 在弹出来的文件选择加载 vue-devtools/shell/chrome 然后在你的扩展列表中就看到了 Vue.js devtools 已经安装进来了 配置 Vue DevTools 选择 详细信息 在插件详细信息中找到 “允许访问文件网址” 并启用 使用 课堂练习以下是几个小练习，用来辅助大家增强体会 Vue 的数据驱动视图思想（MVVM）： 姓名展示：两个文本框，让用户分别输入性和名，然后将数据实时展示到界面上 数字自动增长：一个文本框用来呈递数字，一个按钮，用户点击按钮，文本框中的数字+1 购物车计价器：有商品价格，和商品数量，用户可以点击加减按钮改变商品数量，将价格实时展示到界面上 数字计算器：实现加法计算器 数字计算器：实现加减乘除 以上所有练习，都不要着急写代码，不要用以前 DOM 的思想去操作，利用 Vue 的数据驱动视图的思想，去考虑问题： 根据视图抽象数据模型 数据 行为 数据改变，触发视图更新 综合案例：Todo List 任务列表展示 添加任务 切换任务完成状态 删除单个任务 删除所有已完成任务 显示所有任务数量 显示所有未完成任务数 使用总结 Vue 最大程度上减少了页面上的 DOM 操作 让开发人员更专注于业务操作 通过简洁的指令结合页面结构与逻辑数据 通过组件化方便模板重用以及增加可维护性 代码结构更合理 维护成本更低 VueJS 解放了传统 JavaScript 中繁琐的 DOM 操作]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter1-vue介绍]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%89%8D%E7%AB%AF%2Fvue%2Fchapter1-vue%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文转自vuejs-tutorial，尊重原创，点击可直接访问原文 第 1 章 Vue.js 介绍疯狂发展的前端技术 前端开发的三个时代 纯原生 JavaScript jQuery（仅仅是提高了 DOM 操作的效率） 框架时代 前端交互越来越多，功能需求越来越复杂；旧浏览器逐渐淘汰，移动端需求增加 架构由传统的后台 MVC 向 REST API + MV* 发展 以前：胖服务器，瘦客户端 现在：胖客户端，瘦服务器‘ 前后端分离开发方式 人员职责的划分 技能的划分 各种前端框架诞生 Vue React Angular … 是什么以下引自官网原话： Vue.js (读音 /vjuː/，类似于 view) 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 一款非常优秀的前端渐进式 JavaScript 框架 Vue 本身只是一个用于数据驱动视图更新的库 让你原来操作 DOM 这件事儿更简单了 随着生态的慢慢发展，如今已经有了 Vue Router、Vuex、Vue CLI、Vue Server Renderer 等功能库，所以当 Vue 和这些核心功能库结合到一起的时候，我们称之为一个框架 这些技术一般也称之为 Vue 全家桶，所以学习 Vue 实际上就是要学习 Vue 全家桶才能发挥出 Vue 的威力 由尤雨溪开发并于 2014 年 2 月开源于 Github 目前已收货了 14w+ :star: 可以轻松构建 SPA 应用程序 Single Page Application 单页面应用程序 通过 指令 扩展了 HTML，通过 表达式 绑定数据到 HTML 通过组件化开发极大的提高了开发的效率和可维护性 最大程度上解放了 DOM 操作 它能让你更加的享受编程的乐趣 发展历史 Github 发布记录 Vue.js 由尤雨溪个人正式发布于 2014 年 2 月，并开源于 Github 2015 年 10 月 27 日，正式发布 1.0 2016 年 8 月 1 日，正式发布 2.0 截止到 2019-6 目前最新版本为 2.6.10 预计今年（2019）会发布 3.0 版本 目前已在 Github 收获 14w+ Star Vue 核心思想Vue 是为了克服 HTML 在构建应用上的不足而设计的。Vue 有着诸多特性，最为核心的是： 数据驱动 DOM 是数据的一种自然映射 数据改变自动驱动视图更新 组件化 扩展 HTML 元素，封装可重用代码 相关链接 Vue Github 仓库 Vue 中文官网 Vue 官方教程 Vue 官方 API 参考文档 Vue 官方示例 awesome-vue https://gitee.com/gitee-stars/14)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day19-下单]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday19-%E4%B8%8B%E5%8D%95%2F</url>
    <content type="text"><![CDATA[0.学习目标 会调用订单系统接口 实现订单结算功能 实现微信支付功能 1.订单系统接口我们不做开发，只讲解 1.1.导入订单服务把课前资料提供的leyou-order复制到D:\heima\code\leyou目录。 然后在工程内导入： 然后导入module： 选择导入module： 选择目录中的 ly-order： 打开父工程leyou的pom文件，添加ly-order模块： 1.2.Swagger-UI丝袜哥 1.2.1.什么是OpenAPI随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。 前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要。 没有API文档工具之前，大家都是手写API文档的，在什么地方书写的都有，而且API文档没有统一规范和格式，每个公司都不一样。这无疑给开发带来了灾难。 OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程。目前V3.0版本的OpenAPI规范已经发布并开源在github上 。 官网：https://github.com/OAI/OpenAPI-Specification 1.2.2.什么是swagger？OpenAPI是一个编写API文档的规范，然而如果手动去编写OpenAPI规范的文档，是非常麻烦的。而Swagger就是一个实现了OpenAPI规范的工具集。 官网：https://swagger.io/ 看官方的说明： Swagger包含的工具集： Swagger编辑器： Swagger Editor允许您在浏览器中编辑YAML中的OpenAPI规范并实时预览文档。 Swagger UI： Swagger UI是HTML，Javascript和CSS资产的集合，可以从符合OAS标准的API动态生成漂亮的文档。 Swagger Codegen：允许根据OpenAPI规范自动生成API客户端库（SDK生成），服务器存根和文档。 Swagger Parser：用于解析来自Java的OpenAPI定义的独立库 Swagger Core：与Java相关的库，用于创建，使用和使用OpenAPI定义 Swagger Inspector（免费）： API测试工具，可让您验证您的API并从现有API生成OpenAPI定义 SwaggerHub（免费和商业）： API设计和文档，为使用OpenAPI的团队构建。 1.2.3.快速入门SpringBoot已经集成了Swagger，使用简单注解即可生成swagger的API文档。 1）引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 2）编写配置12345678910111213141516171819202122@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .host("http://order.leyou.com") .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.leyou.order.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("乐优商城订单系统") .description("乐优商城订单系统接口文档") .version("1.0") .build(); &#125;&#125; 3）接口声明在controller的每个handler上添加接口说明注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestController@RequestMapping("order")@Api("订单服务接口")public class OrderController &#123; @Autowired private OrderService orderService; @Autowired private PayHelper payHelper; /** * 创建订单 * * @param order 订单对象 * @return 订单编号 */ @PostMapping @ApiOperation(value = "创建订单接口，返回订单编号", notes = "创建订单") @ApiImplicitParam(name = "order", required = true, value = "订单的json对象,包含订单条目和物流信息") public ResponseEntity&lt;Long&gt; createOrder(@RequestBody @Valid Order order) &#123; Long id = this.orderService.createOrder(order); return new ResponseEntity&lt;&gt;(id, HttpStatus.CREATED); &#125; /** * 分页查询当前用户订单 * * @param status 订单状态 * @return 分页订单数据 */ @GetMapping("list") @ApiOperation(value = "分页查询当前用户订单，并且可以根据订单状态过滤", notes = "分页查询当前用户订单") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "page", value = "当前页", defaultValue = "1", type = "Integer"), @ApiImplicitParam(name = "rows", value = "每页大小", defaultValue = "5", type = "Integer"), @ApiImplicitParam( name = "status", value = "订单状态：1未付款，2已付款未发货，3已发货未确认，4已确认未评价，5交易关闭，6交易成功，已评价", type = "Integer"), &#125;) public ResponseEntity&lt;PageResult&lt;Order&gt;&gt; queryUserOrderList( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "status", required = false) Integer status) &#123; PageResult&lt;Order&gt; result = this.orderService.queryUserOrderList(page, rows, status); if (result == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; 常用注解说明： 12345678910111213/** @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 */ 4）启动测试启动服务，然后访问：http://localhost:8089/swagger-ui.html 点击order-controller，查看接口信息： 点击任意一个接口，即可看到详细信息： 1.3.测试接口1.3.1.创建订单接口可以通过页面看到接口信息： 请求方式：POST 请求路径：/order 请求参数：包含订单、订单详情等数据的json对象。 返回结果：订单编号 点击Try It Out来测试： 输入数据： 123456789101112131415161718192021222324252627&#123; "totalPay": 236800, "postFee": 0, "paymentType": 2, "actualPay": 236800, "buyerMessage": null, "buyerNick": "huge", "orderDetails": [ &#123; "skuId": 3893493, "num": 1, "title": "苹果（Apple）iPhone 6 (A1586) 16GB 金色 移动联通电信4G手机3", "price": 236800, "ownSpec": "&#123;\"机身颜色\":\"钻雕蓝\",\"内存\":\"4GB\",\"机身存储\":\"64GB\"&#125;", "image": "http://image.leyou.com/images/9/4/1524297342728.jpg" &#125; ], "receiver": "锋哥", "receiverMobile": "15800000000", "receiverState": "上海", "receiverCity": "上海", "receiverDistrict": "浦东新签", "receiverAddress": "航头镇航头路18号传智播客3号楼", "receiverZip": "210000", "invoiceType": 0, "sourceType":2&#125; 然后点击execute： 结果： 下单需要登录，通过登录生成token： 把token的值手动加入到浏览器的cookie中： 添加成功，响应订单编号。但是和数据库保存的订单编号不太一样（后几位不一样，浏览器展示长整型会出现精度损失） 1.3.2.生成ID的方式 订单id的特殊性 订单数据非常庞大，将来一定会做分库分表。那么这种情况下， 要保证id的唯一，就不能靠数据库自增，而是自己来实现算法，生成唯一id。 雪花算法 这里的订单id是通过一个工具类生成的： 而工具类所采用的生成id算法，是由Twitter公司开源的snowflake（雪花）算法。 简单原理 雪花算法会生成一个64位的二进制数据，为一个Long型。(转换成字符串后长度最多19) ，其基本结构： 第一位：为未使用 第二部分：41位为毫秒级时间(41位的长度可以使用69年) 第三部分：5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） 第四部分：最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。 配置 为了保证不重复，我们给每个部署的节点都配置机器id： 1234leyou: worker: workerId: 1 datacenterId: 1 加载属性： 1234567891011121314151617181920212223@ConfigurationProperties(prefix = "leyou.worker")public class IdWorkerProperties &#123; private long workerId;// 当前机器id private long datacenterId;// 序列号 public long getWorkerId() &#123; return workerId; &#125; public void setWorkerId(long workerId) &#123; this.workerId = workerId; &#125; public long getDatacenterId() &#123; return datacenterId; &#125; public void setDatacenterId(long datacenterId) &#123; this.datacenterId = datacenterId; &#125;&#125; 编写配置类： 123456789@Configuration@EnableConfigurationProperties(IdWorkerProperties.class)public class IdWorkerConfig &#123; @Bean public IdWorker idWorker(IdWorkerProperties prop) &#123; return new IdWorker(prop.getWorkerId(), prop.getDatacenterId()); &#125;&#125; 使用： 1.3.2.查询订单接口接口说明： 请求方式：GET 请求路径：/order/{id} 请求参数：id，订单编号 返回结果：Order，订单的json对象 测试： 结果： 1.3.3.更新订单状态接口说明： 请求参数：PUT 请求路径：/order/{id}/{status} 请求参数： id：订单编号，String类型，不能为空 status：订单状态，不能为空 返回结果：null 测试： 结果： 数据库中也发生了改变： 1.3.4.分页查询订单接口说明： 请求方式：Get 请求路径：/order/list 请求参数： page：当前页，Integer类型，默认为1 rows：每页大小，Integer类型，默认为5 status：订单状态，String类型，默认查询全部状态订单 返回结果：PageResult 对象，包含下面属性： total：总条数 items：当前页订单数组 订单对象 测试： 结果： 1.3.5.生成微信付款链接接口说明： 请求方式：Get 请求路径：/order/url/{id} 请求参数：id，订单编号 返回结果：String类型，生成的微信支付链接 测试： 结果： 微信支付工具 PayHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Componentpublic class PayHelper &#123; private WXPay wxPay; private static final Logger logger = LoggerFactory.getLogger(PayHelper.class); @Autowired private StringRedisTemplate redisTemplate; @Autowired private OrderService orderService; public PayHelper(PayConfig payConfig) &#123; // 真实开发时 wxPay = new WXPay(payConfig); // 测试时 // wxPay = new WXPay(payConfig, WXPayConstants.SignType.MD5, true); &#125; public String createPayUrl(Long orderId) &#123; String key = "ly.pay.url." + orderId; try &#123; String url = this.redisTemplate.opsForValue().get(key); if (StringUtils.isNotBlank(url)) &#123; return url; &#125; &#125; catch (Exception e) &#123; logger.error("查询缓存付款链接异常,订单编号：&#123;&#125;", orderId, e); &#125; try &#123; Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); // 商品描述 data.put("body", "乐优商城测试"); // 订单号 data.put("out_trade_no", orderId.toString()); //货币 data.put("fee_type", "CNY"); //金额，单位是分 data.put("total_fee", "1"); //调用微信支付的终端IP（estore商城的IP） data.put("spbill_create_ip", "127.0.0.1"); //回调地址 data.put("notify_url", "http://test.leyou.com/wxpay/notify"); // 交易类型为扫码支付 data.put("trade_type", "NATIVE"); //商品id,使用假数据 data.put("product_id", "1234567"); Map&lt;String, String&gt; result = this.wxPay.unifiedOrder(data); if ("SUCCESS".equals(result.get("return_code"))) &#123; String url = result.get("code_url"); // 将付款地址缓存，时间为10分钟 try &#123; this.redisTemplate.opsForValue().set(key, url, 10, TimeUnit.MINUTES); &#125; catch (Exception e) &#123; logger.error("缓存付款链接异常,订单编号：&#123;&#125;", orderId, e); &#125; return url; &#125; else &#123; logger.error("创建预交易订单失败，错误信息：&#123;&#125;", result.get("return_msg")); return null; &#125; &#125; catch (Exception e) &#123; logger.error("创建预交易订单异常", e); return null; &#125; &#125; /** * 查询订单状态 * * @param orderId * @return */ public PayState queryOrder(Long orderId) &#123; Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); // 订单号 data.put("out_trade_no", orderId.toString()); try &#123; Map&lt;String, String&gt; result = this.wxPay.orderQuery(data); if (result == null) &#123; // 未查询到结果，认为是未付款 return PayState.NOT_PAY; &#125; String state = result.get("trade_state"); if ("SUCCESS".equals(state)) &#123; // success，则认为付款成功 // 修改订单状态 this.orderService.updateStatus(orderId, 2); return PayState.SUCCESS; &#125; else if (StringUtils.equals("USERPAYING", state) || StringUtils.equals("NOTPAY", state)) &#123; // 未付款或正在付款，都认为是未付款 return PayState.NOT_PAY; &#125; else &#123; // 其它状态认为是付款失败 return PayState.FAIL; &#125; &#125; catch (Exception e) &#123; logger.error("查询订单状态异常", e); return PayState.NOT_PAY; &#125; &#125;&#125; 跟支付相关的其它几个类： 1.3.6.查询支付状态接口说明： 请求方式： Get 请求路径： /state/{id} 请求参数： id，订单编号 返回结果：0, 未查询到支付信息 1,支付成功 2,支付失败（查询失败，或者订单过期） 1.3.6.1.未付款未付款时查询，测试： 结果： 因为尚未付款，所以查询返回0。 1.3.6.2.付款通过JS把链接变成二维码。 找到课前资料提供的JS页面： 进入，并输入刚刚生成的地址： 1.3.6.3.已付款扫码支付，然后再次查询： 状态码为1，代表支付成功了！ 2.订单结算页2.1.页面跳转在购物车页面的最下方，有一个去结算按钮： 当点击结算，我们应该跳转到订单结算页，即：getOrderInfo.html 查看购物车的结算按钮： 可以看到，地址是正确的。但是只有登录用户才可以去结算付款，因此我们不能直接跳转，而是在跳转前校验用户的登录状态，如果发现是未登录，应该重定向到登录页！ 我们给这个按钮绑定点击事件： 事件中判断登录状态，进行页面跳转： 12345678910toOrderInfo() &#123; // 判断是否登录 ly.verifyUser().then(() =&gt; &#123; // 已登录 window.location.href = "/getOrderInfo.html" &#125;).catch(() =&gt; &#123; // 未登录 window.location.href = "/login.html?returnUrl=" + window.location.href; &#125;)&#125; 登录后测试： 此处页面需要渲染的内容主要包含3部分： 收货人信息 支付方式 商品信息 2.2.收货人信息（作业） 这里的收货人信息肯定是当前登录用户的收货地址。所以需要根据当前登录用户去查询，目前我们在页面是写的假数据： 大家可以在在后台提供地址的增删改查接口，然后页面加载时根据当前登录用户查询，而后赋值给addresses即可。 2.3.支付方式支付方式有2种： 微信支付 货到付款 与我们订单数据中的paymentType关联： 所以我们可以在Vue实例中定义一个属性来记录支付方式： 然后在页面渲染时与这个变量关联： 2.4.商品列表效果图： 这里的送货清单，其实就是购物车中用户选择的要付款的商品 因此，我们需要在购物车跳转过来的同时，携带选中的购物车的信息 2.4.1.购物车信息获取我们修改cart.html中的页面跳转逻辑，把用户选中的购物车信息传递过来： 然后在created钩子函数中获取购物车数据，保存到本地属性，要注意的是，我们应该在获取数据前校验用户登录状态，如果发现未登录，则直接重定向到登录页： 然后重新加载页面，查看控制台： 2.4.2.页面渲染要修改的页面位置：每一个li就是一件商品 我们修改为： 1234567891011121314151617181920212223242526&lt;ul class="send-detail"&gt; &lt;li v-for="(cart,index) in carts" :key="index"&gt; &lt;div class="sendGoods"&gt; &lt;ul class="yui3-g"&gt; &lt;li class="yui3-u-1-6"&gt; &lt;span&gt;&lt;img width="70px" height="70px" :src="cart.image"/&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="yui3-u-7-12"&gt; &lt;div class="desc"&gt;&#123;&#123;cart.title&#125;&#125;&lt;/div&gt; &lt;div class="seven"&gt; &lt;span v-for="(v) in JSON.parse(cart.ownSpec)"&gt;&#123;&#123;v + " "&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="price"&gt;￥&#123;&#123;ly.formatPrice(cart.price * cart.num)&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="num"&gt;&#123;&#123;cart.num&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="exit"&gt;有货&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 2.5.总金额另外在商品列表下面，还有一个总金额的计算： 可以看出这里主要有4个数据： 总金额：totalPay 优惠返现：discount 运费：postFee 实付金额：actualPay 不过我们没有做优惠活动，另外运费需要结合物流系统来计算，暂时我们都设置为0，在order属性中写死： 我们通过计算属性来得到totalPay和actualPay值： 1234567891011computed: &#123; totalNum()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.num, 0) &#125;, totalPay()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.price * c2.num, 0); &#125;, actualPay()&#123; return this.totalPay + this.order.postFee - this.order.discount; &#125;&#125;, 然后在页面渲染： 效果： 2.6.提交订单2.6.1.页面提交来看下订单接口所需要的数据： 分为3部分，分别是 订单本身的基本信息 总金额 实付金额 付款类型 买家信息就是当前用户 订单详情 就是购物车中的商品，不过购物车数据会多出一个userId，我们去除即可： 物流信息 当前用户选中的物流地址信息 给提交按钮绑定事件： 然后编写方法，组织数据并提交： 123456789101112131415161718192021222324252627282930methods: &#123; submit() &#123; // 把购物车数据处理成订单详情 const orderDetails = this.carts.map((&#123;userId, ...rest&#125;) =&gt; rest); // 处理物流信息 const addr = this.addresses[this.selectedAddress]; const obj = &#123; receiver: addr.name, receiverState: addr.state, receiverCity: addr.city, receiverAddress: addr.address, receiverDistrict: addr.district, receiverMobile: addr.phone, receiverZip: addr.zipCode &#125;; // 复制到订单对象 Object.assign(this.order, obj, &#123; orderDetails, totalPay: this.totalPay, actualPay: this.actualPay, &#125;); // 提交订单 ly.http.post("/order", this.order).then((&#123;data&#125;) =&gt; &#123; // 在线支付，需要到付款页 window.location = "pay.html?orderId=" + data; &#125;).catch((resp) =&gt; &#123; alert("订单提交失败，可能是缺货!") &#125;) &#125;&#125;, 2.6.2.精度损失问题在页面点击提交测试： 成功生成订单！ 然后看页面跳转： 好像有什么不对？订单号的最后2位不正确啊！ 这其实是因为JS的长整数精度有限，java的Long类型数据超出了范围，所以出现了精度损失。 我们后台返回的是Json的字符串，在axios内部会自动调用 JSON.parse()方法把json字符串转为JS数据，就会出现进度损失。如果不进行转换，依然当做字符串来使用，就不会有问题了。 因此，我们重写axios对响应的处理回调函数： 1234567&#123; transformResponse: [ function(data)&#123; return data; &#125; ]&#125; 再次测试，就OK了。 接下来就轮到支付了。 3.微信支付3.1.介绍微信支付官方文档：https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F 我们选择开发文档，而后进入选择页面： 选择扫码支付： 此处我们使用模式二来开发： 3.2.开发流程模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。 商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url； 商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。 注意：code_url有效期为2小时，过期后扫码不能再发起支付。 流程图： 这里我们把商户（我们）要做的事情总结一下： 1、商户生成订单 2、商户调用微信下单接口，获取预交易的链接 3、商户将链接生成二维码图片，展示给用户； 4、用户支付并确认 5、支付结果通知： 微信异步通知商户支付结果，商户告知微信支付接收情况 商户如果没有收到通知，可以调用接口，查询支付状态 6、如果支付成功，发货，修改订单状态 在前面的业务中，我们已经完成了： 1、生成订单 接下来，我们需要做的是： 2、调用微信接口，生成链接。 3、并且生成二维码图片 3.3.生成二维码3.3.1.生成预交易链接我们先根据订单的编号，调用后台服务，生成交易链接，而后才能根据链接生成二维码。 在页面发起请求： 12345678910111213141516171819202122232425var payVm = new Vue(&#123; el:"#payVm", data:&#123; ly, orderId:0,// 订单编号 &#125;, created()&#123; // 判断登录状态 ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; console.log(resp.data); &#125;) &#125;).catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href; &#125;) &#125;, components: &#123; shortcut: () =&gt; import("./js/pages/shortcut.js") &#125;&#125;); 后台已经定义好生成付款地址的接口。 刷新页面查看： 3.3.2.生成二维码这里我们使用一个生成二维码的JS插件：qrcode，官网：https://github.com/davidshimjs/qrcodejs 我们把课这个js脚本引入到项目中： 官方使用案例： 然后在页面引用： 页面定义一个div，用于展示二维码： 然后获取到付款链接后，根据链接生成二维码： 1234567891011121314151617181920// 判断登录状态ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; new QRCode(document.getElementById("qrImage"), &#123; text: resp.data, width: 250, height: 250, colorDark: "#000000", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H &#125;); &#125;)&#125;).catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href;&#125;) 刷新页面，查看效果： 此时，客户用手机扫描二维码，可以看到付款页面。 3.4.付款状态查询跳转到支付页面后，我们等待用户付款，付款完成则跳转到付款成功页面。 3.4.1.页面循环查询支付状态不过，因为不清楚用户何时会付款，因此这里采用循环的方式，不断请求判断是否支付成功。 123456789101112131415161718// 开启定时任务，查询付款状态const taskId = setInterval(() =&gt; &#123; ly.http.get("/order/state/" + this.orderId) .then(resp =&gt; &#123; let i = resp.data; if (i === 1) &#123; // 付款成功 clearInterval(taskId); // 跳转到付款成功页 location.href = "/paysuccess.html?orderId=" + this.orderId; &#125; else if (i === 2) &#123; // 付款失败 clearInterval(taskId); // 跳转到付款失败页 location.href = "/payfail.html"; &#125; &#125;)&#125;, 3000); 3.4.2.付款成功页面当付款成功后，自动跳转到付款成功页面：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day18-购物车]]></title>
    <url>%2F2019%2F07%2F18%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday18-%E8%B4%AD%E7%89%A9%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[0.学习目标1.实现未登录状态的购物车 2.实现登陆状态下的购物车 1.搭建购物车服务1.1.创建module 1.2.pom依赖12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-cart&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.3.配置文件123456789101112131415server: port: 8088spring: application: name: cart-service redis: host: 192.168.56.101eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 1.4.启动类123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouCartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouCartApplication.class, args); &#125;&#125; 2.购物车功能分析2.1.需求需求描述： 用户可以在登录状态下将商品添加到购物车 放入数据库 mongodb 放入redis（采用） 用户可以在未登录状态下将商品添加到购物车 放入localstorage cookie webSQL 用户可以使用购物车一起结算下单 用户可以查询自己的购物车 用户可以在购物车中修改购买商品的数量。 用户可以在购物车中删除商品。 在购物车中展示商品优惠信息 提示购物车商品价格变化 2.2.流程图 这幅图主要描述了两个功能：新增商品到购物车、查询购物车。 新增商品： 判断是否登录 是：则添加商品到后台Redis中 否：则添加商品到本地的Localstorage 无论哪种新增，完成后都需要查询购物车列表： 判断是否登录 否：直接查询localstorage中数据并展示 是：已登录，则需要先看本地是否有数据， 有：需要提交到后台添加到redis，合并数据，而后查询 否：直接去后台查询redis，而后返回 3.未登录购物车3.1.准备3.1.1购物车的数据结构首先分析一下未登录购物车的数据结构。 我们看下页面展示需要什么数据： 因此每一个购物车信息，都是一个对象，包含： 12345678&#123; skuId:2131241, title:"小米6", image:"", price:190000, num:1, ownSpec:"&#123;"机身颜色":"陶瓷黑尊享版","内存":"6GB","机身存储":"128GB"&#125;"&#125; 另外，购物车中不止一条数据，因此最终会是对象的数组。即： 123[ &#123;...&#125;,&#123;...&#125;,&#123;...&#125;] 3.1.2.web本地存储知道了数据结构，下一个问题，就是如何保存购物车数据。前面我们分析过，可以使用Localstorage来实现。Localstorage是web本地存储的一种，那么，什么是web本地存储呢？ 什么是web本地存储？ web本地存储主要有两种方式： LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 LocalStorage的用法语法非常简单： 123localStorage.setItem("key","value"); // 存储数据localStorage.getItem("key"); // 获取数据localStorage.removeItem("key"); // 删除数据 注意：localStorage和SessionStorage都只能保存字符串。 不过，在我们的common.js中，已经对localStorage进行了简单的封装： 示例： 3.1.3.获取num添加购物车需要知道购物的数量，所以我们需要获取数量大小。我们在Vue中定义num，保存数量： 然后将num与页面的input框绑定，同时给+和-的按钮绑定事件： 编写方法： 3.2.添加购物车3.2.1.点击事件我们看下商品详情页： 现在点击加入购物车会跳转到购物车成功页面。 不过我们不这么做，我们绑定点击事件，然后实现添加购物车功能。 addCart方法中判断用户的登录状态： 1234567addCart()&#123; ly.http.get("/auth/verify").then(res=&gt;&#123; // 已登录发送信息到后台，保存到redis中 &#125;).catch(()=&gt;&#123; // 未登录保存在浏览器本地的localStorage中 &#125;)&#125; 3.2.2.获取数量，添加购物车12345678910111213141516171819202122232425262728293031addCart()&#123; ly.verifyUser().then(res=&gt;&#123; // 已登录发送信息到后台，保存到redis中 &#125;).catch(()=&gt;&#123; // 未登录保存在浏览器本地的localStorage中 // 1、查询本地购物车 let carts = ly.store.get("carts") || []; let cart = carts.find(c=&gt;c.skuId===this.sku.id); // 2、判断是否存在 if (cart) &#123; // 3、存在更新数量 cart.num += this.num; &#125; else &#123; // 4、不存在，新增 cart = &#123; skuId: this.sku.id, title: this.sku.title, price: this.sku.price, image: this.sku.images, num: this.num, ownSpec: this.ownSpec &#125; carts.push(cart); &#125; // 把carts写回localstorage ly.store.set("carts", carts); // 跳转 window.location.href = "http://www.leyou.com/cart.html"; &#125;);&#125; 结果： 添加完成后，页面会跳转到购物车结算页面：cart.html 3.3.查询购物车3.3.1.校验用户登录因为会多次校验用户登录状态，因此我们封装一个校验的方法： 在common.js中： 在页面item.html中使用该方法： 3.3.2.查询购物车页面加载时，就应该去查询购物车。 1234567891011121314151617181920212223242526var cartVm = new Vue(&#123; el: "#cartApp", data: &#123; ly, carts: [],// 购物车数据 &#125;, created() &#123; this.loadCarts(); &#125;, methods: &#123; loadCarts() &#123; // 先判断登录状态 ly.verifyUser().then(() =&gt; &#123; // 已登录 &#125;).catch(() =&gt; &#123; // 未登录 this.carts = ly.store.get("carts") || []; this.selected = this.carts; &#125;) &#125; &#125; components: &#123; shortcut: () =&gt; import("/js/pages/shortcut.js") &#125;&#125;) 刷新页面，查看控制台Vue实例： 3.5.2.渲染到页面接下来，我们在页面中展示carts的数据： 要注意，价格的展示需要进行格式化，这里使用的是我们在common.js中定义的formatPrice方法 效果： 3.6.修改数量我们给页面的 + 和 -绑定点击事件，修改num 的值： 两个事件： 123456789101112131415161718192021increment(c) &#123; c.num++; ly.verifyUser().then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;).catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;,decrement(c) &#123; if (c.num &lt;= 1) &#123; return; &#125; c.num--; ly.verifyUser().then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;).catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125; 3.7.删除商品给删除按钮绑定事件： 点击事件中删除商品： 123456789deleteCart(i)&#123; ly.verifyUser().then(res=&gt;&#123; // TODO，已登录购物车 &#125;).catch(()=&gt;&#123; // 未登录购物车 this.carts.splice(i, 1); ly.store.set("carts", this.carts); &#125;)&#125; 3.8.选中商品在页面中，每个购物车商品左侧，都有一个复选框，用户可以选择部分商品进行下单，而不一定是全部： 我们定义一个变量，记录所有被选中的商品： 3.8.1.选中一个我们给商品前面的复选框与selected绑定，并且指定其值为当前购物车商品： 3.8.2.初始化全选我们在加载完成购物车查询后，初始化全选： 3.8.3.总价格然后编写一个计算属性，计算出选中商品总价格： 12345computed: &#123; totalPrice() &#123; return ly.formatPrice(this.selected.reduce((c1, c2) =&gt; c1 + c2.num * c2.price, 0)); &#125;&#125; 在页面中展示总价格： 效果： 4.已登录购物车接下来，我们完成已登录购物车。 在刚才的未登录购物车编写时，我们已经预留好了编写代码的位置，逻辑也基本一致。 4.1.添加登录校验购物车系统只负责登录状态的购物车处理，因此需要添加登录校验，我们通过JWT鉴权即可实现。 4.1.1.引入JWT相关依赖我们引入之前写的鉴权工具：leyou-auth-common 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 4.1.2.配置公钥1234leyou: jwt: pubKeyPath: C:/tmp/rsa/rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 4.1.3.加载公钥 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ConfigurationProperties(prefix = "leyou.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private PublicKey publicKey; // 公钥 private String cookieName; private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); @PostConstruct public void init()&#123; try &#123; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥失败！", e); throw new RuntimeException(); &#125; &#125; public String getPubKeyPath() &#123; return pubKeyPath; &#125; public void setPubKeyPath(String pubKeyPath) &#123; this.pubKeyPath = pubKeyPath; &#125; public PublicKey getPublicKey() &#123; return publicKey; &#125; public void setPublicKey(PublicKey publicKey) &#123; this.publicKey = publicKey; &#125; public String getCookieName() &#123; return cookieName; &#125; public void setCookieName(String cookieName) &#123; this.cookieName = cookieName; &#125;&#125; 4.1.4.编写拦截器因为很多接口都需要进行登录，我们直接编写SpringMVC拦截器，进行统一登录校验。同时，我们还要把解析得到的用户信息保存起来，以便后续的接口可以使用。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class LoginInterceptor extends HandlerInterceptorAdapter &#123; private JwtProperties jwtProperties; // 定义一个线程域，存放登录用户 private static final ThreadLocal&lt;UserInfo&gt; tl = new ThreadLocal&lt;&gt;(); public LoginInterceptor(JwtProperties jwtProperties) &#123; this.jwtProperties = jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 查询token String token = CookieUtils.getCookieValue(request, "LY_TOKEN"); if (StringUtils.isBlank(token)) &#123; // 未登录,返回401 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; // 有token，查询用户信息 try &#123; // 解析成功，证明已经登录 UserInfo user = JwtUtils.getInfoFromToken(token, jwtProperties.getPublicKey()); // 放入线程域 tl.set(user); return true; &#125; catch (Exception e)&#123; // 抛出异常，证明未登录,返回401 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; tl.remove(); &#125; public static UserInfo getLoginUser() &#123; return tl.get(); &#125;&#125; 注意： 这里我们使用了ThreadLocal来存储查询到的用户信息，线程内共享，因此请求到达Controller后可以共享User 并且对外提供了静态的方法：getLoginUser()来获取User信息 4.1.5.配置拦截器配置SpringMVC，使过滤器生效： 1234567891011121314151617@Configuration@EnableConfigurationProperties(JwtProperties.class)public class MvcConfig implements WebMvcConfigurer &#123; @Autowired private JwtProperties jwtProperties; @Bean public LoginInterceptor loginInterceptor() &#123; return new LoginInterceptor(jwtProperties); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 4.2.后台购物车设计当用户登录时，我们需要把购物车数据保存到后台，可以选择保存在数据库。但是购物车是一个读写频率很高的数据。因此我们这里选择读写效率比较高的Redis作为购物车存储。 Redis有5种不同数据结构，这里选择哪一种比较合适呢？Map&lt;String, List&gt; 首先不同用户应该有独立的购物车，因此购物车应该以用户的作为key来存储，Value是用户的所有购物车信息。这样看来基本的k-v结构就可以了。 但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品id进行判断，为了方便后期处理，我们的购物车也应该是k-v结构，key是商品id，value才是这个商品的购物车信息。 综上所述，我们的购物车结构是一个双层Map：Map&lt;String,Map&lt;String,String&gt;&gt; 第一层Map，Key是用户id 第二层Map，Key是购物车中商品id，值是购物车数据 实体类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Cart &#123; private Long userId;// 用户id private Long skuId;// 商品id private String title;// 标题 private String image;// 图片 private Long price;// 加入购物车时的价格 private Integer num;// 购买数量 private String ownSpec;// 商品规格参数 public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public Long getSkuId() &#123; return skuId; &#125; public void setSkuId(Long skuId) &#123; this.skuId = skuId; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImage() &#123; return image; &#125; public void setImage(String image) &#123; this.image = image; &#125; public Long getPrice() &#123; return price; &#125; public void setPrice(Long price) &#123; this.price = price; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; public String getOwnSpec() &#123; return ownSpec; &#125; public void setOwnSpec(String ownSpec) &#123; this.ownSpec = ownSpec; &#125;&#125; 4.3.添加商品到购物车4.3.1.页面发起请求已登录情况下，向后台添加购物车： 123ly.http.post("/cart", &#123;skuId: this.sku.id, num: this.num&#125;).then(res=&gt;&#123; window.location = "http://www.leyou.com/cart.html";&#125;) 这里发起的是Json请求。那么我们后台也要以json接收。 4.3.2.编写controller先分析一下： 请求方式：新增，肯定是Post 请求路径：/cart ，这个其实是Zuul路由的路径，我们可以不管 请求参数：Json对象，包含skuId和num属性 返回结果：无 1234567891011121314151617@Controllerpublic class CartController &#123; @Autowired private CartService cartService; /** * 添加购物车 * * @return */ @PostMapping public ResponseEntity&lt;Void&gt; addCart(@RequestBody Cart cart) &#123; this.cartService.addCart(cart); return ResponseEntity.ok().build(); &#125;&#125; 在leyou-gateway中添加路由配置： 4.3.3.CartService这里我们不访问数据库，而是直接操作Redis。基本思路： 先查询之前的购物车数据 判断要添加的商品是否存在 存在：则直接修改数量后写回Redis 不存在：新建一条数据，然后写入Redis 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Servicepublic class CartService &#123; @Autowired private StringRedisTemplate redisTemplate; @Autowired private GoodsClient goodsClient; static final String KEY_PREFIX = "leyou:cart:uid:"; static final Logger logger = LoggerFactory.getLogger(CartService.class); public void addCart(Cart cart) &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); // Redis的key String key = KEY_PREFIX + user.getId(); // 获取hash操作对象 BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); // 查询是否存在 Long skuId = cart.getSkuId(); Integer num = cart.getNum(); Boolean boo = hashOps.hasKey(skuId.toString()); if (boo) &#123; // 存在，获取购物车数据 String json = hashOps.get(skuId.toString()).toString(); cart = JsonUtils.parse(json, Cart.class); // 修改购物车数量 cart.setNum(cart.getNum() + num); &#125; else &#123; // 不存在，新增购物车数据 cart.setUserId(user.getId()); // 其它商品信息，需要查询商品服务 Sku sku = this.goodsClient.querySkuById(skuId); cart.setImage(StringUtils.isBlank(sku.getImages()) ? "" : StringUtils.split(sku.getImages(), ",")[0]); cart.setPrice(sku.getPrice()); cart.setTitle(sku.getTitle()); cart.setOwnSpec(sku.getOwnSpec()); &#125; // 将购物车数据写入redis hashOps.put(cart.getSkuId().toString(), JsonUtils.serialize(cart)); &#125;&#125; 需要引入leyou-item-interface依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 4.3.4.GoodClient参照搜索工程，添加GoodClient，提供根据id查询sku的接口： 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 在leyou-item-service中的GoodsController添加方法： 12345678@GetMapping("sku/&#123;id&#125;")public ResponseEntity&lt;Sku&gt; querySkuById(@PathVariable("id")Long id)&#123; Sku sku = this.goodsService.querySkuById(id); if (sku == null)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(sku);&#125; 在leyou-item-service中的GoodsService添加方法： 123public Sku querySkuById(Long id) &#123; return this.skuMapper.selectByPrimaryKey(id);&#125; 4.3.5.结果 4.4.查询购物车4.4.1.页面发起请求购物车页面：cart.html 4.4.2.后台实现 Controller 12345678910111213/** * 查询购物车列表 * * @return */@GetMappingpublic ResponseEntity&lt;List&lt;Cart&gt;&gt; queryCartList() &#123; List&lt;Cart&gt; carts = this.cartService.queryCartList(); if (carts == null) &#123; return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null); &#125; return ResponseEntity.ok(carts);&#125; Service 12345678910111213141516171819public List&lt;Cart&gt; queryCartList() &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); // 判断是否存在购物车 String key = KEY_PREFIX + user.getId(); if(!this.redisTemplate.hasKey(key))&#123; // 不存在，直接返回 return null; &#125; BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); List&lt;Object&gt; carts = hashOps.values(); // 判断是否有数据 if(CollectionUtils.isEmpty(carts))&#123; return null; &#125; // 查询购物车数据 return carts.stream().map(o -&gt; JsonUtils.parse(o.toString(), Cart.class)).collect(Collectors.toList());&#125; 4.4.3.测试 4.5.修改商品数量4.5.1.页面发起请求 4.5.2.后台实现 Controller 12345@PutMappingpublic ResponseEntity&lt;Void&gt; updateNum(@RequestBody Cart cart)&#123; this.cartService.updateCarts(cart); return ResponseEntity.noContent().build();&#125; Service 1234567891011121314public void updateCarts(Cart cart) &#123; // 获取登陆信息 UserInfo userInfo = LoginInterceptor.getUserInfo(); String key = LEYOU_CART_KEY + userInfo.getId(); // 获取hash操作对象 BoundHashOperations&lt;String, Object, Object&gt; hashOperations = this.redisTemplate.boundHashOps(key); // 获取购物车信息 String cartJson = hashOperations.get(cart.getSkuId().toString()).toString(); Cart cart1 = JsonUtils.parse(cartJson, Cart.class); // 更新数量 cart1.setNum(cart.getNum()); // 写入购物车 hashOperations.put(cart.getSkuId().toString(), JsonUtils.serialize(cart1));&#125; 4.6.删除购物车商品4.6.1.页面发起请求 注意：后台成功响应后，要把页面的购物车中数据也删除 4.6.2.后台实现 Controller 12345@DeleteMapping("&#123;skuId&#125;")public ResponseEntity&lt;Void&gt; deleteCart(@PathVariable("skuId") String skuId) &#123; this.cartService.deleteCart(skuId); return ResponseEntity.ok().build();&#125; Service 1234567public void deleteCart(String skuId) &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); String key = KEY_PREFIX + user.getId(); BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); hashOps.delete(skuId);&#125; 5.登录后购物车合并（作业）当跳转到购物车页面，查询购物车列表前，需要判断用户登录状态， 如果登录： 首先检查用户的LocalStorage中是否有购物车信息， 如果有，则提交到后台保存， 清空LocalStorage 如果未登录，直接查询即可]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day17-授权中心]]></title>
    <url>%2F2019%2F07%2F17%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday17-%E6%8E%88%E6%9D%83%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[0.学习目标1.无状态登录原理1.1.什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。 例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。 缺点是什么？ 服务端保存大量数据，增加服务端压力 服务端保存用户状态，无法进行水平扩展 客户端请求依赖服务端，多次请求必须访问同一台服务器 1.2.什么是无状态微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务的对token进行解密，判断是否有效。 流程图： 整个登录过程中，最关键的点是什么？ token的安全性 token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。 采用何种方式加密才是安全可靠的呢？ 我们将采用JWT + RSA非对称加密 1.4.JWT1.4.1.简介JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io GitHub上jwt的java客户端：https://github.com/jwtk/jjwt 1.4.2.数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 我们会对头部进行base64编码，得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64编码，可解码，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64编码，得到第二部分数据 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性 生成的数据格式：token==个人证件 jwt=个人身份证 可以看到分为3段，每段就是上面的一部分数据 1.4.3.JWT交互流程流程图： 步骤翻译： 1、用户登录 2、服务的认证，通过后根据secret生成token 3、将生成的token返回给浏览器 4、用户每次请求携带token 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 6、处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 1.4.4.非对称加密加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有私钥或公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 RSA算法历史： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA 1.5.结合Zuul的鉴权流程我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。 1.5.1.没有RSA加密时在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图： 1、用户请求登录 2、Zuul将请求转发到授权中心，请求授权 3、授权中心校验完成，颁发JWT凭证 4、客户端请求其它功能，携带JWT 5、Zuul将jwt交给授权中心校验，通过后放行 6、用户请求到达微服务 7、微服务将jwt交给鉴权中心，鉴权同时解析用户信息 8、鉴权中心返回用户数据给微服务 9、微服务处理请求，返回响应 发现什么问题了？ 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。 1.5.2.结合RSA的鉴权直接看图： 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务 用户请求登录 授权中心校验，通过后用私钥对JWT进行签名加密 返回jwt给用户 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 2.授权中心2.1.创建授权中心授权中心的主要职责： 用户鉴权： 接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT 使用私钥生成JWT并返回 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证 原理与用户鉴权类似，但逻辑稍微复杂一些（此处我们不做实现） 因为生成jwt，解析jwt这样的行为以后在其它微服务中也会用到，因此我们会抽取成工具。我们把鉴权中心进行聚合，一个工具module，一个提供服务的module 2.1.1.创建父module我们先创建父module，名称为：leyou-auth 将pom打包方式改为pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 2.1.2.通用module然后是授权服务的通用模块：leyou-auth-common： pom.xml： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 结构： 2.1.3.授权服务 pom.xml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引导类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouAuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouAuthApplication.class, args); &#125;&#125; application.yml 12345678910111213server: port: 8087spring: application: name: auth-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 结构： 在leyou-gateway工程的application.yml中，修改路由： 1234567zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 search-service: /search/** # 搜索微服务 user-service: /user/** # 用户微服务 auth-service: /auth/** # 授权中心微服务 2.2.JWT工具类我们在leyou-auth-common中导入课前资料中的工具类： 需要在leyou-auth-common中引入JWT依赖： 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3.测试工具类我们在leyou-auth-common中编写测试类： 1234567891011121314151617181920212223242526272829303132333435363738public class JwtTest &#123; private static final String pubKeyPath = "C:\\tmp\\rsa\\rsa.pub"; private static final String priKeyPath = "C:\\tmp\\rsa\\rsa.pri"; private PublicKey publicKey; private PrivateKey privateKey; @Test public void testRsa() throws Exception &#123; RsaUtils.generateKey(pubKeyPath, priKeyPath, "234"); &#125; @Before public void testGetRsa() throws Exception &#123; this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; @Test public void testGenerateToken() throws Exception &#123; // 生成token String token = JwtUtils.generateToken(new UserInfo(20L, "jack"), privateKey, 5); System.out.println("token = " + token); &#125; @Test public void testParseToken() throws Exception &#123; String token = "eyJhbGciOiJSUzI1NiJ9.eyJpZCI6MjAsInVzZXJuYW1lIjoiamFjayIsImV4cCI6MTUzMzI4MjQ3N30.EPo35Vyg1IwZAtXvAx2TCWuOPnRwPclRNAM4ody5CHk8RF55wdfKKJxjeGh4H3zgruRed9mEOQzWy79iF1nGAnvbkraGlD6iM-9zDW8M1G9if4MX579Mv1x57lFewzEo-zKnPdFJgGlAPtNWDPv4iKvbKOk1-U7NUtRmMsF1Wcg"; // 解析token UserInfo user = JwtUtils.getInfoFromToken(token, publicKey); System.out.println("id: " + user.getId()); System.out.println("userName: " + user.getUsername()); &#125;&#125; 测试生成公钥和私钥，我们运行这段代码：注意需要把@Before方法注释掉 运行之后，查看目标目录： 公钥和私钥已经生成了！ 测试生成token，把@Before的注释去掉的： 测试解析token： 正常情况： 任意改动token，发现报错了： 2.3.编写登录授权接口接下来，我们需要在leyou-auth-servcice编写一个接口，对外提供登录授权服务。基本流程如下： 客户端携带用户名和密码请求登录 授权中心调用用户中心接口，根据用户名和密码查询用户信息 如果用户名密码正确，能获取用户，否则为空，则登录失败 如果校验成功，则生成JWT并返回 2.3.1.生成公钥和私钥我们需要在授权中心生成真正的公钥和私钥。我们必须有一个生成公钥和私钥的secret，这个可以配置到application.yml中： 123456leyou: jwt: secret: leyou@Login(Auth&#125;*^31)&amp;heiMa% # 登录校验的密钥 pubKeyPath: C:\\tmp\\rsa\\rsa.pub # 公钥地址 priKeyPath: C:\\tmp\\rsa\\rsa.pri # 私钥地址 expire: 30 # 过期时间,单位分钟 然后编写属性类，加载这些数据： 12345678910111213141516171819202122232425262728293031323334353637383940@ConfigurationProperties(prefix = "leyou.jwt")public class JwtProperties &#123; private String secret; // 密钥 private String pubKeyPath;// 公钥 private String priKeyPath;// 私钥 private int expire;// token过期时间 private PublicKey publicKey; // 公钥 private PrivateKey privateKey; // 私钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init()&#123; try &#123; File pubKey = new File(pubKeyPath); File priKey = new File(priKeyPath); if (!pubKey.exists() || !priKey.exists()) &#123; // 生成公钥和私钥 RsaUtils.generateKey(pubKeyPath, priKeyPath, secret); &#125; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥和私钥失败！", e); throw new RuntimeException(); &#125; &#125; // getter setter ...&#125; 2.3.2.Controller编写授权接口，我们接收用户名和密码，校验成功后，写入cookie中。 请求方式：post 请求路径：/accredit 请求参数：username和password 返回结果：无 代码： 12345678910111213141516171819202122232425262728293031323334@RestController@EnableConfigurationProperties(JwtProperties.class)public class AuthController &#123; @Autowired private AuthService authService; @Autowired private JwtProperties prop; /** * 登录授权 * * @param username * @param password * @return */ @PostMapping("accredit") public ResponseEntity&lt;Void&gt; authentication( @RequestParam("username") String username, @RequestParam("password") String password, HttpServletRequest request, HttpServletResponse response) &#123; // 登录校验 String token = this.authService.authentication(username, password); if (StringUtils.isBlank(token)) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.UNAUTHORIZED); &#125; // 将token写入cookie,并指定httpOnly为true，防止通过JS获取和修改 CookieUtils.setCookie(request, response, prop.getCookieName(), token, prop.getCookieMaxAge(), null, true); return ResponseEntity.ok().build(); &#125;&#125; 这里的cookie的name和生存时间，我们配置到属性文件：application.yml： 然后在JwtProperties中添加属性： 2.3.3.CookieUtils要注意，这里我们使用了一个工具类，CookieUtils，可以在课前资料中找到，我们把它添加到leyou-common中，然后引入servlet相关依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;&lt;/dependency&gt; 代码：略 2.3.3.UserClient接下来我们肯定要对用户密码进行校验，所以我们需要通过FeignClient去访问 user-service微服务： 在leyou-auth中引入user-service-interface依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 参照leyou-search或者leyou-goods-web，在leyou-auth-service中编写FeignClient： 123@FeignClient(value = "user-service")public interface UserClient extends UserApi &#123;&#125; 在leyou-user-interface工程中添加api接口： 内容： 12345678@RequestMapping("user")public interface UserApi &#123; @GetMapping("query") public User queryUser( @RequestParam("username") String username, @RequestParam("password") String password);&#125; 2.3.4.AuthService在leyou-auth-service： 123456789101112131415161718192021222324252627282930@Servicepublic class AuthService &#123; @Autowired private UserClient userClient; @Autowired private JwtProperties properties; public String authentication(String username, String password) &#123; try &#123; // 调用微服务，执行查询 User user = this.userClient.queryUser(username, password); // 如果查询结果为null，则直接返回null if (user == null) &#123; return null; &#125; // 如果有查询结果，则生成token String token = JwtUtils.generateToken(new UserInfo(user.getId(), user.getUsername()), properties.getPrivateKey(), properties.getExpire()); return token; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.3.5.项目完整结构 2.3.6.测试 2.4.登录页面接下来，我们看看登录页面，是否能够正确的发出请求。 我们在页面输入登录信息，然后点击登录： 查看控制台： 发现请求的路径不对，我们的认证接口是： 1/api/auth/accredit 我们打开login.html，修改路径信息： 页面ajax请求： 然后再次测试，成功跳转到了首页： 2.5.解决cookie写入问题接下来我们查看首页cookie： 什么都没有，为什么？ 2.5.1.问题分析我们在之前测试时，清晰的看到了响应头中，有Set-Cookie属性，为什么在这里却什么都没有？ 我们之前在讲cors跨域时，讲到过跨域请求cookie生效的条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 浏览器发起ajax需要指定withCredentials 为true 看看我们的服务端cors配置： 没有任何问题。 再看客户端浏览器的ajax配置，我们在js/common.js中对axios进行了统一配置： 一切OK。 那说明，问题一定出在响应的set-cookie头中。我们再次仔细看看刚才的响应头： 我们发现cookie的 domain属性似乎不太对。 cookie也是有域 的限制，一个网页，只能操作当前域名下的cookie，但是现在我们看到的地址是0.0.1，而页面是www.leyou.com,域名不匹配，cookie设置肯定失败了！ 2.5.2.跟踪CookieUtils我们去Debug跟踪CookieUtils，看看到底是怎么回事： 我们发现内部有一个方法，用来获取Domain： 它获取domain是通过服务器的host来计算的，然而我们的地址竟然是：127.0.0.1:8087，因此后续的运算，最终得到的domain就变成了： 问题找到了：我们请求时的serverName明明是：api.leyou.com，现在却被变成了：127.0.0.1，因此计算domain是错误的，从而导致cookie设置失败！ 2.5.3.解决host地址的变化那么问题来了：为什么我们这里的请求serverName变成了：127.0.0.1:8087呢？ 这里的server name其实就是请求的时的主机名：Host，之所以改变，有两个原因： 我们使用了nginx反向代理，当监听到api.leyou.com的时候，会自动将请求转发至127.0.0.1:10010，即Zuul。 而后请求到达我们的网关Zuul，Zuul就会根据路径匹配，我们的请求是/api/auth，根据规则被转发到了 127.0.0.1:8087 ，即我们的授权中心。 我们首先去更改nginx配置，让它不要修改我们的host：proxy_set_header Host $host; 把nginx进行reload： 1nginx -s reload 这样就解决了nginx这里的问题。但是Zuul还会有一次转发，所以要去修改网关的配置（leyou-gateway工程）： 重启后，我们再次测试。 最后计算得到的domain： 完美！ 2.5.4.再次测试我们再次登录，发现依然没有cookie！！ 怎么回事呢？ 我们通过RestClient访问下看看： 发现，响应头中还是没有set-cookie。 这是怎么回事？？ 2.5.5.Zuul的敏感头过滤Zuul内部有默认的过滤器，会对请求和响应头信息进行重组，过滤掉敏感的头信息： 会发现，这里会通过一个属性为SensitiveHeaders的属性，来获取敏感头列表，然后添加到IgnoredHeaders中，这些头信息就会被忽略。 而这个SensitiveHeaders的默认值就包含了set-cookie： 解决方案有两种： 全局设置： zuul.sensitive-headers= 指定路由设置： zuul.routes.&lt;routeName&gt;.sensitive-headers= zuul.routes.&lt;routeName&gt;.custom-sensitive-headers=true 思路都是把敏感头设置为null 2.5.6.最后的测试再次重启后测试： 3.首页判断登录状态虽然cookie已经成功写入，但是我们首页的顶部，登录状态依然没能判断出用户信息： 这里需要向后台发起请求，获取根据cookie获取当前用户的信息。 我们先看页面实现 3.1.页面JS代码页面的顶部已经被我们封装为一个独立的Vue组件，在/js/pages/shortcut.js中 打开js，发现里面已经定义好了Vue组件，并且在created函数中，查询用户信息： 查看网络控制台，发现发起了请求： 因为token在cookie中，因此本次请求肯定会携带token信息在头中。 3.2.后台实现校验用户接口我们在leyou-auth-service中定义用户的校验接口，通过cookie获取token，然后校验通过返回用户信息。 请求方式：GET 请求路径：/verify 请求参数：无，不过我们需要从cookie中获取token信息 返回结果：UserInfo，校验成功返回用户信息；校验失败，则返回401 代码： 123456789101112131415161718/** * 验证用户信息 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verifyUser(@CookieValue("LY_TOKEN")String token)&#123; try &#123; // 从token中解析token信息 UserInfo userInfo = JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); // 解析成功返回用户信息 return ResponseEntity.ok(userInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 出现异常则，响应500 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#125; 3.3.测试 页面效果： 3.4.刷新token每当用户在页面进行新的操作，都应该刷新token的过期时间，否则30分钟后用户的登录信息就无效了。而刷新其实就是重新生成一份token，然后写入cookie即可。 那么问题来了：我们怎么知道用户有操作呢？ 事实上，每当用户来查询其个人信息，就证明他正在浏览网页，此时刷新cookie是比较合适的时机。因此我们可以对刚刚的校验用户登录状态的接口进行改进，加入刷新token的逻辑。 1234567891011121314151617181920212223/** * 验证用户信息 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verifyUser(@CookieValue("LY_TOKEN")String token, HttpServletRequest request, HttpServletResponse response)&#123; try &#123; // 从token中解析token信息 UserInfo userInfo = JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); // 解析成功要重新刷新token token = JwtUtils.generateToken(userInfo, this.properties.getPrivateKey(), this.properties.getExpire()); // 更新cookie中的token CookieUtils.setCookie(request, response, this.properties.getCookieName(), token, this.properties.getCookieMaxAge()); // 解析成功返回用户信息 return ResponseEntity.ok(userInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 出现异常则，响应500 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#125; 4.网关的登录拦截器接下来，我们在Zuul编写拦截器，对用户的token进行校验，如果发现未登录，则进行拦截。 4.1.引入jwt相关配置既然是登录拦截，一定是前置拦截器，我们在leyou-gateway中定义。 首先在pom.xml中，引入所需要的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后编写application.yml属性文件，添加如下内容： 1234leyou: jwt: pubKeyPath: C:\\tmp\\rsa\\rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 编写属性类，读取公钥： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ConfigurationProperties(prefix = "leyou.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private PublicKey publicKey; // 公钥 private String cookieName; private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); @PostConstruct public void init()&#123; try &#123; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥失败！", e); throw new RuntimeException(); &#125; &#125; public String getPubKeyPath() &#123; return pubKeyPath; &#125; public void setPubKeyPath(String pubKeyPath) &#123; this.pubKeyPath = pubKeyPath; &#125; public PublicKey getPublicKey() &#123; return publicKey; &#125; public void setPublicKey(PublicKey publicKey) &#123; this.publicKey = publicKey; &#125; public String getCookieName() &#123; return cookieName; &#125; public void setCookieName(String cookieName) &#123; this.cookieName = cookieName; &#125;&#125; 4.2.编写过滤器逻辑基本逻辑： 获取cookie中的token 通过JWT对token进行校验 通过：则放行；不通过：则重定向到登录页 123456789101112131415161718192021222324252627282930313233343536373839404142@Component@EnableConfigurationProperties(JwtProperties.class)public class LoginFilter extends ZuulFilter &#123; @Autowired private JwtProperties properties; @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 5; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; // 获取上下文 RequestContext context = RequestContext.getCurrentContext(); // 获取request HttpServletRequest request = context.getRequest(); // 获取token String token = CookieUtils.getCookieValue(request, this.properties.getCookieName()); // 校验 try &#123; // 校验通过什么都不做，即放行 JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); &#125; catch (Exception e) &#123; // 校验出现异常，返回403 context.setSendZuulResponse(false); context.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); &#125; return null; &#125;&#125; 重启，刷新页面，发现请求校验的接口也被拦截了： 证明我们的拦截器生效了，但是，似乎有什么不对的。这个路径似乎不应该被拦截啊！ 4.3.白名单要注意，并不是所有的路径我们都需要拦截，例如： 登录校验接口：/auth/** 注册接口：/user/register 数据校验接口：/user/check/** 发送验证码接口：/user/code 搜索接口：/search/** 另外，跟后台管理相关的接口，因为我们没有做登录和权限，因此暂时都放行，但是生产环境中要做登录校验： 后台商品服务：/item/** 所以，我们需要在拦截时，配置一个白名单，如果在名单内，则不进行拦截。 在application.yaml中添加规则： 123456789leyou: filter: allowPaths: - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item 然后读取这些属性： 内容： 12345678910111213@ConfigurationProperties(prefix = "leyou.filter")public class FilterProperties &#123; private List&lt;String&gt; allowPaths; public List&lt;String&gt; getAllowPaths() &#123; return allowPaths; &#125; public void setAllowPaths(List&lt;String&gt; allowPaths) &#123; this.allowPaths = allowPaths; &#125;&#125; 在过滤器中的shouldFilter方法中添加判断逻辑 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Component@EnableConfigurationProperties(&#123;JwtProperties.class, FilterProperties.class&#125;)public class LoginFilter extends ZuulFilter &#123; @Autowired private JwtProperties jwtProp; @Autowired private FilterProperties filterProp; private static final Logger logger = LoggerFactory.getLogger(LoginFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 5; &#125; @Override public boolean shouldFilter() &#123; // 获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); // 获取request HttpServletRequest req = ctx.getRequest(); // 获取路径 String requestURI = req.getRequestURI(); // 判断白名单 // 遍历允许访问的路径 for (String path : this.filterProp.getAllowPaths()) &#123; // 然后判断是否是符合 if(requestURI.startsWith(path))&#123; return false; &#125; &#125; return true; &#125; @Override public Object run() throws ZuulException &#123; // 获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); // 获取request HttpServletRequest request = ctx.getRequest(); // 获取token String token = CookieUtils.getCookieValue(request, jwtProp.getCookieName()); // 校验 try &#123; // 校验通过什么都不做，即放行 JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey()); &#125; catch (Exception e) &#123; // 校验出现异常，返回403 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); logger.error("非法访问，未登录，地址：&#123;&#125;", request.getRemoteHost(), e ); &#125; return null; &#125;&#125; 再次测试：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day16-用户注册]]></title>
    <url>%2F2019%2F07%2F13%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday16-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[0.学习目标 创建用户中心 了解面向接口开发方式 实现数据校验功能 实现短信发送功能 实现注册功能 实现根据用户名和密码查询用户功能 1.创建用户中心用户搜索到自己心仪的商品，接下来就要去购买，但是购买必须先登录。所以接下来我们编写用户中心，实现用户的登录和注册功能。 用户中心的提供的服务： 用户的注册 用户登录 用户个人信息管理 用户地址管理 用户收藏管理 我的订单 优惠券管理 这里我们暂时先实现基本的：注册和登录功能，其它功能大家可以自行补充完整。 因为用户中心的服务其它微服务也会调用，因此这里我们做聚合。 leyou-user：父工程，包含2个子工程： leyou-user-interface：实体及接口 leyou-user-service：业务和服务 1.1.创建父module创建 位置： 1.2.创建leyou-user-interface在leyou-user下，创建module： pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 1.3.创建leyou-user-service创建module pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.user.mapper")public class LeyouUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouUserApplication.class, args); &#125;&#125; 配置： 1234567891011121314151617181920server: port: 8085spring: application: name: user-service datasource: url: jdbc:mysql://127.0.0.1:3306/leyou username: root password: root driver-class-name: com.mysql.jdbc.Drivereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15mybatis: type-aliases-package: com.leyou.user.pojo 父工程leyou-user的pom： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;leyou-user-interface&lt;/module&gt; &lt;module&gt;leyou-user-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1.4.添加网关路由我们修改leyou-gateway，添加路由规则，对leyou-user-service进行路由: 2.后台功能准备2.1.接口文档整个用户中心的开发，我们将模拟公司内面向接口的开发。 现在假设项目经理已经设计好了接口文档，详见：《用户中心接口说明.md》 我们将根据文档直接编写后台功能，不关心页面实现。 2.2.数据结构12345678910CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;, `password` varchar(32) NOT NULL COMMENT &apos;密码，加密存储&apos;, `phone` varchar(20) DEFAULT NULL COMMENT &apos;注册手机号&apos;, `created` datetime NOT NULL COMMENT &apos;创建时间&apos;, `salt` varchar(32) NOT NULL COMMENT &apos;密码加密的salt值&apos;, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; 数据结构比较简单，因为根据用户名查询的频率较高，所以我们给用户名创建了索引 2.3.基本代码 2.3.1.实体类123456789101112131415161718@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username;// 用户名 @JsonIgnore private String password;// 密码 private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 注意：为了安全考虑。这里对password和salt添加了注解@JsonIgnore，这样在json序列化时，就不会把password和salt返回。 2.3.2.mapper12public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 2.3.3.Service123456@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper;&#125; 2.3.4.controller1234567@Controllerpublic class UserController &#123; @Autowired private UserService userService; &#125; 3.数据验证功能3.1.接口说明实现用户数据的校验，主要包括对：手机号、用户名的唯一性校验。 接口路径： 1GET /check/&#123;data&#125;/&#123;type&#125; 参数说明： 参数 说明 是否必须 数据类型 默认值 data 要校验的数据 是 String 无 type 要校验的数据类型：1，用户名；2，手机； 否 Integer 1 返回结果： 返回布尔类型结果： true：可用 false：不可用 状态码： 200：校验成功 400：参数有误 500：服务器内部异常 3.2.controller因为有了接口，我们可以不关心页面，所有需要的东西都一清二楚： 请求方式：GET 请求路径：/check/{param}/{type} 请求参数：param,type 返回结果：true或false 1234567891011121314/** * 校验数据是否可用 * @param data * @param type * @return */@GetMapping("check/&#123;data&#125;/&#123;type&#125;")public ResponseEntity&lt;Boolean&gt; checkUserData(@PathVariable("data") String data, @PathVariable(value = "type") Integer type) &#123; Boolean boo = this.userService.checkData(data, type); if (boo == null) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return ResponseEntity.ok(boo);&#125; 3.3.Service1234567891011121314public Boolean checkData(String data, Integer type) &#123; User record = new User(); switch (type) &#123; case 1: record.setUsername(data); break; case 2: record.setPhone(data); break; default: return null; &#125; return this.userMapper.selectCount(record) == 0;&#125; 3.4.测试我们在数据库插入一条假数据： 然后在浏览器调用接口，测试： 4.阿里大于短信服务4.1.demo注册页面上有短信发送的按钮，当用户点击发送短信，我们需要生成验证码，发送给用户。我们将使用阿里提供的阿里大于来实现短信发送。 参考课前资料的《阿里短信.md》学习demo入门 4.2.创建短信微服务因为系统中不止注册一个地方需要短信发送，因此我们将短信发送抽取为微服务：leyou-sms-service，凡是需要的地方都可以使用。 另外，因为短信发送API调用时长的不确定性，为了提高程序的响应速度，短信发送我们都将采用异步发送方式，即： 短信服务监听MQ消息，收到消息后发送短信。 其它服务要发送短信时，通过MQ通知短信微服务。 4.2.1.创建module 4.2.2.pom123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.sms&lt;/groupId&gt; &lt;artifactId&gt;leyou-sms-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.2.3.编写启动类123456@SpringBootApplicationpublic class LeyouSmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouSmsApplication.class, args); &#125;&#125; 4.2.4.编写application.yml12345678910server: port: 8086spring: application: name: sms-service rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 4.3.编写短信工具类项目结构： 4.3.1.属性抽取我们首先把一些常量抽取到application.yml中： 123456leyou: sms: accessKeyId: JWffwFJIwada # 你自己的accessKeyId accessKeySecret: aySRliswq8fe7rF9gQyy1Izz4MQ # 你自己的AccessKeySecret signName: 乐优商城 # 签名名称 verifyCodeTemplate: SMS_133976814 # 模板名称 然后注入到属性类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243@ConfigurationProperties(prefix = "leyou.sms")public class SmsProperties &#123; String accessKeyId; String accessKeySecret; String signName; String verifyCodeTemplate; public String getAccessKeyId() &#123; return accessKeyId; &#125; public void setAccessKeyId(String accessKeyId) &#123; this.accessKeyId = accessKeyId; &#125; public String getAccessKeySecret() &#123; return accessKeySecret; &#125; public void setAccessKeySecret(String accessKeySecret) &#123; this.accessKeySecret = accessKeySecret; &#125; public String getSignName() &#123; return signName; &#125; public void setSignName(String signName) &#123; this.signName = signName; &#125; public String getVerifyCodeTemplate() &#123; return verifyCodeTemplate; &#125; public void setVerifyCodeTemplate(String verifyCodeTemplate) &#123; this.verifyCodeTemplate = verifyCodeTemplate; &#125;&#125; 4.3.2.工具类我们把阿里提供的demo进行简化和抽取，封装一个工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsUtils &#123; @Autowired private SmsProperties prop; //产品名称:云通信短信API产品,开发者无需替换 static final String product = "Dysmsapi"; //产品域名,开发者无需替换 static final String domain = "dysmsapi.aliyuncs.com"; static final Logger logger = LoggerFactory.getLogger(SmsUtils.class); public SendSmsResponse sendSms(String phone, String code, String signName, String template) throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", prop.getAccessKeyId(), prop.getAccessKeySecret()); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象-具体描述见控制台-文档部分内容 SendSmsRequest request = new SendSmsRequest(); request.setMethod(MethodType.POST); //必填:待发送手机号 request.setPhoneNumbers(phone); //必填:短信签名-可在短信控制台中找到 request.setSignName(signName); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode(template); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 request.setTemplateParam("&#123;\"code\":\"" + code + "\"&#125;"); //选填-上行短信扩展码(无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("123456"); //hint 此处可能会抛出异常，注意catch SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); logger.info("发送短信状态：&#123;&#125;", sendSmsResponse.getCode()); logger.info("发送短信消息：&#123;&#125;", sendSmsResponse.getMessage()); return sendSmsResponse; &#125;&#125; 4.4.编写消息监听器接下来，编写消息监听器，当接收到消息后，我们发送短信。 12345678910111213141516171819202122232425262728293031323334@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsListener &#123; @Autowired private SmsUtils smsUtils; @Autowired private SmsProperties prop; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.sms.queue", durable = "true"), exchange = @Exchange(value = "leyou.sms.exchange", ignoreDeclarationExceptions = "true"), key = &#123;"sms.verify.code"&#125;)) public void listenSms(Map&lt;String, String&gt; msg) throws Exception &#123; if (msg == null || msg.size() &lt;= 0) &#123; // 放弃处理 return; &#125; String phone = msg.get("phone"); String code = msg.get("code"); if (StringUtils.isBlank(phone) || StringUtils.isBlank(code)) &#123; // 放弃处理 return; &#125; // 发送消息 SendSmsResponse resp = this.smsUtils.sendSms(phone, code, prop.getSignName(), prop.getVerifyCodeTemplate()); &#125;&#125; 我们注意到，消息体是一个Map，里面有两个属性： phone：电话号码 code：短信验证码 4.5.启动启动项目，然后查看RabbitMQ控制台，发现交换机已经创建： 队列也已经创建： 并且绑定： 5.发送短信功能短信微服务已经准备好，我们就可以继续编写用户中心接口了。 5.1.接口说明 这里的业务逻辑是这样的： 1）我们接收页面发送来的手机号码 2）生成一个随机验证码 3）将验证码保存在服务端 4）发送短信，将验证码发送到用户手机 那么问题来了：验证码保存在哪里呢？ 验证码有一定有效期，一般是5分钟，我们可以利用Redis的过期机制来保存。 5.2.Redis5.2.1.安装参考课前资料中的：《centos下的redis安装配置.md》 5.2.2.Spring Data Redis官网：http://projects.spring.io/spring-data-redis/ Spring Data Redis，是Spring Data 家族的一部分。 对Jedis客户端进行了封装，与spring进行了整合。可以非常方便的来实现redis的配置和操作。 5.2.3.RedisTemplate基本操作Spring Data Redis 提供了一个工具类：RedisTemplate。里面封装了对于Redis的五种数据结构的各种操作，包括： redisTemplate.opsForValue() ：操作字符串 redisTemplate.opsForHash() ：操作hash redisTemplate.opsForList()：操作list redisTemplate.opsForSet()：操作set redisTemplate.opsForZSet()：操作zset 其它一些通用命令，如expire，可以通过redisTemplate.xx()来直接调用 5种结构： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的Map&lt;String,List&lt;String&gt;&gt; set：等同于java中的Map&lt;String,Set&lt;String&gt;&gt; sort_set：可排序的set hash：等同于java中的：`Map&lt;String,Map&lt;String,String&gt;&gt; 5.2.4.StringRedisTemplateRedisTemplate在创建时，可以指定其泛型类型： K：代表key 的数据类型 V: 代表value的数据类型 注意：这里的类型不是Redis中存储的数据类型，而是Java中的数据类型，RedisTemplate会自动将Java类型转为Redis支持的数据类型：字符串、字节、二进制等等。 不过RedisTemplate默认会采用JDK自带的序列化（Serialize）来对对象进行转换。生成的数据十分庞大，因此一般我们都会指定key和value为String类型，这样就由我们自己把对象序列化为json字符串来存储即可。 因为大部分情况下，我们都会使用key和value都为String的RedisTemplate，因此Spring就默认提供了这样一个实现： 5.2.5.测试我们在项目中编写一个测试案例，把课前资料中的redisTest.java导入到项目中 需要在项目中引入Redis启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件中指定Redis地址： 123spring: redis: host: 192.168.56.101 5.3.在项目中实现需要三个步骤： 生成随机验证码 将验证码保存到Redis中，用来在注册的时候验证 发送验证码到leyou-sms-service服务，发送短信 因此，我们需要引入Redis和AMQP： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加RabbitMQ和Redis配置： 12345678spring: redis: host: 192.168.56.101 rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 另外还要用到工具类，生成6位随机码，这个我们封装到了leyou-common中，因此需要引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt; NumberUtils中有生成随机码的工具方法： 123456789101112/** * 生成指定位数的随机数字 * @param len 随机数的位数 * @return 生成的随机数 */public static String generateCode(int len)&#123; len = Math.min(len, 8); int min = Double.valueOf(Math.pow(10, len - 1)).intValue(); int num = new Random().nextInt( Double.valueOf(Math.pow(10, len + 1)).intValue() - 1) + min; return String.valueOf(num).substring(0,len);&#125; 5.3.1.UserController在leyou-user-service工程中的UserController添加方法： 12345678910111213/** * 发送手机验证码 * @param phone * @return */@PostMapping("code")public ResponseEntity&lt;Void&gt; sendVerifyCode(String phone) &#123; Boolean boo = this.userService.sendVerifyCode(phone); if (boo == null || !boo) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; 5.3.2.UserService在Service中添加代码： 123456789101112131415161718192021222324252627@Autowiredprivate StringRedisTemplate redisTemplate;@Autowiredprivate AmqpTemplate amqpTemplate;static final String KEY_PREFIX = "user:code:phone:";static final Logger logger = LoggerFactory.getLogger(UserService.class);public Boolean sendVerifyCode(String phone) &#123; // 生成验证码 String code = NumberUtils.generateCode(6); try &#123; // 发送短信 Map&lt;String, String&gt; msg = new HashMap&lt;&gt;(); msg.put("phone", phone); msg.put("code", code); this.amqpTemplate.convertAndSend("leyou.sms.exchange", "sms.verify.code", msg); // 将code存入redis this.redisTemplate.opsForValue().set(KEY_PREFIX + phone, code, 5, TimeUnit.MINUTES); return true; &#125; catch (Exception e) &#123; logger.error("发送短信失败。phone：&#123;&#125;， code：&#123;&#125;", phone, code); return false; &#125;&#125; 注意：要设置短信验证码在Redis的缓存时间为5分钟 5.3.3.测试通过RestClient发送请求试试： 查看Redis中的数据： 查看短信： 6.注册功能6.1.接口说明 基本逻辑： 1）校验短信验证码 2）生成盐 3）对密码加密 4）写入数据库 5）删除Redis中的验证码 6.2.UserController1234567891011121314/** * 注册 * @param user * @param code * @return */@PostMapping("register")public ResponseEntity&lt;Void&gt; register(User user, @RequestParam("code") String code) &#123; Boolean boo = this.userService.register(user, code); if (boo == null || !boo) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; 6.3.UserService1234567891011121314151617181920212223242526public Boolean register(User user, String code) &#123; // 校验短信验证码 String cacheCode = this.redisTemplate.opsForValue().get(KEY_PREFIX + user.getPhone()); if (!StringUtils.equals(code, cacheCode)) &#123; return false; &#125; // 生成盐 String salt = CodecUtils.generateSalt(); user.setSalt(salt); // 对密码加密 user.setPassword(CodecUtils.md5Hex(user.getPassword(), salt)); // 强制设置不能指定的参数为null user.setId(null); user.setCreated(new Date()); // 添加到数据库 boolean b = this.userMapper.insertSelective(user) == 1; if(b)&#123; // 注册成功，删除redis中的记录 this.redisTemplate.delete(KEY_PREFIX + user.getPhone()); &#125; return b;&#125; 此处使用了课前资料中的CodeUtils： 该工具类需要apache加密工具包： 1234&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt; 6.4.测试我们通过RestClient测试： 查看数据库： 查看redis中的信息也被删除 6.5.hibernate-validate刚才虽然实现了注册，但是服务端并没有进行数据校验，而前端的校验是很容易被有心人绕过的。所以我们必须在后台添加数据校验功能： 我们这里会使用Hibernate-Validator框架完成数据校验： 而SpringBoot的web启动器中已经集成了相关依赖： 6.5.1.什么是Hibernate ValidatorHibernate Validator是Hibernate提供的一个开源框架，使用注解方式非常方便的实现服务端的数据校验。 官网：http://hibernate.org/validator/ hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint（约束） 的实现，除此之外还有一些附加的 constraint。 在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 6.5.2.Bean校验的注解常用注解如下： Constraint 详细信息 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=,regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法，银行卡，信用卡等号码一般都用Luhn计算合法性 6.5.3.给User添加校验我们在leyou-user-interface中添加Hibernate-Validator依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; 我们在User对象的部分属性上添加注解： 1234567891011121314151617181920@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String username;// 用户名 @JsonIgnore @Length(min = 4, max = 30, message = "密码只能在4~30位之间") private String password;// 密码 @Pattern(regexp = "^1[35678]\\d&#123;9&#125;$", message = "手机号格式不正确") private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 6.5.4.在controller上进行控制在controller中改造register方法，只需要给User添加 @Valid注解即可。 6.5.5.测试我们故意填错： 然后SpringMVC会自动返回错误信息： 7.根据用户名和密码查询用户功能说明 查询功能，根据参数中的用户名和密码查询指定用户 接口路径 1GET /query 参数说明 参数 说明 是否必须 数据类型 默认值 username 用户名，格式为4~30位字母、数字、下划线 是 String 无 password 用户密码，格式为4~30位字母、数字、下划线 是 String 无 返回结果 用户的json格式数据 123456&#123; "id": 6572312, "username":"test", "phone":"13688886666", "created": 1342432424&#125; 状态码 200：注册成功 400：用户名或密码错误 500：服务器内部异常，注册失败 7.1.controller1234567891011121314151617/** * 根据用户名和密码查询用户 * @param username * @param password * @return */@GetMapping("query")public ResponseEntity&lt;User&gt; queryUser( @RequestParam("username") String username, @RequestParam("password") String password ) &#123; User user = this.userService.queryUser(username, password); if (user == null) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return ResponseEntity.ok(user); &#125; 7.2.service12345678910111213141516public User queryUser(String username, String password) &#123; // 查询 User record = new User(); record.setUsername(username); User user = this.userMapper.selectOne(record); // 校验用户名 if (user == null) &#123; return null; &#125; // 校验密码 if (!user.getPassword().equals(CodecUtils.md5Hex(password, user.getSalt()))) &#123; return null; &#125; // 用户名密码都正确 return user;&#125; 要注意，查询时也要对密码进行加密后判断是否一致。 7.3.测试 8.在注册页进行测试在注册页填写信息： 提交发现页面自动跳转到了登录页，查看数据库：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day15-rabbitmq及数据同步]]></title>
    <url>%2F2019%2F07%2F12%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday15-rabbitmq%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步 1.RabbitMQ1.1.搜索与商品服务的问题目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？ 商品的原始数据保存在数据库中，增删改查都在数据库中完成。 搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。 商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。 如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？ 这里有两种解决方案： 方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面 方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口 以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。 所以，我们会通过另外一种方式来解决这个问题：消息队列 1.2.消息队列（MQ）1.2.1.什么是消息队列消息队列，即MQ，Message Queue。 消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。 结合前面所说的问题： 商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。 搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。 如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。 1.2.2.AMQP和JMSMQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。 两者间的区别和联系： JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模型；而AMQP的消息模型更加丰富 1.2.3.常见MQ产品 ActiveMQ：基于JMS RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会 Kafka：分布式消息系统，高吞吐量 1.2.4.RabbitMQRabbitMQ是基于AMQP的一款消息管理系统 官网： http://www.rabbitmq.com/ 官方教程：http://www.rabbitmq.com/getstarted.html 1.3.下载和安装1.3.1.下载官网下载地址：http://www.rabbitmq.com/download.html 目前最新版本是：3.7.5 我们的课程中使用的是：3.4.1版本 课前资料提供了安装包： 1.3.2.安装详见课前资料中的： 2.五种消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。 但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。 我们通过一个demo工程来了解下RabbitMQ的工作方式： 导入工程： 导入后： 依赖： 123456789101112131415161718192021222324252627282930&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接： 12345678910111213141516171819202122public class ConnectionUtil &#123; /** * 建立与RabbitMQ的连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("192.168.56.101"); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/leyou"); factory.setUsername("leyou"); factory.setPassword("leyou"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; &#125;&#125; 2.1.基本消息模型官方介绍： RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。 RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。 P（producer/ publisher）：生产者，一个发送消息的用户应用程序。 C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。 总之： 生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。 我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。 我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。 2.1.1.生产者发送消息123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道，这是完成大部分API的地方。 Channel channel = connection.createChannel(); // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。 // 声明一个队列是幂等的 - 只有当它不存在时才会被创建 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 控制台： 2.1.2.管理工具中查看消息进入队列页面，可以看到新建了一个队列：simple_queue 点击队列名称，进入详情页，可以查看消息： 在控制台查看消息并不会将消息消费，所以消息还在。 2.1.3.消费者获取消息12345678910111213141516171819202122232425public class Recv &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); &#125; &#125;; // 监听队列，第二个参数：是否自动进行消息确认。 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 控制台： 这个时候，队列中的消息就没了： 我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印. 2.1.4.消息确认机制（ACK）通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。 那么问题来了：RabbitMQ怎么知道消息被接收了呢？ 如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！ 因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况： 自动ACK：消息一旦被接收，消费者自动发送ACK 手动ACK：消息接收后，不会发送ACK，需要手动调用 大家觉得哪种更好呢？ 这需要看消息的重要性： 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。 我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码： 123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; 注意到最后一行代码： 1channel.basicConsume(QUEUE_NAME, false, consumer); 如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明： 2.1.4.1.自动ACK存在的问题修改消费者，添加异常，如下： 生产者不做任何修改，直接运行，消息发送成功： 运行消费者，程序抛出异常。但是消息依然被消费： 管理界面： 2.1.4.2.演示手动ACK修改消费者，把自动改成手动（去掉之前制造的异常） 生产者不变，再次运行： 运行消费者 但是，查看管理界面，发现： 停掉消费者的程序，发现： 这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。 当我们关掉这个消费者，消息的状态再次称为Ready 修改代码手动ACK： 执行： 消息消费成功！ 2.2.work消息模型工作队列或者竞争消费者模式 在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。 这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。 接下来我们来模拟这个流程： P：生产者：任务的发布者 C1：消费者，领取任务并且完成任务，假设完成速度较快 C2：消费者2：领取任务并完成任务，假设完成速度慢 面试题：避免消息堆积？ 1）采用workqueue，多个消费者监听同一队列。 2）接收到消息以后，而是通过线程池，异步消费。 2.2.1.生产者生产者与案例1中的几乎一样： 123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "test_work_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 循环发布任务 for (int i = 0; i &lt; 50; i++) &#123; // 消息内容 String message = "task .. " + i; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); Thread.sleep(i * 2); &#125; // 关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 不过这里我们是循环发送50条消息。 2.2.2.消费者1 2.2.3.消费者2 与消费者1基本类似，就是没有设置消费耗时时间。 这里是模拟有些消费者快，有些比较慢。 接下来，两个消费者一同启动，然后发送50条消息： 可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。 2.2.4.能者多劳刚才的实现有问题吗？ 消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。 怎么实现呢？ 我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。 再次测试： 2.3.订阅模型分类在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 订阅模型示意图： 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的 X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Exchange类型有以下几种： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 我们这里先学习 Fanout：即广播模式 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 2.4.订阅模型-FanoutFanout，也称为广播。 流程图： 在广播模式下，消息发送流程是这样的： 1） 可以有多个消费者 2） 每个消费者有自己的queue（队列） 3） 每个队列都要绑定到Exchange（交换机） 4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 5） 交换机把消息发送给绑定过的所有队列 6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 2.4.1.生产者两个变化： 1） 声明Exchange，不再声明Queue 2） 发送消息到Exchange，不再发送到Queue 1234567891011121314151617181920212223public class Send &#123; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为fanout channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); // 消息内容 String message = "Hello everyone"; // 发布消息到Exchange channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes()); System.out.println(" [生产者] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.4.2.消费者112345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_1"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 要注意代码中：队列需要和交换机绑定 2.4.3.消费者212345678910111213141516171819202122232425262728293031public class Recv2 &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_2"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.4.4.测试我们运行两个消费者，然后发送1条消息： 2.5.订阅模型-Direct有选择性的接收消息 在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。 在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。 但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。 P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 2.5.1.生产者此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为direct channel.exchangeDeclare(EXCHANGE_NAME, "direct"); // 消息内容 String message = "商品新增了， id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.5.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "direct_exchange_queue_1"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 1234567891011121314151617181920212223242526272829303132public class Recv2 &#123; private final static String QUEUE_NAME = "direct_exchange_queue_2"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "insert"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.4.测试我们分别发送增、删、改的RoutingKey，发现结果： 2.6.订阅模型-TopicTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： `#`：匹配一个或多个词 `*`：匹配不多不少恰好1个词 举例： `audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs` `audit.*`：只能匹配`audit.irs` 在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。 我们创建了三个绑定：Q1绑定了绑定键“ .orange.”，Q2绑定了“..rabbit”和“lazy.＃”。 Q1匹配所有的橙色动物。 Q2匹配关于兔子以及懒惰动物的消息。 练习，生产者发送如下消息，会进入那个队列： quick.orange.rabbit Q1 Q2 lazy.orange.elephant quick.orange.fox lazy.pink.rabbit quick.brown.fox quick.orange.male.rabbit orange 2.6.1.生产者使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete： 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为topic channel.exchangeDeclare(EXCHANGE_NAME, "topic"); // 消息内容 String message = "新增商品 : id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "item.insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.6.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "topic_exchange_queue_1"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.6.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 123456789101112131415161718192021222324252627282930313233/** * 消费者2 */public class Recv2 &#123; private final static String QUEUE_NAME = "topic_exchange_queue_2"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.*"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.7.持久化如何避免消息丢失？ 1） 消费者的ACK机制。可以防止消费者丢失消息。 2） 但是，如果在消费者消费之前，MQ就宕机了，消息就没了。 是可以将消息进行持久化呢？ 要将消息持久化，前提是：队列、Exchange都持久化 2.7.1.交换机持久化 2.7.2.队列持久化 2.7.3.消息持久化 3.Spring AMQP3.1.简介Sprin有很多不同的项目，其中就有对AMQP的支持： Spring AMQP的页面：http://spring.io/projects/spring-amqp 注意这里一段描述： Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。 3.2.依赖和配置添加AMQP的启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中添加RabbitMQ地址： 123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 3.3.监听者在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。 123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125; @Componet：类上的注解，注册到Spring容器 @RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性： bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性： value：这个消费者关联的队列。值是@Queue，代表一个队列 exchange：队列所绑定的交换机，值是@Exchange类型 key：队列和交换机绑定的RoutingKey 类似listen这样的方法在一个类中可以写多个，就代表多个消费者。 3.4.AmqpTemplateSpring最擅长的事情就是封装，把他人的框架进行封装和整合。 Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法： 红框圈起来的是比较常用的3个方法，分别是： 指定交换机、RoutingKey和消息体 指定消息 指定RoutingKey和消息，会向默认的交换机发送消息 3.5.测试代码123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125; 运行后查看日志： 3.项目改造接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。 3.1.思路分析 发送方：商品微服务 什么时候发？ 当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。 发送什么内容？ 对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们只发送商品id，其它服务可以根据id查询自己需要的信息。 接收方：搜索微服务、静态页微服务 接收消息后如何处理？ 搜索微服务： 增/改：添加新的数据到索引库 删：删除索引库数据 静态页微服务： 增/改：创建新的静态页 删：删除原来的静态页 3.2.商品服务发送消息我们先在商品微服务leyou-item-service中实现发送消息。 3.2.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3.2.2.配置文件我们在application.yml中添加一些有关RabbitMQ的配置： 123456789spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou template: exchange: leyou.item.exchange publisher-confirms: true template：有关AmqpTemplate的配置 exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个 publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试 3.2.3.改造GoodsService在GoodsService中封装一个发送消息到mq的方法：（需要注入AmqpTemplate模板） 12345678private void sendMessage(Long id, String type)&#123; // 发送消息 try &#123; this.amqpTemplate.convertAndSend("item." + type, id); &#125; catch (Exception e) &#123; logger.error("&#123;&#125;商品消息发送异常，商品id：&#123;&#125;", type, id, e); &#125;&#125; 这里没有指定交换机，因此默认发送到了配置中的：leyou.item.exchange 注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑 然后在新增的时候调用： 修改的时候调用： 3.3.搜索服务接收消息搜索服务接收到消息后要做的事情： 增：添加新的数据到索引库 删：删除索引库数据 改：修改索引库数据 因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。 3.3.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3.3.2.添加配置123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 3.3.3.编写监听器 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class GoodsListener &#123; @Autowired private SearchService searchService; /** * 处理insert和update的消息 * * @param id * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建或更新索引 this.searchService.createIndex(id); &#125; /** * 处理delete的消息 * * @param id */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 删除索引 this.searchService.deleteIndex(id); &#125;&#125; 3.3.4.编写创建和删除索引方法这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引： 12345678910111213public void createIndex(Long id) throws IOException &#123; Spu spu = this.goodsClient.querySpuById(id); // 构建商品 Goods goods = this.buildGoods(spu); // 保存数据到索引库 this.goodsRepository.save(goods);&#125;public void deleteIndex(Long id) &#123; this.goodsRepository.deleteById(id);&#125; 创建索引的方法可以从之前导入数据的测试类中拷贝和改造。 3.4.静态页服务接收消息商品静态页服务接收到消息后的处理： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并覆盖原来的 不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。 3.4.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.添加配置123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 3.4.3.编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536@Componentpublic class GoodsListener &#123; @Autowired private GoodsHtmlService goodsHtmlService; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建页面 goodsHtmlService.createHtml(id); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 删除页面 goodsHtmlService.deleteHtml(id); &#125;&#125; 3.4.4.添加删除页面方法1234public void deleteHtml(Long id) &#123; File file = new File("C:\\project\\nginx-1.14.0\\html\\item\\", id + ".html"); file.deleteOnExit();&#125; 3.5.测试3.5.1.查看RabbitMQ控制台重新启动项目，并且登录RabbitMQ管理界面：http://192.168.56.101:15672 可以看到，交换机已经创建出来了： 队列也已经创建完毕： 并且队列都已经绑定到交换机： 3.5.2.修改数据试一试在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day14-商品详情及静态化]]></title>
    <url>%2F2019%2F07%2F11%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday14.%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%8F%8A%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解Thymeleaf的基本使用 实现商品详情页的渲染 知道页面静态化的作用 实现页面静态化功能 1.商品详情当用户搜索到商品，肯定会点击查看，就会进入商品详情页，接下来我们完成商品详情页的展示， 1.1.Thymeleaf在商品详情页中，我们会使用到Thymeleaf来渲染页面，所以需要先了解Thymeleaf的语法。 详见课前资料中《Thymeleaf语法入门.md》 1.2.商品详情页服务商品详情浏览量比较大，并发高，我们会独立开启一个微服务，用来展示商品详情。 1.2.1.创建module商品的详情页服务，命名为：leyou-goods-web 目录： 1.2.2.pom依赖123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.goods&lt;/groupId&gt; &lt;artifactId&gt;leyou-goods-web&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouGoodsWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouGoodsWebApplication.class, args); &#125;&#125; 1.2.4.application.yml文件1234567891011121314server: port: 8084spring: application: name: goods-web thymeleaf: cache: falseeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 1.2.5.页面模板我们从leyou-portal中复制item.html模板到当前项目resource目录下的templates中： 1.3.页面跳转1.3.1.修改页面跳转路径首先我们需要修改搜索结果页的商品地址，目前所有商品的地址都是：http://www.leyou.com/item.html 我们应该跳转到对应的商品的详情页才对。 那么问题来了：商品详情页是一个SKU？还是多个SKU的集合？ 通过详情页的预览，我们知道它是多个SKU的集合，即SPU。 所以，页面跳转时，我们应该携带SPU的id信息。 例如：http://www.leyou.com/item/2314123.html 这里就采用了路径占位符的方式来传递spu的id，我们打开search.html，修改其中的商品路径： 刷新页面后再看： 1.3.2.nginx反向代理接下来，我们要把这个地址指向我们刚刚创建的服务：leyou-goods-web，其端口为8084 我们在nginx.conf中添加一段逻辑： 把以/item开头的请求，代理到我们的8084端口。 1.3.3.编写跳转controller在leyou-goods-web中编写controller，接收请求，并跳转到商品详情页： 12345678910111213141516@Controller@RequestMapping("item")public class GoodsController &#123; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; return "item"; &#125;&#125; 1.3.4.测试启动leyou-goods-page，点击搜索页面商品，看是能够正常跳转： 现在看到的依然是静态的数据。我们接下来开始页面的渲染 1.4.封装模型数据首先我们一起来分析一下，在这个页面中需要哪些数据 我们已知的条件是传递来的spu的id，我们需要根据spu的id查询到下面的数据： spu信息 spu的详情 spu下的所有sku 品牌 商品三级分类 商品规格参数、规格参数组 1.4.1.商品微服务提供接口1.4.1.1.查询spu以上所需数据中，根据id查询spu的接口目前还没有，我们需要在商品微服务中提供这个接口： GoodsApi 1234567/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public Spu querySpuById(@PathVariable("id") Long id); GoodsController 12345678@GetMapping("spu/&#123;id&#125;")public ResponseEntity&lt;Spu&gt; querySpuById(@PathVariable("id") Long id)&#123; Spu spu = this.goodsService.querySpuById(id); if(spu == null)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(spu);&#125; GoodsService 123public Spu querySpuById(Long id) &#123; return this.spuMapper.selectByPrimaryKey(id);&#125; 1.4.1.2.查询规格参数组我们在页面展示规格时，需要按组展示： 组内有多个参数，为了方便展示。我们在leyou-item-service中提供一个接口，查询规格组，同时在规格组内的所有参数。 拓展SpecGroup类： 我们在SpecGroup中添加一个SpecParam的集合，保存该组下所有规格参数 1234567891011121314@Table(name = "tb_spec_group")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; @Transient private List&lt;SpecParam&gt; params; // 该组下的所有规格参数集合&#125; 然后提供查询接口： SpecificationAPI： 123456789101112131415161718@RequestMapping("spec")public interface SpecificationApi &#123; @GetMapping("groups/&#123;cid&#125;") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; querySpecGroups(@PathVariable("cid") Long cid); @GetMapping("/params") public List&lt;SpecParam&gt; querySpecParam( @RequestParam(value = "gid", required = false) Long gid, @RequestParam(value = "cid", required = false) Long cid, @RequestParam(value = "searching", required = false) Boolean searching, @RequestParam(value = "generic", required = false) Boolean generic); // 查询规格参数组，及组内参数 @GetMapping("&#123;cid&#125;") List&lt;SpecGroup&gt; querySpecsByCid(@PathVariable("cid") Long cid);&#125; SpecificationController 12345678@GetMapping("&#123;cid&#125;")public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; querySpecsByCid(@PathVariable("cid") Long cid)&#123; List&lt;SpecGroup&gt; list = this.specificationService.querySpecsByCid(cid); if(list == null || list.size() == 0)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; SpecificationService 123456789public List&lt;SpecGroup&gt; querySpecsByCid(Long cid) &#123; // 查询规格组 List&lt;SpecGroup&gt; groups = this.querySpecGroups(cid); groups.forEach(g -&gt; &#123; // 查询组内参数 g.setParams(this.querySpecParams(g.getId(), null, null, null)); &#125;); return groups;&#125; 在service中，我们调用之前编写过的方法，查询规格组，和规格参数，然后封装返回。 1.4.2.创建FeignClient我们在leyou-goods-web服务中，创建FeignClient： BrandClient： 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; CategoryClient 123@FeignClient("item-service")public interface CategoryClient extends CategoryApi &#123;&#125; GoodsClient: 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; SpecificationClient： 123@FeignClient(value = "item-service")public interface SpecificationClient extends SpecificationApi&#123;&#125; 1.4.3.封装数据模型我们创建一个GoodsService，在里面来封装数据模型。 这里要查询的数据： SPU SpuDetail SKU集合 商品分类 这里值需要分类的id和name就够了，因此我们查询到以后自己需要封装数据 品牌对象 规格组 查询规格组的时候，把规格组下所有的参数也一并查出，上面提供的接口中已经实现该功能，我们直接调 sku的特有规格参数 有了规格组，为什么这里还要查询？ 因为在SpuDetail中的SpecialSpec中，是以id作为规格参数id作为key，如图： 但是，在页面渲染时，需要知道参数的名称，如图： 我们就需要把id和name一一对应起来，因此需要额外查询sku的特有规格参数，然后变成一个id:name的键值对格式。也就是一个Map，方便将来根据id查找！ Service代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Servicepublic class GoodsService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; public Map&lt;String, Object&gt; loadData(Long spuId)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 根据id查询spu对象 Spu spu = this.goodsClient.querySpuById(spuId); // 查询spudetail SpuDetail spuDetail = this.goodsClient.querySpuDetailBySpuId(spuId); // 查询sku集合 List&lt;Sku&gt; skus = this.goodsClient.querySkusBySpuId(spuId); // 查询分类 List&lt;Long&gt; cids = Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3()); List&lt;String&gt; names = this.categoryClient.queryNamesByIds(cids); List&lt;Map&lt;String, Object&gt;&gt; categories = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cids.size(); i++) &#123; Map&lt;String, Object&gt; categoryMap = new HashMap&lt;&gt;(); categoryMap.put("id", cids.get(i)); categoryMap.put("name", names.get(i)); categories.add(categoryMap); &#125; // 查询品牌 Brand brand = this.brandClient.queryBrandById(spu.getBrandId()); // 查询规格参数组 List&lt;SpecGroup&gt; groups = this.specificationClient.querySpecGroupByCid(spu.getCid3()); // 查询特殊的规格参数 List&lt;SpecParam&gt; params = this.specificationClient.queryParams(null, spu.getCid3(), null, false); Map&lt;Long, String&gt; paramMap = new HashMap&lt;&gt;(); params.forEach(param -&gt; &#123; paramMap.put(param.getId(), param.getName()); &#125;); // 封装spu map.put("spu", spu); // 封装spuDetail map.put("spuDetail", spuDetail); // 封装sku集合 map.put("skus", skus); // 分类 map.put("categories", categories); // 品牌 map.put("brand", brand); // 规格参数组 map.put("groups", groups); // 查询特殊规格参数 map.put("paramMap", paramMap); return map; &#125;&#125; 然后在controller中把数据放入model： 12345678910111213141516171819202122@Controller@RequestMapping("item")public class GoodsController &#123; @Autowired private GoodsService goodsService; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; // 加载所需的数据 Map&lt;String, Object&gt; modelMap = this.goodsService.loadModel(id); // 放入模型 model.addAllAttributes(modelMap); return "item"; &#125;&#125; 1.4.4.页面测试数据我们在页面中先写一段JS，把模型中的数据取出观察，看是否成功： 123456789&lt;script th:inline="javascript"&gt; const a = /*[[$&#123;groups&#125;]]*/ []; const b = /*[[$&#123;params&#125;]]*/ []; const c = /*[[$&#123;categories&#125;]]*/ []; const d = /*[[$&#123;spu&#125;]]*/ &#123;&#125;; const e = /*[[$&#123;spuDetail&#125;]]*/ &#123;&#125;; const f = /*[[$&#123;skus&#125;]]*/ []; const g = /*[[$&#123;brand&#125;]]*/ &#123;&#125;;&lt;/script&gt; 然后查看页面源码： 数据都成功查到了！ 1.5.渲染面包屑在商品展示页的顶部，有一个商品分类、品牌、标题的面包屑 其数据有3部分： 商品分类 商品品牌 spu标题 我们的模型中都有，所以直接渲染即可（页面101行开始）： 1234567891011&lt;div class="crumb-wrap"&gt; &lt;ul class="sui-breadcrumb"&gt; &lt;li th:each="category : $&#123;categories&#125;"&gt; &lt;a href="#" th:text="$&#123;category.name&#125;"&gt;手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" th:text="$&#123;brand.name&#125;"&gt;Apple&lt;/a&gt; &lt;/li&gt; &lt;li class="active" th:text="$&#123;spu.title&#125;"&gt;Apple iPhone 6s&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.6.渲染商品列表先看下整体效果： 这个部分需要渲染的数据有5块： sku图片 sku标题 副标题 sku价格 特有规格属性列表 其中，sku 的图片、标题、价格，都必须在用户选中一个具体sku后，才能渲染。而特有规格属性列表可以在spuDetail中查询到。而副标题则是在spu中，直接可以在页面渲染 因此，我们先对特有规格属性列表进行渲染。等用户选择一个sku，再通过js对其它sku属性渲染 1.6.1.副标题副标题是在spu中，所以我们直接通过Thymeleaf渲染： 在第146行左右： 1&lt;div class="news"&gt;&lt;span th:utext="$&#123;spu.subTitle&#125;"&gt;&lt;/span&gt;&lt;/div&gt; 副标题中可能会有超链接，因此这里也用th:utext来展示，效果： 1.6.2.渲染规格属性列表规格属性列表将来会有事件和动态效果。我们需要有js代码参与，不能使用Thymeleaf来渲染了。 因此，这里我们用vue，不过需要先把数据放到js对象中，方便vue使用 初始化数据我们在页面的head中，定义一个js标签，然后在里面定义变量，保存与sku相关的一些数据： 12345678&lt;script th:inline="javascript"&gt; // sku集合 const skus = /*[[$&#123;skus&#125;]]*/ []; // 规格参数id与name对 const paramMap = /*[[$&#123;params&#125;]]*/ &#123;&#125;; // 特有规格参数集合 const specialSpec = JSON.parse(/*[[$&#123;spuDetail.specialSpec&#125;]]*/ "");&lt;/script&gt; specialSpec：这是SpuDetail中唯一与Sku相关的数据 因此我们并没有保存整个spuDetail，而是只保留了这个属性，而且需要手动转为js对象。 paramMap：规格参数的id和name键值对，方便页面根据id获取参数名 skus：sku集合 我们来看下页面获取的数据： 通过Vue渲染我们把刚才获得的几个变量保存在Vue实例中： 然后在页面中渲染： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" class="selected"&gt; &#123;&#123;str&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 然后刷新页面查看： 数据成功渲染了。不过我们发现所有的规格都被勾选了。这是因为现在，每一个规格都有样式：selected，我们应该只选中一个，让它的class样式为selected才对！ 那么问题来了，我们该如何确定用户选择了哪一个？ 1.6.3.规格属性的筛选分析规格参数的格式是这样的： 每一个规格项是数组中的一个元素，因此我们只要保存被选择的规格项的索引，就能判断哪个是用户选择的了！ 我们需要一个对象来保存用户选择的索引，格式如下： 12345&#123; "4":0, "12":0, "13":0&#125; 但问题是，第一次进入页面时，用户并未选择任何参数。因此索引应该有一个默认值，我们将默认值设置为0。 我们在head的script标签中，对索引对象进行初始化： 然后在vue中保存： 页面改造我们在页面中，通过判断indexes的值来判断当前规格是否被选中，并且给规格绑定点击事件，点击规格项后，修改indexes中的对应值： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" :class="&#123;selected: j===indexes[k]&#125;" @click="indexes[k]=j"&gt; &#123;&#123;str&#125;&#125;&lt;span v-if="j===indexes[k]" title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 效果： 1.6.4.确定SKU在我们设计sku数据的时候，就已经添加了一个字段：indexes： 这其实就是规格参数的索引组合。 而我们在页面中，用户点击选择规格后，就会把对应的索引保存起来： 因此，我们可以根据这个indexes来确定用户要选择的sku 我们在vue中定义一个计算属性，来计算与索引匹配的sku： 123456computed:&#123; sku()&#123; const index = Object.values(this.indexes).join("_"); return this.skus.find(s =&gt; s.indexes == index); &#125;&#125; 在浏览器工具中查看： 1.6.5.渲染sku列表既然已经拿到了用户选中的sku，接下来，就可以在页面渲染数据了 图片列表商品图片是一个字符串，以,分割，页面展示比较麻烦，所以我们编写一个计算属性：images()，将图片字符串变成数组： 123456789computed: &#123; sku()&#123; const index = Object.values(this.indexes).join("_"); return this.skus.find(s=&gt;s.indexes==index); &#125;, images()&#123; return this.sku.images ? this.sku.images.split(",") : ['']; &#125;&#125;, 页面改造： 123456789101112131415161718192021&lt;div class="zoom"&gt; &lt;!--默认第一个预览--&gt; &lt;div id="preview" class="spec-preview"&gt; &lt;span class="jqzoom"&gt; &lt;img :jqimg="images[0]" :src="images[0]" width="400px" height="400px"/&gt; &lt;/span&gt; &lt;/div&gt; &lt;!--下方的缩略图--&gt; &lt;div class="spec-scroll"&gt; &lt;a class="prev"&gt;&amp;lt;&lt;/a&gt; &lt;!--左右按钮--&gt; &lt;div class="items"&gt; &lt;ul&gt; &lt;li v-for="(image, i) in images" :key="i"&gt; &lt;img :src="image" :bimg="image" onmousemove="preview(this)" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a class="next"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 效果： 标题和价格 完整效果 1.7.商品详情商品详情页面如下图所示： 分成上下两部分： 上部：展示的是规格属性列表 下部：展示的是商品详情 1.7.1.属性列表（作业）这部分内容与规格参数部分重复，我就不带大家做了，大家可以自己完成 1.7.2.商品详情商品详情是HTML代码，我们不能使用 th:text，应该使用th:utext 在页面的第444行左右： 123&lt;!--商品详情--&gt;&lt;div class="intro-detail" th:utext="$&#123;spuDetail.description&#125;"&gt;&lt;/div&gt; 最终展示效果： 1.8.规格包装规格包装分成两部分： 规格参数 包装列表 而且规格参数需要按照组来显示 1.8.1.规格参数最终的效果： 我们模型中有一个groups，跟这个数据结果很像： 分成8个组，组内都有params，里面是所有的参数。不过，这些参数都没有值！ 规格参数的值分为两部分： 通用规格参数：保存在SpuDetail中的genericSpec中 特有规格参数：保存在sku的ownSpec中 我们需要把这两部分值取出来，放到groups中。 从spuDetail中取出genericSpec并取出groups： 把genericSpec引入到Vue实例： 因为sku是动态的，所以我们编写一个计算属性，来进行值的组合： 1234567891011121314groups()&#123; groups.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; if(param.generic)&#123; // 通用属性，去spu的genericSpec中获取 param.v = this.genericSpec[param.id] || '其它'; &#125;else&#123; // 特有属性值，去SKU中获取 param.v = JSON.parse(this.sku.ownSpec)[param.id] &#125; &#125;) &#125;) return groups;&#125; 然后在页面渲染： 12345678910&lt;div class="Ptable"&gt; &lt;div class="Ptable-item" v-for="group in groups" :key="group.name"&gt; &lt;h3&gt;&#123;&#123;group.name&#125;&#125;&lt;/h3&gt; &lt;dl&gt; &lt;div v-for="p in group.params"&gt; &lt;dt&gt;&#123;&#123;p.name&#125;&#125;&lt;/dt&gt;&lt;dd&gt;&#123;&#123;p.v + (p.unit || '')&#125;&#125;&lt;/dd&gt; &lt;/div&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 1.8.2.包装列表包装列表在商品详情中，我们一开始并没有赋值到Vue实例中，但是可以通过Thymeleaf来渲染 1234&lt;div class="package-list"&gt; &lt;h3&gt;包装清单&lt;/h3&gt; &lt;p th:text="$&#123;spuDetail.packingList&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 最终效果： 1.9.售后服务售后服务也可以通过Thymeleaf进行渲染： 1234&lt;div id="three" class="tab-pane"&gt; &lt;p&gt;售后保障&lt;/p&gt; &lt;p th:text="$&#123;spuDetail.afterService&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 效果： 2.页面静态化2.1.简介2.1.1.问题分析现在，我们的页面是通过Thymeleaf模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到HTML页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。 大家能想到什么办法来解决这个问题？ 首先我们能想到的就是缓存技术，比如之前学习过的Redis。不过Redis适合数据规模比较小的情况。假如数据量比较大，例如我们的商品详情页。每个页面如果10kb，100万商品，就是10GB空间，对内存占用比较大。此时就给缓存系统带来极大压力，如果缓存崩溃，接下来倒霉的就是数据库了。 所以缓存并不是万能的，某些场景需要其它技术来解决，比如静态化。 2.1.2.什么是静态化静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 而静态的HTML页面可以部署在nginx中，从而大大提高并发能力，减小tomcat压力。 2.1.3.如何实现静态化目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。常用的模板引擎比如： Freemarker Velocity Thymeleaf 我们之前就使用的Thymeleaf，来渲染html返回给用户。Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件，从而实现静态化。 2.2.Thymeleaf实现静态化2.2.1.概念先说下Thymeleaf中的几个概念： Context：运行上下文 TemplateResolver：模板解析器 TemplateEngine：模板引擎 Context 上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。 当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。 TemplateResolver 模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。 当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。 TemplateEngine 模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数： 1templateEngine.process("模板名", context, writer); 三个参数： 模板名称 上下文：里面包含模型数据 writer：输出目的地的流 在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。 而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！ 2.2.2.具体实现 Service代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class GoodsHtmlService &#123; @Autowired private GoodsService goodsService; @Autowired private TemplateEngine templateEngine; private static final Logger LOGGER = LoggerFactory.getLogger(GoodsHtmlService.class); /** * 创建html页面 * * @param spuId * @throws Exception */ public void createHtml(Long spuId) &#123; PrintWriter writer = null; try &#123; // 获取页面数据 Map&lt;String, Object&gt; spuMap = this.goodsService.loadModel(spuId); // 创建thymeleaf上下文对象 Context context = new Context(); // 把数据放入上下文对象 context.setVariables(spuMap); // 创建输出流 File file = new File("C:\\project\\nginx-1.14.0\\html\\item\\" + spuId + ".html"); writer = new PrintWriter(file); // 执行页面静态化方法 templateEngine.process("item", context, writer); &#125; catch (Exception e) &#123; LOGGER.error("页面静态化出错：&#123;&#125;，"+ e, spuId); &#125; finally &#123; if (writer != null) &#123; writer.close(); &#125; &#125; &#125; /** * 新建线程处理页面静态化 * @param spuId */ public void asyncExcute(Long spuId) &#123; ThreadUtils.execute(()-&gt;createHtml(spuId)); /*ThreadUtils.execute(new Runnable() &#123; @Override public void run() &#123; createHtml(spuId); &#125; &#125;);*/ &#125;&#125; 线程工具类： 12345678public class ThreadUtils &#123; private static final ExecutorService es = Executors.newFixedThreadPool(10); public static void execute(Runnable runnable) &#123; es.submit(runnable); &#125;&#125; 2.2.3.什么时候创建静态文件我们编写好了创建静态文件的service，那么问题来了：什么时候去调用它呢 想想这样的场景： 假如大部分的商品都有了静态页面。那么用户的请求都会被nginx拦截下来，根本不会到达我们的leyou-goods-web服务。只有那些还没有页面的请求，才可能会到达这里。 因此，如果请求到达了这里，我们除了返回页面视图外，还应该创建一个静态页面，那么下次就不会再来麻烦我们了。 所以，我们在GoodsController中添加逻辑，去生成静态html文件： 12345678910111213@GetMapping("&#123;id&#125;.html")public String toItemPage(@PathVariable("id")Long id, Model model)&#123; // 加载所需的数据 Map&lt;String, Object&gt; map = this.goodsService.loadModel(id); // 把数据放入数据模型 model.addAllAttributes(map); // 页面静态化 this.goodsHtmlService.asyncExcute(id); return "item";&#125; 注意：生成html 的代码不能对用户请求产生影响，所以这里我们使用额外的线程进行异步创建。 2.2.4.重启测试访问一个商品详情，然后查看nginx目录： 2.3.nginx代理静态页面接下来，我们修改nginx，让它对商品请求进行监听，指向本地静态页面，如果本地没找到，才进行反向代理： 1234567891011121314151617181920212223server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location /item &#123; # 先找本地 root html; if (!-f $request_filename) &#123; #请求的文件不存在，就反向代理 proxy_pass http://127.0.0.1:8084; break; &#125; &#125; location / &#123; proxy_pass http://127.0.0.1:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重启测试： 发现请求速度得到了极大提升：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day13-搜索过滤]]></title>
    <url>%2F2019%2F07%2F10%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday13-%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解过滤功能的基本思路 实现分类和品牌展示 了解规格参数展示 实现过滤条件筛选 实现已选过滤项回显 实现取消选择过滤项 1.过滤功能分析首先看下页面要实现的效果： 整个过滤部分有3块： 顶部的导航，已经选择的过滤条件展示： 商品分类面包屑，根据用户选择的商品分类变化 其它已选择过滤参数 过滤条件展示，又包含3部分 商品分类展示 品牌展示 其它规格参数 展开或收起的过滤条件的按钮 顶部导航要展示的内容跟用户选择的过滤条件有关。 比如用户选择了某个商品分类，则面包屑中才会展示具体的分类 比如用户选择了某个品牌，列表中才会有品牌信息。 所以，这部分需要依赖第二部分：过滤条件的展示和选择。因此我们先不着急去做。 展开或收起的按钮是否显示，取决于过滤条件有多少，如果很少，那么就没必要展示。所以也是跟第二部分的过滤条件有关。 这样分析来看，我们必须先做第二部分：过滤条件展示。 2.生成分类和品牌过滤先来看分类和品牌。在我们的数据库中已经有所有的分类和品牌信息。在这个位置，是不是把所有的分类和品牌信息都展示出来呢？ 显然不是，用户搜索的条件会对商品进行过滤，而在搜索结果中，不一定包含所有的分类和品牌，直接展示出所有商品分类，让用户选择显然是不合适的。 无论是分类信息，还是品牌信息，都应该从搜索的结果商品中进行聚合得到。 2.1.扩展返回的结果原来，我们返回的结果是PageResult对象，里面只有total、totalPage、items3个属性。但是现在要对商品分类和品牌进行聚合，数据显然不够用，我们需要对返回的结果进行扩展，添加分类和品牌的数据。 那么问题来了：以什么格式返回呢？ 看页面： 分类：页面显示了分类名称，但背后肯定要保存id信息。所以至少要有id和name 品牌：页面展示的有logo，有文字，当然肯定有id，基本上是品牌的完整数据 我们新建一个类，继承PageResult，然后扩展两个新的属性：分类集合和品牌集合： 1234567891011121314151617181920212223242526272829303132333435363738394041public class SearchResult extends PageResult&lt;Goods&gt; &#123; private List&lt;Map&lt;String, Object&gt;&gt; categories; private List&lt;Brand&gt; brands; public SearchResult() &#123; &#125; public SearchResult(List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands) &#123; this.categories = categories; this.brands = brands; &#125; public SearchResult(List&lt;Goods&gt; items, Long total, List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands) &#123; super(items, total); this.categories = categories; this.brands = brands; &#125; public SearchResult(List&lt;Goods&gt; items, Long total, Integer totalPage, List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands) &#123; super(items, total, totalPage); this.categories = categories; this.brands = brands; &#125; public List&lt;Map&lt;String, Object&gt;&gt; getCategories() &#123; return categories; &#125; public void setCategories(List&lt;Map&lt;String, Object&gt;&gt; categories) &#123; this.categories = categories; &#125; public List&lt;Brand&gt; getBrands() &#123; return brands; &#125; public void setBrands(List&lt;Brand&gt; brands) &#123; this.brands = brands; &#125;&#125; 2.2.聚合商品分类和品牌我们修改搜索的业务逻辑，对分类和品牌聚合。 因为索引库中只有id，所以我们根据id聚合，然后再根据id去查询完整数据。 所以，商品微服务需要提供一个接口：根据品牌id集合，批量查询品牌。 修改SearchService： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public SearchResult search(SearchRequest request) &#123; // 判断查询条件 if (StringUtils.isBlank(request.getKey())) &#123; // 返回默认结果集 return null; &#125; // 初始化自定义查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加查询条件 queryBuilder.withQuery(QueryBuilders.matchQuery("all", request.getKey()).operator(Operator.AND)); // 添加结果集过滤，只需要：id,subTitle, skus queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id", "subTitle", "skus"&#125;, null)); // 获取分页参数 Integer page = request.getPage(); Integer size = request.getSize(); // 添加分页 queryBuilder.withPageable(PageRequest.of(page - 1, size)); String categoryAggName = "categories"; String brandAggName = "brands"; queryBuilder.addAggregation(AggregationBuilders.terms(categoryAggName).field("cid3")); queryBuilder.addAggregation(AggregationBuilders.terms(brandAggName).field("brandId")); // 执行搜索，获取搜索的结果集 AggregatedPage&lt;Goods&gt; goodsPage = (AggregatedPage&lt;Goods&gt;)this.goodsReponsitory.search(queryBuilder.build()); // 解析聚合结果集 List&lt;Map&lt;String, Object&gt;&gt; categories = getCategoryAggResult(goodsPage.getAggregation(categoryAggName)); List&lt;Brand&gt; brands = getBrandAggResult(goodsPage.getAggregation(brandAggName)); // 封装成需要的返回结果集 return new SearchResult(goodsPage.getContent(), goodsPage.getTotalElements(), goodsPage.getTotalPages(), categories, brands);&#125;/** * 解析品牌聚合结果集 * @param aggregation * @return */private List&lt;Brand&gt; getBrandAggResult(Aggregation aggregation) &#123; // 处理聚合结果集 LongTerms terms = (LongTerms)aggregation; // 获取所有的品牌id桶 List&lt;LongTerms.Bucket&gt; buckets = terms.getBuckets(); // 定义一个品牌集合，搜集所有的品牌对象 List&lt;Brand&gt; brands = new ArrayList&lt;&gt;(); // 解析所有的id桶，查询品牌 buckets.forEach(bucket -&gt; &#123; Brand brand = this.brandClient.queryBrandById(bucket.getKeyAsNumber().longValue()); brands.add(brand); &#125;); return brands; // 解析聚合结果集中的桶，把桶的集合转化成id的集合 // List&lt;Long&gt; brandIds = terms.getBuckets().stream().map(bucket -&gt; bucket.getKeyAsNumber().longValue()).collect(Collectors.toList()); // 根据ids查询品牌 //return brandIds.stream().map(id -&gt; this.brandClient.queryBrandById(id)).collect(Collectors.toList()); // return terms.getBuckets().stream().map(bucket -&gt; this.brandClient.queryBrandById(bucket.getKeyAsNumber().longValue())).collect(Collectors.toList());&#125;/** * 解析分类 * @param aggregation * @return */private List&lt;Map&lt;String,Object&gt;&gt; getCategoryAggResult(Aggregation aggregation) &#123; // 处理聚合结果集 LongTerms terms = (LongTerms)aggregation; // 获取所有的分类id桶 List&lt;LongTerms.Bucket&gt; buckets = terms.getBuckets(); // 定义一个品牌集合，搜集所有的品牌对象 List&lt;Map&lt;String, Object&gt;&gt; categories = new ArrayList&lt;&gt;(); List&lt;Long&gt; cids = new ArrayList&lt;&gt;(); // 解析所有的id桶，查询品牌 buckets.forEach(bucket -&gt; &#123; cids.add(bucket.getKeyAsNumber().longValue()); &#125;); List&lt;String&gt; names = this.categoryClient.queryNamesByIds(cids); for (int i = 0; i &lt; cids.size(); i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("id", cids.get(i)); map.put("name", names.get(i)); categories.add(map); &#125; return categories;&#125; 测试： 2.3.页面渲染数据2.3.1.过滤参数数据结构来看下页面的展示效果： 虽然分类、品牌内容都不太一样，但是结构相似，都是key和value的结构。 而且页面结构也极为类似： 所以，我们可以把所有的过滤条件放入一个数组中，然后在页面利用v-for遍历一次生成。 其基本结构是这样的： 123456[ &#123; k:"过滤字段名", options:[&#123;/*过滤字段值对象*/&#125;,&#123;/*过滤字段值对象*/&#125;] &#125;] 我们先在data中定义数组：filters，等待组装过滤参数： 1234567891011data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0, // 总页数 filters:[] // 过滤参数集合&#125;, 然后在查询搜索结果的回调函数中，对过滤参数进行封装： 然后刷新页面，通过浏览器工具，查看封装的结果： 2.3.2.页面渲染数据首先看页面原来的代码： 我们注意到，虽然页面元素是一样的，但是品牌会比其它搜索条件多出一些样式，因为品牌是以图片展示。需要进行特殊处理。数据展示是一致的，我们采用v-for处理： 123456789101112131415161718192021222324252627&lt;div class="type-wrap" v-for="(f,i) in filters" :key="i" v-if="f.k !== '品牌'"&gt; &lt;div class="fl key"&gt;&#123;&#123;f.k&#125;&#125;&lt;/div&gt; &lt;div class="fl value"&gt; &lt;ul class="type-list"&gt; &lt;li v-for="(option, j) in f.options" :key="j"&gt; &lt;a&gt;&#123;&#123;option.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="type-wrap logo" v-else&gt; &lt;div class="fl key brand"&gt;&#123;&#123;f.k&#125;&#125;&lt;/div&gt; &lt;div class="value logos"&gt; &lt;ul class="logo-list"&gt; &lt;li v-for="(option, j) in f.options" v-if="option.image"&gt; &lt;img :src="option.image" /&gt; &lt;/li&gt; &lt;li style="text-align: center" v-else&gt; &lt;a style="line-height: 30px; font-size: 12px" href="#"&gt;&#123;&#123;option.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt; &lt;a href="javascript:void(0);" class="sui-btn"&gt;多选&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 结果： 3.生成规格参数过滤3.1.谋而后动有四个问题需要先思考清楚： 什么时候显示规格参数过滤？ 分类只有一个 如何知道哪些规格需要过滤？ 要过滤的参数，其可选值是如何获取的？ 规格过滤的可选值，其数据格式怎样的？ 什么情况下显示有关规格参数的过滤？ 如果用户尚未选择商品分类，或者聚合得到的分类数大于1，那么就没必要进行规格参数的聚合。因为不同分类的商品，其规格是不同的。 因此，我们在后台需要对聚合得到的商品分类数量进行判断，如果等于1，我们才继续进行规格参数的聚合。 如何知道哪些规格需要过滤？ 我们不能把数据库中的所有规格参数都拿来过滤。因为并不是所有的规格参数都可以用来过滤，参数的值是不确定的。 值的庆幸的是，我们在设计规格参数时，已经标记了某些规格可搜索，某些不可搜索。 因此，一旦商品分类确定，我们就可以根据商品分类查询到其对应的规格，从而知道哪些规格要进行搜索。 要过滤的参数，其可选值是如何获取的？ 虽然数据库中有所有的规格参数，但是不能把一切数据都用来供用户选择。 与商品分类和品牌一样，应该是从用户搜索得到的结果中聚合，得到与结果品牌的规格参数可选值。 规格过滤的可选值，其数据格式怎样的？ 我们直接看页面效果： 我们之前存储时已经将数据分段，恰好符合这里的需求 3.2.实战接下来，我们就用代码实现刚才的思路。 总结一下，应该是以下几步： 1）用户搜索得到商品，并聚合出商品分类 2）判断分类数量是否等于1，如果是则进行规格参数聚合 3）先根据分类，查找可以用来搜索的规格 4）对规格参数进行聚合 5）将规格参数聚合结果整理后返回 3.2.1.扩展返回结果返回结果中需要增加新数据，用来保存规格参数过滤条件。这里与前面的品牌和分类过滤的json结构类似： 123456[ &#123; "k":"规格参数名", "options":["规格参数值","规格参数值"] &#125;] 因此，在java中我们用List&lt;Map&lt;String, Object&gt;&gt;来表示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SearchResult extends PageResult&lt;Goods&gt; &#123; private List&lt;Map&lt;String, Object&gt;&gt; categories; private List&lt;Brand&gt; brands; private List&lt;Map&lt;String, Object&gt;&gt; specs; public SearchResult() &#123; &#125; public SearchResult(List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String, Object&gt;&gt; specs) &#123; this.categories = categories; this.brands = brands; this.specs = specs; &#125; public SearchResult(List&lt;Goods&gt; items, Long total, List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String, Object&gt;&gt; specs) &#123; super(items, total); this.categories = categories; this.brands = brands; this.specs = specs; &#125; public SearchResult(List&lt;Goods&gt; items, Long total, Integer totalPage, List&lt;Map&lt;String, Object&gt;&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String, Object&gt;&gt; specs) &#123; super(items, total, totalPage); this.categories = categories; this.brands = brands; this.specs = specs; &#125; public List&lt;Map&lt;String, Object&gt;&gt; getCategories() &#123; return categories; &#125; public void setCategories(List&lt;Map&lt;String, Object&gt;&gt; categories) &#123; this.categories = categories; &#125; public List&lt;Brand&gt; getBrands() &#123; return brands; &#125; public void setBrands(List&lt;Brand&gt; brands) &#123; this.brands = brands; &#125; public List&lt;Map&lt;String, Object&gt;&gt; getSpecs() &#123; return specs; &#125; public void setSpecs(List&lt;Map&lt;String, Object&gt;&gt; specs) &#123; this.specs = specs; &#125;&#125; 3.2.2.判断是否需要聚合首先，在聚合得到商品分类后，判断分类的个数，如果是1个则进行规格聚合： 我们将聚合的代码抽取到了一个getParamAggResult方法中。 3.2.3.获取需要聚合的规格参数然后，我们需要根据商品分类，查询所有可用于搜索的规格参数： 要注意的是，这里我们需要根据分类id查询规格，而规格参数接口需要从商品微服务提供 3.2.4.聚合规格参数因为规格参数保存时不做分词，因此其名称会自动带上一个.keyword后缀： 3.2.5.解析聚合结果 3.2.6.最终的完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public SearchResult search(SearchRequest request) &#123; // 判断查询条件 if (StringUtils.isBlank(request.getKey())) &#123; // 返回默认结果集 return null; &#125; // 初始化自定义查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加查询条件 MatchQueryBuilder basicQuery = QueryBuilders.matchQuery("all", request.getKey()).operator(Operator.AND); queryBuilder.withQuery(basicQuery); // 添加结果集过滤，只需要：id,subTitle, skus queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id", "subTitle", "skus"&#125;, null)); // 获取分页参数 Integer page = request.getPage(); Integer size = request.getSize(); // 添加分页 queryBuilder.withPageable(PageRequest.of(page - 1, size)); String categoryAggName = "categories"; String brandAggName = "brands"; queryBuilder.addAggregation(AggregationBuilders.terms(categoryAggName).field("cid3")); queryBuilder.addAggregation(AggregationBuilders.terms(brandAggName).field("brandId")); // 执行搜索，获取搜索的结果集 AggregatedPage&lt;Goods&gt; goodsPage = (AggregatedPage&lt;Goods&gt;)this.goodsReponsitory.search(queryBuilder.build()); // 解析聚合结果集 List&lt;Map&lt;String, Object&gt;&gt; categories = getCategoryAggResult(goodsPage.getAggregation(categoryAggName)); List&lt;Brand&gt; brands = getBrandAggResult(goodsPage.getAggregation(brandAggName)); // 判断分类聚合的结果集大小，等于1则聚合 List&lt;Map&lt;String, Object&gt;&gt; specs = null; if (categories.size() == 1) &#123; specs = getParamAggResult((Long)categories.get(0).get("id"), basicQuery); &#125; // 封装成需要的返回结果集 return new SearchResult(goodsPage.getContent(), goodsPage.getTotalElements(), goodsPage.getTotalPages(), categories, brands, specs);&#125;/** * 聚合出规格参数过滤条件 * @param id * @param basicQuery * @return */private List&lt;Map&lt;String,Object&gt;&gt; getParamAggResult(Long id, QueryBuilder basicQuery) &#123; // 创建自定义查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 基于基本的查询条件，聚合规格参数 queryBuilder.withQuery(basicQuery); // 查询要聚合的规格参数 List&lt;SpecParam&gt; params = this.specificationClient.queryParams(null, id, null, true); // 添加聚合 params.forEach(param -&gt; &#123; queryBuilder.addAggregation(AggregationBuilders.terms(param.getName()).field("specs." + param.getName() + ".keyword")); &#125;); // 只需要聚合结果集，不需要查询结果集 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;&#125;, null)); // 执行聚合查询 AggregatedPage&lt;Goods&gt; goodsPage = (AggregatedPage&lt;Goods&gt;)this.goodsReponsitory.search(queryBuilder.build()); // 定义一个集合，收集聚合结果集 List&lt;Map&lt;String, Object&gt;&gt; paramMapList = new ArrayList&lt;&gt;(); // 解析聚合查询的结果集 Map&lt;String, Aggregation&gt; aggregationMap = goodsPage.getAggregations().asMap(); for (Map.Entry&lt;String, Aggregation&gt; entry : aggregationMap.entrySet()) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 放入规格参数名 map.put("k", entry.getKey()); // 收集规格参数值 List&lt;Object&gt; options = new ArrayList&lt;&gt;(); // 解析每个聚合 StringTerms terms = (StringTerms)entry.getValue(); // 遍历每个聚合中桶，把桶中key放入收集规格参数的集合中 terms.getBuckets().forEach(bucket -&gt; options.add(bucket.getKeyAsString())); map.put("options", options); paramMapList.add(map); &#125; return paramMapList;&#125; 3.2.7.测试结果 3.3.页面渲染3.3.1.渲染规格过滤条件首先把后台传递过来的specs添加到filters数组： 要注意：分类、品牌的option选项是对象，里面有name属性，而specs中的option是简单的字符串，所以需要进行封装，变为相同的结构： 最后的结果： 3.3.2.展示或收起过滤条件是不是感觉显示的太多了，我们可以通过按钮点击来展开和隐藏部分内容： 我们在data中定义变量，记录展开或隐藏的状态： 然后在按钮绑定点击事件，以改变show的取值： 在展示规格时，对show进行判断： OK！ 4.过滤条件的筛选当我们点击页面的过滤项，要做哪些事情？ 把过滤条件保存在search对象中（watch监控到search变化后就会发送到后台） 在页面顶部展示已选择的过滤项 把商品分类展示到顶部面包屑 4.1.保存过滤项4.1.1.定义属性我们把已选择的过滤项保存在search中： 要注意，在created构造函数中会对search进行初始化，所以要在构造函数中对filter进行初始化： search.filter是一个对象，结构： 123&#123; "过滤项名":"过滤项值"&#125; 4.1.2.绑定点击事件给所有的过滤项绑定点击事件： 要注意，点击事件传2个参数： k：过滤项的key option：当前过滤项对象 在点击事件中，保存过滤项到selectedFilter： 123456789selectFilter(k, o)&#123; const obj = &#123;&#125;; Object.assign(obj, this.search); if(k === '分类' || k === '品牌')&#123; o = o.id; &#125; obj.filter[k] = o.name || o; this.search = obj;&#125; 另外，这里search对象中嵌套了filter对象，请求参数格式化时需要进行特殊处理，修改common.js中的一段代码： 我们刷新页面，点击后通过浏览器功能查看search.filter的属性变化： 并且，此时浏览器地址也发生了变化： 1http://www.leyou.com/search.html?key=%E6%89%8B%E6%9C%BA&amp;page=1&amp;filter.%E5%93%81%E7%89%8C=2032&amp;filter.CPU%E5%93%81%E7%89%8C=%E6%B5%B7%E6%80%9D%EF%BC%88Hisilicon%EF%BC%89&amp;filter.CPU%E6%A0%B8%E6%95%B0=%E5%8D%81%E6%A0%B8 网络请求也正常发出： 4.2.后台添加过滤条件既然请求已经发送到了后台，那接下来我们就在后台去添加这些条件： 4.2.1.拓展请求对象我们需要在请求类：SearchRequest中添加属性，接收过滤属性。过滤属性都是键值对格式，但是key不确定，所以用一个map来接收即可。 4.2.2.添加过滤条件目前，我们的基本查询是这样的： 现在，我们要把页面传递的过滤条件也加入进去。 因此不能在使用普通的查询，而是要用到BooleanQuery，基本结构是这样的： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机",operator:"and"&#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 所以，我们对原来的基本查询进行改造：（SearchService中的search方法） 因为比较复杂，我们将其封装到一个方法中： 123456789101112131415161718192021222324252627282930313233/** * 构建bool查询构建器 * @param request * @return */private BoolQueryBuilder buildBooleanQueryBuilder(SearchRequest request) &#123; BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); // 添加基本查询条件 boolQueryBuilder.must(QueryBuilders.matchQuery("all", request.getKey()).operator(Operator.AND)); // 添加过滤条件 if (CollectionUtils.isEmpty(request.getFilter()))&#123; return boolQueryBuilder; &#125; for (Map.Entry&lt;String, Object&gt; entry : request.getFilter().entrySet()) &#123; String key = entry.getKey(); // 如果过滤条件是“品牌”, 过滤的字段名：brandId if (StringUtils.equals("品牌", key)) &#123; key = "brandId"; &#125; else if (StringUtils.equals("分类", key)) &#123; // 如果是“分类”，过滤字段名：cid3 key = "cid3"; &#125; else &#123; // 如果是规格参数名，过滤字段名：specs.key.keyword key = "specs." + key + ".keyword"; &#125; boolQueryBuilder.filter(QueryBuilders.termQuery(key, entry.getValue())); &#125; return boolQueryBuilder;&#125; 其它不变。 4.3.页面测试我们先不点击过滤条件，直接搜索手机： 总共184条 接下来，我们点击一个过滤条件： 得到的结果： 5.页面展示选择的过滤项(作业)5.1.商品分类面包屑当用户选择一个商品分类以后，我们应该在过滤模块的上方展示一个面包屑，把三级商品分类都显示出来。 用户选择的商品分类就存放在search.filter中，但是里面只有第三级分类的id：cid3 我们需要根据它查询出所有三级分类的id及名称 5.1.1.提供查询分类接口我们在商品微服务中提供一个根据三级分类id查询1~3级分类集合的方法： Controller 12345678910111213/** * 根据3级分类id，查询1~3级的分类 * @param id * @return */@GetMapping("all/level")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryAllByCid3(@RequestParam("id") Long id)&#123; List&lt;Category&gt; list = this.categoryService.queryAllByCid3(id); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123456public List&lt;Category&gt; queryAllByCid3(Long id) &#123; Category c3 = this.categoryMapper.selectByPrimaryKey(id); Category c2 = this.categoryMapper.selectByPrimaryKey(c3.getParentId()); Category c1 = this.categoryMapper.selectByPrimaryKey(c2.getParentId()); return Arrays.asList(c1,c2,c3);&#125; 测试： 5.1.2.页面展示面包屑后台提供了接口，下面的问题是，我们在哪里去查询接口？ 大家首先想到的肯定是当用户点击以后。 但是我们思考一下：用户点击以后，就会重新发起请求，页面刷新，那么你渲染的结果就没了。 因此，应该是在页面重新加载完毕后，此时因为过滤条件中加入了商品分类的条件，所以查询的结果中只有1个分类。 我们判断商品分类是否只有1个，如果是，则查询三级商品分类，添加到面包屑即可。 渲染： 刷新页面： 5.2.其它过滤项接下来，我们需要在页面展示用户已选择的过滤项，如图： 我们知道，所有已选择过滤项都保存在search.filter中，因此在页面遍历并展示即可。 但这里有个问题，filter中数据的格式： 基本有四类数据： 商品分类：这个不需要展示，分类展示在面包屑位置 品牌：这个要展示，但是其key和值不合适，我们不能显示一个id在页面。需要找到其name值 数值类型规格：这个展示的时候，需要把单位查询出来 非数值类型规格：这个直接展示其值即可 因此，我们在页面上这样处理： 1234567&lt;!--已选择过滤项--&gt;&lt;ul class="tags-choose"&gt; &lt;li class="tag" v-for="(v,k) in search.filter" v-if="k !== 'cid3'" :key="k"&gt; &#123;&#123;k === 'brandId' ? '品牌' : k&#125;&#125;:&lt;span style="color: red"&gt;&#123;&#123;getFilterValue(k,v)&#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;i class="sui-icon icon-tb-close"&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt; 判断如果 k === &#39;cid3&#39;说明是商品分类，直接忽略 判断k === &#39;brandId&#39;说明是品牌，页面显示品牌，其它规格则直接显示k的值 值的处理比较复杂，我们用一个方法getFilterValue(k,v)来处理，调用时把k和v都传递 方法内部： 12345678910111213getFilterValue(k,v)&#123; // 如果没有过滤参数，我们跳过展示 if(!this.filters || this.filters.length === 0)&#123; return null; &#125; let filter = null; // 判断是否是品牌 if(k === 'brandId')&#123; // 返回品牌名称 return this.filters.find(f =&gt; f.k === 'brandId').options[0].name; &#125; return v;&#125; 然后刷新页面，即可看到效果： 5.3.隐藏已经选择的过滤项现在，我们已经实现了已选择过滤项的展示，但是你会发现一个问题： 已经选择的过滤项，在过滤列表中依然存在： 这些已经选择的过滤项，应该从列表中移除。 怎么做呢？ 你必须先知道用户选择了什么。用户选择的项保存在search.filter中： 我们可以编写一个计算属性，把filters中的 已经被选择的key过滤掉： 123456789101112computed:&#123; remainFilters()&#123; const keys = Object.keys(this.search.filter); if(this.search.filter.cid3)&#123; keys.push("cid3") &#125; if(this.search.filter.brandId)&#123; keys.push("brandId") &#125; return this.filters.filter(f =&gt; !keys.includes(f.k)); &#125;&#125; 然后页面不再直接遍历filters，而是遍历remainFilters 刷新页面： 最后发现，还剩下一堆没选过的。但是都只有一个可选项，此时再过滤没有任何意义，应该隐藏，所以，在刚才的过滤条件中，还应该添加一条：如果只剩下一个可选项，不显示 6.取消过滤项（作业）我们能够看到，每个过滤项后面都有一个小叉，当点击后，应该取消对应条件的过滤。 思路非常简单： 给小叉绑定点击事件 点击后把过滤项从search.filter中移除，页面会自动刷新，OK 绑定点击事件： 绑定点击事件时，把k传递过去，方便删除 删除过滤项 123removeFilter(k)&#123; this.search.filter[k] = null;&#125; 7.优化搜索系统需要优化的点： 查询规格参数部分可以添加缓存 聚合计算interval变化频率极低，所以可以设计为定时任务计算（周期为天），然后缓存起来。 elasticsearch本身有查询缓存，可以不进行优化 商品图片应该采用缩略图，减少流量，提高页面加载速度 图片采用延迟加载 图片还可以采用CDN服务器 sku信息应该在页面异步加载，而不是放到索引库]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day12-基本搜索]]></title>
    <url>%2F2019%2F07%2F08%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday12.%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[0.学习目标 编写数据导入功能 实现基本搜索 实现页面分页 实现结果排序 1.索引库数据导入昨天我们学习了Elasticsearch的基本应用。今天就学以致用，搭建搜索微服务，实现搜索功能。 1.1.创建搜索服务创建module： Pom文件： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.search&lt;/groupId&gt; &lt;artifactId&gt;leyou-search&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml： 12345678910111213141516server: port: 8083spring: application: name: search-service data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.56.101:9300eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 引导类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouSearchService &#123; public static void main(String[] args) &#123; SpringApplication.run(LySearchService.class, args); &#125;&#125; 1.2.索引库数据格式分析接下来，我们需要商品数据导入索引库，便于用户搜索。 那么问题来了，我们有SPU和SKU，到底如何保存到索引库？ 1.2.1.以结果为导向大家来看下搜索结果页： 可以看到，每一个搜索结果都有至少1个商品，当我们选择大图下方的小图，商品会跟着变化。 因此，搜索的结果是SPU，即多个SKU的集合。 既然搜索的结果是SPU，那么我们索引库中存储的应该也是SPU，但是却需要包含SKU的信息。 1.2.2.需要什么数据再来看看页面中有什么数据： 直观能看到的：图片、价格、标题、副标题 暗藏的数据：spu的id，sku的id 另外，页面还有过滤条件： 这些过滤条件也都需要存储到索引库中，包括： 商品分类、品牌、可用来搜索的规格参数等 综上所述，我们需要的数据格式有： spuId、SkuId、商品分类id、品牌id、图片、价格、商品的创建时间、sku信息集、可搜索的规格参数 1.2.3.最终的数据结构我们创建一个类，封装要保存到索引库的数据，并设置映射属性： 123456789101112131415161718@Document(indexName = "goods", type = "docs", shards = 1, replicas = 0)public class Goods &#123; @Id private Long id; // spuId @Field(type = FieldType.Text, analyzer = "ik_max_word") private String all; // 所有需要被搜索的信息，包含标题，分类，甚至品牌 @Field(type = FieldType.Keyword, index = false) private String subTitle;// 卖点 private Long brandId;// 品牌id private Long cid1;// 1级分类id private Long cid2;// 2级分类id private Long cid3;// 3级分类id private Date createTime;// 创建时间 private List&lt;Long&gt; price;// 价格 @Field(type = FieldType.Keyword, index = false) private String skus;// List&lt;sku&gt;信息的json结构 private Map&lt;String, Object&gt; specs;// 可搜索的规格参数，key是参数名，值是参数值&#125; 一些特殊字段解释： all：用来进行全文检索的字段，里面包含标题、商品分类信息 price：价格数组，是所有sku的价格集合。方便根据价格进行筛选过滤 skus：用于页面展示的sku信息，不索引，不搜索。包含skuId、image、price、title字段 specs：所有规格参数的集合。key是参数名，值是参数值。 例如：我们在specs中存储 内存：4G,6G，颜色为红色，转为json就是： 123456&#123; "specs":&#123; "内存":[4G,6G], "颜色":"红色" &#125;&#125; 当存储到索引库时，elasticsearch会处理为两个字段： specs.内存：[4G,6G] specs.颜色：红色 另外， 对于字符串类型，还会额外存储一个字段，这个字段不会分词，用作聚合。 specs.颜色.keyword：红色 1.3.商品微服务提供接口索引库中的数据来自于数据库，我们不能直接去查询商品的数据库，因为真实开发中，每个微服务都是相互独立的，包括数据库也是一样。所以我们只能调用商品微服务提供的接口服务。 先思考我们需要的数据： SPU信息 SKU信息 SPU的详情 商品分类名称（拼接all字段） 品牌名称 规格参数 再思考我们需要哪些服务： 第一：分批查询spu的服务，已经写过。 第二：根据spuId查询sku的服务，已经写过 第三：根据spuId查询SpuDetail的服务，已经写过 第四：根据商品分类id，查询商品分类名称，没写过 第五：根据商品品牌id，查询商品的品牌，没写过 第六：规格参数接口 因此我们需要额外提供一个查询商品分类名称的接口。 1.3.1.商品分类名称查询在CategoryController中添加接口： 123456789@GetMapping("names")public ResponseEntity&lt;List&lt;String&gt;&gt; queryNamesByIds(@RequestParam("ids")List&lt;Long&gt; ids)&#123; List&lt;String&gt; names = this.categoryService.queryNamesByIds(ids); if (CollectionUtils.isEmpty(names)) &#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(names);&#125; 测试： 1.3.2.编写FeignClient1.3.2.1.问题展现操作leyou-search工程 现在，我们要在搜索微服务调用商品微服务的接口。 第一步要在leyou-search工程中，引入商品微服务依赖：leyou-item-interface。 1234567891011&lt;!--商品微服务--&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 第二步，编写FeignClient 12345678910111213141516171819202122232425262728293031323334@FeignClient(value = "item-service")public interface GoodsClient &#123; /** * 分页查询商品 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("/spu/page") PageResult&lt;SpuBo&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", defaultValue = "true") Boolean saleable, @RequestParam(value = "key", required = false) String key); /** * 根据spu商品id查询详情 * @param id * @return */ @GetMapping("/spu/detail/&#123;id&#125;") SpuDetail querySpuDetailById(@PathVariable("id") Long id); /** * 根据spu的id查询sku * @param id * @return */ @GetMapping("sku/list") List&lt;Sku&gt; querySkuBySpuId(@RequestParam("id") Long id);&#125; 以上的这些代码直接从商品微服务中拷贝而来，完全一致。差别就是没有方法的具体实现。大家觉得这样有没有问题？ 而FeignClient代码遵循SpringMVC的风格，因此与商品微服务的Controller完全一致。这样就存在一定的问题： 代码冗余。尽管不用写实现，只是写接口，但服务调用方要写与服务controller一致的代码，有几个消费者就要写几次。 增加开发成本。调用方还得清楚知道接口的路径，才能编写正确的FeignClient。 1.3.2.2.解决方案因此，一种比较友好的实践是这样的： 我们的服务提供方不仅提供实体类，还要提供api接口声明 调用方不用自己编写接口方法声明，直接继承提供方给的Api接口即可， 第一步：服务的提供方在leyou-item-interface中提供API接口，并编写接口声明： 商品分类服务接口： 123456@RequestMapping("category")public interface CategoryApi &#123; @GetMapping("names") ResponseEntity&lt;List&lt;String&gt;&gt; queryNameByIds(@RequestParam("ids") List&lt;Long&gt; ids);&#125; 商品服务接口，返回值不再使用ResponseEntity： 12345678910111213141516171819202122232425262728293031323334@RequestMapping("/goods")public interface GoodsApi &#123; /** * 分页查询商品 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("/spu/page") PageResult&lt;SpuBo&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", defaultValue = "true") Boolean saleable, @RequestParam(value = "key", required = false) String key); /** * 根据spu商品id查询详情 * @param id * @return */ @GetMapping("/spu/detail/&#123;id&#125;") SpuDetail querySpuDetailById(@PathVariable("id") Long id); /** * 根据spu的id查询sku * @param id * @return */ @GetMapping("sku/list") List&lt;Sku&gt; querySkuBySpuId(@RequestParam("id") Long id);&#125; 品牌的接口： 123456@RequestMapping("brand")public interface BrandApi &#123; @GetMapping("&#123;id&#125;") public Brand queryBrandById(@PathVariable("id") Long id);&#125; 规格参数的接口： 123456789101112@RequestMapping("spec")public interface SpecificationApi &#123; @GetMapping("params") public List&lt;SpecParam&gt; queryParams( @RequestParam(value = "gid", required = false) Long gid, @RequestParam(value = "cid", required = false) Long cid, @RequestParam(value = "generic", required = false) Boolean generic, @RequestParam(value = "searching", required = false) Boolean searching );&#125; 需要引入springMVC及leyou-common的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 第二步：在调用方leyou-search中编写FeignClient，但不要写方法声明了，直接继承leyou-item-interface提供的api接口： 商品的FeignClient： 123@FeignClient(value = "item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 商品分类的FeignClient： 123@FeignClient(value = "item-service")public interface CategoryClient extends CategoryApi &#123;&#125; 品牌的FeignClient： 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; 规格参数的FeignClient: 123@FeignClient("item-service")public interface SpecificationClient extends SpecificationApi &#123;&#125; 是不是简单多了？ 1.3.2.3.测试在leyou-search中引入springtest依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建测试类： 在接口上按快捷键：Ctrl + Shift + T 测试代码： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class CategoryClientTest &#123; @Autowired private CategoryClient categoryClient; @Test public void testQueryCategories() &#123; List&lt;String&gt; names = this.categoryClient.queryNamesByIds(Arrays.asList(1L, 2L, 3L)); names.forEach(System.out::println); &#125;&#125; 结果： 1.4.导入数据1.4.1.创建GoodsRepository java代码： 12public interface GoodsRepository extends ElasticsearchRepository&lt;Goods, Long&gt; &#123;&#125; 1.4.2.创建索引我们新建一个测试类，在里面进行数据的操作： 1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class ElasticsearchTest &#123; @Autowired private GoodsReponsitory goodsReponsitory; @Autowired private ElasticsearchTemplate template; @Test public void createIndex()&#123; // 创建索引库，以及映射 this.template.createIndex(Goods.class); this.template.putMapping(Goods.class); &#125;&#125; 通过kibana查看： 1.4.3.导入数据导入数据其实就是查询数据，然后把查询到的Spu转变为Goods来保存，因此我们先编写一个SearchService，然后在里面定义一个方法， 把Spu转为Goods 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Servicepublic class SearchService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; private static final ObjectMapper MAPPER = new ObjectMapper(); public Goods buildGoods(Spu spu) throws IOException &#123; // 创建goods对象 Goods goods = new Goods(); // 查询品牌 Brand brand = this.brandClient.queryBrandById(spu.getBrandId()); // 查询分类名称 List&lt;String&gt; names = this.categoryClient.queryNamesByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); // 查询spu下的所有sku List&lt;Sku&gt; skus = this.goodsClient.querySkusBySpuId(spu.getId()); List&lt;Long&gt; prices = new ArrayList&lt;&gt;(); List&lt;Map&lt;String, Object&gt;&gt; skuMapList = new ArrayList&lt;&gt;(); // 遍历skus，获取价格集合 skus.forEach(sku -&gt;&#123; prices.add(sku.getPrice()); Map&lt;String, Object&gt; skuMap = new HashMap&lt;&gt;(); skuMap.put("id", sku.getId()); skuMap.put("title", sku.getTitle()); skuMap.put("price", sku.getPrice()); skuMap.put("image", StringUtils.isNotBlank(sku.getImages()) ? StringUtils.split(sku.getImages(), ",")[0] : ""); skuMapList.add(skuMap); &#125;); // 查询出所有的搜索规格参数 List&lt;SpecParam&gt; params = this.specificationClient.queryParams(null, spu.getCid3(), null, true); // 查询spuDetail。获取规格参数值 SpuDetail spuDetail = this.goodsClient.querySpuDetailBySpuId(spu.getId()); // 获取通用的规格参数 Map&lt;Long, Object&gt; genericSpecMap = MAPPER.readValue(spuDetail.getGenericSpec(), new TypeReference&lt;Map&lt;Long, Object&gt;&gt;() &#123; &#125;); // 获取特殊的规格参数 Map&lt;Long, List&lt;Object&gt;&gt; specialSpecMap = MAPPER.readValue(spuDetail.getSpecialSpec(), new TypeReference&lt;Map&lt;Long, List&lt;Object&gt;&gt;&gt;() &#123; &#125;); // 定义map接收&#123;规格参数名，规格参数值&#125; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); params.forEach(param -&gt; &#123; // 判断是否通用规格参数 if (param.getGeneric()) &#123; // 获取通用规格参数值 String value = genericSpecMap.get(param.getId()).toString(); // 判断是否是数值类型 if (param.getNumeric())&#123; // 如果是数值的话，判断该数值落在那个区间 value = chooseSegment(value, param); &#125; // 把参数名和值放入结果集中 paramMap.put(param.getName(), value); &#125; else &#123; paramMap.put(param.getName(), specialSpecMap.get(param.getId())); &#125; &#125;); // 设置参数 goods.setId(spu.getId()); goods.setCid1(spu.getCid1()); goods.setCid2(spu.getCid2()); goods.setCid3(spu.getCid3()); goods.setBrandId(spu.getBrandId()); goods.setCreateTime(spu.getCreateTime()); goods.setSubTitle(spu.getSubTitle()); goods.setAll(spu.getTitle() + brand.getName() + StringUtils.join(names, " ")); goods.setPrice(prices); goods.setSkus(MAPPER.writeValueAsString(skuMapList)); goods.setSpecs(paramMap); return goods; &#125; private String chooseSegment(String value, SpecParam p) &#123; double val = NumberUtils.toDouble(value); String result = "其它"; // 保存数值段 for (String segment : p.getSegments().split(",")) &#123; String[] segs = segment.split("-"); // 获取数值范围 double begin = NumberUtils.toDouble(segs[0]); double end = Double.MAX_VALUE; if(segs.length == 2)&#123; end = NumberUtils.toDouble(segs[1]); &#125; // 判断是否在范围内 if(val &gt;= begin &amp;&amp; val &lt; end)&#123; if(segs.length == 1)&#123; result = segs[0] + p.getUnit() + "以上"; &#125;else if(begin == 0)&#123; result = segs[1] + p.getUnit() + "以下"; &#125;else&#123; result = segment + p.getUnit(); &#125; break; &#125; &#125; return result; &#125;&#125; 因为过滤参数中有一类比较特殊，就是数值区间： 所以我们在存入时要进行处理： 1234567891011121314151617181920212223242526private String chooseSegment(String value, SpecParam p) &#123; double val = NumberUtils.toDouble(value); String result = "其它"; // 保存数值段 for (String segment : p.getSegments().split(",")) &#123; String[] segs = segment.split("-"); // 获取数值范围 double begin = NumberUtils.toDouble(segs[0]); double end = Double.MAX_VALUE; if(segs.length == 2)&#123; end = NumberUtils.toDouble(segs[1]); &#125; // 判断是否在范围内 if(val &gt;= begin &amp;&amp; val &lt; end)&#123; if(segs.length == 1)&#123; result = segs[0] + p.getUnit() + "以上"; &#125;else if(begin == 0)&#123; result = segs[1] + p.getUnit() + "以下"; &#125;else&#123; result = segment + p.getUnit(); &#125; break; &#125; &#125; return result;&#125; 然后编写一个测试类，循环查询Spu，然后调用IndexService中的方法，把SPU变为Goods，然后写入索引库： 1234567891011121314151617181920212223242526272829@Testpublic void createIndex()&#123; // 创建索引 this.elasticsearchTemplate.createIndex(Goods.class); // 配置映射 this.elasticsearchTemplate.putMapping(Goods.class); Integer page = 1; Integer rows = 100; do &#123; // 分批查询spuBo PageResult&lt;SpuBo&gt; pageResult = this.goodsClient.querySpuBoByPage(null, true, page, rows); // 遍历spubo集合转化为List&lt;Goods&gt; List&lt;Goods&gt; goodsList = pageResult.getItems().stream().map(spuBo -&gt; &#123; try &#123; return this.searchService.buildGoods((Spu) spuBo); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;).collect(Collectors.toList()); this.goodsReponsitory.saveAll(goodsList); // 获取当前页的数据条数，如果是最后一页，没有100条 rows = pageResult.getItems().size(); // 每次循环页码加1 page++; &#125; while (rows == 100);&#125; 通过kibana查询， 可以看到数据成功导入： 2.实现基本搜索2.1.页面分析2.1.1.页面跳转在首页的顶部，有一个输入框： 当我们输入任何文本，点击搜索，就会跳转到搜索页search.html了： 并且将搜索关键字以请求参数携带过来： 我们打开search.html，在最下面会有提前定义好的Vue实例： 1234567891011&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#searchApp", data: &#123; &#125;, components:&#123; // 加载页面顶部组件 lyTop: () =&gt; import("./js/pages/top.js") &#125; &#125;);&lt;/script&gt; 这个Vue实例中，通过import导入的方式，加载了另外一个js：top.js并作为一个局部组件。top其实是页面顶部导航组件，我们暂时不管 2.1.2.发起异步请求要想在页面加载后，就展示出搜索结果。我们应该在页面加载时，获取地址栏请求参数，并发起异步请求，查询后台数据，然后在页面渲染。 我们在data中定义一个对象，记录请求的参数： 12345data: &#123; search:&#123; key:"", // 搜索页面的关键字 &#125;&#125; 我们通过钩子函数created，在页面加载时获取请求参数，并记录下来。 12345678910111213created()&#123; // 判断是否有请求参数 if(!location.search)&#123; return; &#125; // 将请求参数转为对象 const search = ly.parse(location.search.substring(1)); // 记录在data的search对象中 this.search = search; // 发起请求，根据条件搜索 this.loadData();&#125; 然后发起请求，搜索数据。 12345678methods: &#123; loadData()&#123; // ly.http.post("/search/page", ly.stringify(this.search)).then(resp=&gt;&#123; ly.http.post("/search/page", this.search).then(resp=&gt;&#123; console.log(resp); &#125;); &#125;&#125; 我们这里使用ly是common.js中定义的工具对象。 这里使用的是post请求，这样可以携带更多参数，并且以json格式发送 在leyou-gateway中的CORS配置类中，添加允许信任域名： 并在leyou-gateway工程的Application.yml中添加网关映射： 刷新页面试试： 因为后台没有提供接口，所以无法访问。没关系，接下来我们实现后台接口 2.2.后台提供搜索接口2.2.1.controller 首先分析几个问题： 请求方式：Post 请求路径：/search/page，不过前面的/search应该是网关的映射路径，因此真实映射路径page，代表分页查询 请求参数：json格式，目前只有一个属性：key-搜索关键字，但是搜索结果页一定是带有分页查询的，所以将来肯定会有page属性，因此我们可以用一个对象来接收请求的json数据： 1234567891011121314151617181920212223242526272829303132public class SearchRequest &#123; private String key;// 搜索条件 private Integer page;// 当前页 private static final Integer DEFAULT_SIZE = 20;// 每页大小，不从页面接收，而是固定大小 private static final Integer DEFAULT_PAGE = 1;// 默认页 public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Integer getPage() &#123; if(page == null)&#123; return DEFAULT_PAGE; &#125; // 获取页码时做一些校验，不能小于1 return Math.max(DEFAULT_PAGE, page); &#125; public void setPage(Integer page) &#123; this.page = page; &#125; public Integer getSize() &#123; return DEFAULT_SIZE; &#125;&#125; 返回结果：作为分页结果，一般都两个属性：当前页数据、总条数信息，我们可以使用之前定义的PageResult类 代码： 12345678910111213141516171819202122@RestController@RequestMappingpublic class SearchController &#123; @Autowired private SearchService searchService; /** * 搜索商品 * * @param request * @return */ @PostMapping("page") public ResponseEntity&lt;PageResult&lt;Goods&gt;&gt; search(@RequestBody SearchRequest request) &#123; PageResult&lt;Goods&gt; result = this.searchService.search(request); if (result == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; 2.2.2.service 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class SearchService &#123; @Autowired private GoodsRepository goodsRepository; public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; String key = request.getKey(); // 判断是否有搜索条件，如果没有，直接返回null。不允许搜索全部商品 if (StringUtils.isBlank(key)) &#123; return null; &#125; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 1、对key进行全文检索查询 queryBuilder.withQuery(QueryBuilders.matchQuery("all", key).operator(Operator.AND)); // 2、通过sourceFilter设置返回的结果字段,我们只需要id、skus、subTitle queryBuilder.withSourceFilter(new FetchSourceFilter( new String[]&#123;"id","skus","subTitle"&#125;, null)); // 3、分页 // 准备分页参数 int page = request.getPage(); int size = request.getSize(); queryBuilder.withPageable(PageRequest.of(page - 1, size)); // 4、查询，获取结果 Page&lt;Goods&gt; pageInfo = this.goodsRepository.search(queryBuilder.build()); // 封装结果并返回 return new PageResult&lt;&gt;(goodsPage.getTotalElements(), goodsPage.getTotalPages(), goodsPage.getContent()); &#125;&#125; 注意点：我们要设置SourceFilter，来选择要返回的结果，否则返回一堆没用的数据，影响查询效率。 2.2.3.测试刷新页面测试： 数据是查到了，但是因为我们只查询部分字段，所以结果json 数据中有很多null，这很不优雅。 解决办法很简单，在leyou-search的application.yml中添加一行配置，json处理时忽略空值： 123spring: jackson: default-property-inclusion: non_null # 配置json处理时忽略空值 结果： 2.3.页面渲染页面已经拿到了结果，接下来就要渲染样式了。 2.3.1.保存搜索结果首先，在data中定义属性，保存搜索的结果： 在loadData的异步查询中，将结果赋值给goodsList： 2.3.2.循环展示商品在search.html的中部，有一个div，用来展示所有搜索到的商品： 可以看到，div中有一个无序列表ul，内部的每一个li就是一个商品spu了。 我们删除多余的，只保留一个li，然后利用vue的循环来展示搜索到的结果： 2.3.3.多sku展示2.3.3.1.分析接下来展示具体的商品信息，来看图： 这里我们可以发现，一个商品位置，是多个sku的信息集合。当用户鼠标选择某个sku，对应的图片、价格、标题会随之改变！ 我们先来实现sku的选择，才能去展示不同sku的数据。 可以看到，在列表中默认第一个是被选中的，那我们就需要做两件事情： 在搜索到数据时，先默认把第一个sku作为被选中的，记录下来 记录当前被选中的是哪一个sku，记录在哪里比较合适呢？显然是遍历到的goods对象自己内部，因为每一个goods都会有自己的sku信息。 2.3.3.2.初始化sku查询出的结果集skus是一个json类型的字符串，不是js对象 我们在查询成功的回调函数中，对goods进行遍历，把skus转化成json对象集合，并添加一个selected属性保存被选中的sku： 2.3.3.3.多sku图片列表接下来，我们看看多个sku的图片列表位置： 看到又是一个无序列表，这里我们也一样删掉多余的，保留一个li，需要注意选中的项有一个样式类：selected 我们的代码： 1234567&lt;!--多sku图片列表--&gt;&lt;ul class=&quot;skus&quot;&gt; &lt;li :class=&quot;&#123;selected: sku.id == goods.selected.id&#125;&quot; v-for=&quot;sku in goods.skus&quot; :key=&quot;sku.id&quot; @mouseOver=&quot;goods.selected=sku&quot;&gt; &lt;img :src=&quot;sku.image&quot;&gt; &lt;/li&gt;&lt;/ul&gt; 注意： class样式通过 goods.selected的id是否与当前sku的id一致来判断 绑定了鼠标事件，鼠标进入后把当前sku赋值到goods.selected 2.3.4.展示sku其它属性现在，我们已经可以通过goods.selected获取用户选中的sku，那么我们就可以在页面展示了： 刷新页面： 看起来很完美是吧！ 但其实有一些瑕疵 2.3.5.几个问题2.3.5.1.价格显示的是分首先价格显示就不正确，我们数据库中存放的是以分为单位，所以这里要格式化。 好在我们之前common.js中定义了工具类，可以帮我们转换。 改造： 结果报错： 为啥？ 因为在Vue范围内使用任何变量，都会默认去Vue实例中寻找，我们使用ly，但是Vue实例中没有这个变量。所以解决办法就是把ly记录到Vue实例： 然后刷新页面： 2.3.5.2.标题过长标题内容太长了，已经无法完全显示，怎么办？ 截取一下： 最好在加个悬停展示所有内容的效果 2.3.5.3.sku点击不切换还有一个错误比较隐蔽，不容易被发现。我们点击sku 的图片列表，发现没有任何变化。 这不科学啊，为什么？ 这是因为Vue的自动渲染是基于对象的属性变化的。比如页面使用GoodsList进行渲染，如果GoodsList变化，或者其内部的任何子对象变化，都会Vue感知，从而从新渲染页面。 然而，这一切有一个前提，那就是当你第一次渲染时，对象中有哪些属性，Vue就只监视这些属性，后来添加的属性发生改变，是不会被监视到的。 而我们的goods对象中，本身是没有selected属性的，是我们后来才添加进去的： 这段代码稍微改造一下，即可： 也就是说，我们先把selected属性初始化完毕，然后才把整个对象赋值给goodsList，这样，goodsList已初始化时就有selected属性，以后就会被正常监控了。 3.页面分页效果刚才的查询中，我们默认了查询的页码和每页大小，因此所有的分页功能都无法使用，接下来我们一起看看分页功能条该如何制作。 这里要分两步， 第一步：如何生成分页条 第二步：点击分页按钮，我们做什么 3.1.如何生成分页条先看下页面关于分页部分的代码： 可以看到所有的分页栏内容都是写死的。 3.1.1.需要的数据分页数据应该是根据总页数、当前页、总条数等信息来计算得出。 当前页：肯定是由页面来决定的，点击按钮会切换到对应的页 总页数：需要后台传递给我们 总条数：需要后台传递给我们 我们首先在data中记录下这几个值：page-当前页，total-总条数，totalPage-总页数 12345678910data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0 // 总页数&#125; 因为page是搜索条件之一，所以记录在search对象中。 要注意：我们在created钩子函数中，会读取url路径的参数，然后赋值给search。如果是第一次请求页面，page是不存在的。因此为了避免page被覆盖，我们应该这么做： 不过，这个时候我们自己的search对象中的值就可有可无了 3.1.2.后台提供数据后台返回的结果中，要包含total和totalPage，我们改造下刚才的接口： 在我们返回的PageResult对象中，其实是有totalPage字段的： 我们在返回时，把这个值填上： 页面测试一下： OK 3.1.3.页面计算分页条首先，把后台提供的数据保存在data中： 然后看下我们要实现的效果： 这里最复杂的是中间的1~5的分页按钮，它需要动态变化。 思路分析： 最多有5个按钮，因此我们可以用v-for循环从1到5即可 但是分页条不一定是从1开始： 如果当前页值小于等于3的时候，分页条位置从1开始到5结束 如果总页数小于等于5的时候，分页条位置从1开始到总页数结束 如果当前页码大于3，应该从page-3开始 但是如果当前页码大于totalPage-3，应该从totalPage-5开始 所以，我们的页面这样来做： a标签中的分页数字通过index函数来计算，需要把i传递过去： 1234567891011index(i)&#123; if(this.search.page &lt;= 3 || this.totalPage &lt;= 5)&#123; // 如果当前页小于等于3或者总页数小于等于5 return i; &#125; else if(this.search.page &gt; 3) &#123; // 如果当前页大于3 return this.search.page - 3 + i; &#125; else &#123; return this.totalPage - 5 + i; &#125;&#125; 需要注意的是，如果总页数不足5页，我们就不应该遍历1~5，而是1~总页数，稍作改进： 分页条的其它部分就比较简单了： 12345678910111213141516171819202122&lt;div class=&quot;sui-pagination pagination-large&quot;&gt; &lt;ul style=&quot;width: 550px&quot;&gt; &lt;li :class=&quot;&#123;prev:true,disabled:search.page === 1&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;«上一页&lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;active: index(i) === search.page&#125;&quot; v-for=&quot;i in Math.min(5,totalPage)&quot; :key=&quot;i&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123;index(i)&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dotted&quot; v-show=&quot;totalPage &gt; 5&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt; &lt;li :class=&quot;&#123;next:true,disabled:search.page === totalPage&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;下一页»&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;span&gt;共&#123;&#123;totalPage&#125;&#125;页&amp;nbsp;&lt;/span&gt; &lt;span&gt; 到第 &lt;input type=&quot;text&quot; class=&quot;page-num&quot; :value=&quot;search.page&quot;&gt; 页 &lt;button class=&quot;page-confirm&quot; onclick=&quot;alert(1)&quot;&gt;确定&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 3.2.点击分页做什么点击分页按钮后，自然是要修改page的值 所以，我们在上一页、下一页按钮添加点击事件，对page进行修改，在数字按钮上绑定点击事件，点击直接修改page： 翻页事件的方法： 12345678910prevPage()&#123; if(this.search.page &gt; 1)&#123; this.search.page-- &#125;&#125;,nextPage()&#123; if(this.search.page &lt; this.totalPage)&#123; this.search.page++ &#125;&#125; 当page发生变化，我们应该去后台重新查询数据。 不过，如果我们直接发起ajax请求，那么浏览器的地址栏中是不会有变化的，没有记录下分页信息。如果用户刷新页面，那么就会回到第一页。 这样不太友好，我们应该把搜索条件记录在地址栏的查询参数中。 因此，我们监听search的变化，然后把search的过滤字段拼接在url路径后： 123456789watch:&#123; search:&#123; deep:true, handler(val)&#123; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125;, 刷新页面测试，然后就出现重大bug：页面无限刷新！为什么？ 因为Vue实例初始化的钩子函数中，我们读取请求参数，赋值给search的时候，也触发了watch监视！也就是说，每次页面创建完成，都会触发watch，然后就会去修改window.location路径，然后页面被刷新，再次触发created钩子，又触发watch，周而复始，无限循环。 所以，我们需要在watch中进行监控，如果发现是第一次初始化，则不继续向下执行。 那么问题是，如何判断是不是第一次？ 第一次初始化时，search中的key值肯定是空的，所以，我们这么做： 12345678910111213watch:&#123; search:&#123; deep:true, handler(val,old)&#123; if(!old || !old.key)&#123; // 如果旧的search值为空，或者search中的key为空，证明是第一次 return; &#125; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125; 再次刷新，OK了！ 3.3.页面顶部分页条在页面商品列表的顶部，也有一个分页条： 我们把这一部分，也加上点击事件： 4.排序(作业)4.1.页面搜索排序条件在搜索商品列表的顶部，有这么一部分内容： 这是用来做排序的，默认按照综合排序。点击新品，应该按照商品创建时间排序，点击价格应该按照价格排序。因为我们没有统计销量和评价，这里咱们以新品和价格为例，进行讲解，做法是想通的。 排序需要知道两个内容： 排序的字段 排序的方式 因此，我们首先在search中记录这两个信息，因为created钩子函数会对search进行覆盖，因此我们在钩子函数中对这两个信息进行初始化即可： 然后，在页面上给按钮绑定点击事件，修改sortBy和descending的值： 1234567891011121314151617181920212223&lt;!--排序字段--&gt;&lt;ul class=&quot;sui-nav&quot;&gt; &lt;li :class=&quot;&#123;active:!search.sortBy&#125;&quot; @click=&quot;search.sortBy=&apos;&apos;&quot;&gt; &lt;a href=&quot;#&quot;&gt;综合&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;销量&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;createTime&apos;&quot; :class=&quot;&#123;active: search.sortBy===&apos;createTime&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;新品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;评价&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;price&apos;; search.descending = !search.descending&quot; :class=&quot;&#123;active: search.sortBy===&apos;price&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt; 价格 &lt;v-icon v-show=&quot;search.descending&quot;&gt;arrow_drop_down&lt;/v-icon&gt; &lt;v-icon v-show=&quot;!search.descending&quot;&gt;arrow_drop_up&lt;/v-icon&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看到，页面请求参数中已经有了排序字段了： 4.2.后台添加排序逻辑接下来，后台需要接收请求参数中的排序信息，然后在搜索中加入排序的逻辑。 现在，我们的请求参数对象SearchRequest中，只有page、key两个字段。需要进行扩展： 然后在搜索业务逻辑中，添加排序条件： 注意，因为我们存储在索引库中的的价格是一个数组，因此在按照价格排序时，会进行智能处理： 如果是价格降序，则会把数组中的最大值拿来排序 如果是价格升序，则会把数组中的最小值拿来排序]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day11-Elasticsearch]]></title>
    <url>%2F2019%2F07%2F07%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday11-elasticsearch%2F</url>
    <content type="text"><![CDATA[0.学习目标 独立安装Elasticsearch 会使用Rest的API操作索引 会使用Rest的API查询数据 会使用Rest的API聚合数据 掌握Spring Data Elasticsearch使用 1.Elasticsearch介绍和安装用户访问我们的首页，一般都会直接搜索来寻找自己想要购买的商品。 而商品的数量非常多，而且分类繁杂。如何能正确的显示出用户想要的商品，并进行合理的过滤，尽快促成交易，是搜索系统要研究的核心。 面对这样复杂的搜索业务和数据量，使用传统数据库搜索就显得力不从心，一般我们都会使用全文检索技术，比如之前大家学习过的Solr。 不过今天，我们要讲的是另一个全文检索技术：Elasticsearch。 1.1.简介1.1.1.ElasticElastic官网：https://www.elastic.co/cn/ Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。 1.1.2.ElasticsearchElasticsearch官网：https://www.elastic.co/cn/products/elasticsearch 如上所述，Elasticsearch具备以下特点： 分布式，无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心） Restful风格，一切API都遵循Rest原则，容易上手 近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。 1.1.3.版本目前Elasticsearch最新的版本是6.3.1，我们就使用6.3.0 需要虚拟机JDK1.8及以上 1.2.安装和配置为了模拟真实场景，我们将在linux下安装Elasticsearch。 1.2.1.新建一个用户leyou出于安全考虑，elasticsearch默认不允许以root账号运行。 创建用户： 1useradd leyou 设置密码： 1passwd leyou 切换用户： 1su - leyou 1.2.2.上传安装包,并解压我们将安装包上传到：/home/leyou目录 解压缩： 1tar -zxvf elasticsearch-6.2.4.tar.gz 我们把目录重命名： 1mv elasticsearch-6.3.0/ elasticsearch 进入，查看目录结构： 1.2.3.修改配置我们进入config目录：cd config 需要修改的配置文件有两个： jvm.options Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。 编辑jvm.options： 1vim jvm.options 默认配置如下： 12-Xms1g-Xmx1g 内存占用太多了，我们调小一些： 12-Xms512m-Xmx512m elasticsearch.yml 1vim elasticsearch.yml 修改数据和日志目录： 12path.data: /home/leyou/elasticsearch/data # 数据目录位置path.logs: /home/leyou/elasticsearch/logs # 日志目录位置 我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。 进入elasticsearch的根目录，然后创建： 12mkdir datamkdir logs 修改绑定的ip： 1network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问 默认只允许本机访问，修改为0.0.0.0后则可以远程访问 目前我们是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。 elasticsearch.yml的其它可配置信息： 属性名 说明 cluster.name 配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。 node.name 节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理 path.conf 设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch path.data 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开 path.logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 path.plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 bootstrap.memory_lock 设置为true可以锁住ES使用的内存，避免内存进行swap network.host 设置bind_host和publish_host，设置为0.0.0.0允许外网访问 http.port 设置对外服务的http端口，默认为9200。 transport.tcp.port 集群结点之间通信端口 discovery.zen.ping.timeout 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些 discovery.zen.minimum_master_nodes 主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2 1.3.运行进入elasticsearch/bin目录，可以看到下面的执行文件： 然后输入命令： 1./elasticsearch 发现报错了，启动失败。 1.3.1.错误1：内核过低 我们使用的是centos6，其linux内核版本为2.6。而Elasticsearch的插件要求至少3.5以上版本。不过没关系，我们禁用这个插件即可。 修改elasticsearch.yml文件，在最下面添加如下配置： 1bootstrap.system_call_filter: false 然后重启 1.3.2.错误2：文件权限不足再次启动，又出错了： 1[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 我们用的是leyou用户，而不是root，所以文件权限不足。 首先用root用户登录。 然后修改配置文件: 1vim /etc/security/limits.conf 添加下面的内容： 1234567* soft nofile 65536* hard nofile 131072* soft nproc 4096* hard nproc 4096 1.3.3.错误3：线程数不够刚才报错中，还有一行： 1[1]: max number of threads [1024] for user [leyou] is too low, increase to at least [4096] 这是线程数不够。 继续修改配置： 1vim /etc/security/limits.d/90-nproc.conf 修改下面的内容： 1* soft nproc 1024 改为： 1* soft nproc 4096 1.3.4.错误4：进程虚拟内存1[3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量，继续修改配置文件， ： 1vim /etc/sysctl.conf 添加下面内容： 1vm.max_map_count=655360 然后执行命令： 1sysctl -p 1.3.5.重启终端窗口所有错误修改完毕，一定要重启你的 Xshell终端，否则配置无效。 1.3.6.启动再次启动，终于成功了！ 可以看到绑定了两个端口: 9300：集群节点间通讯接口 9200：客户端访问接口 我们在浏览器中访问：http://192.168.56.101:9200 1.4.安装kibana1.4.1.什么是Kibana？ Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。 1.4.2.安装因为Kibana依赖于node，我们的虚拟机没有安装node，而window中安装过。所以我们选择在window下使用kibana。 最新版本与elasticsearch保持一致，也是6.3.0 解压到特定目录即可 1.4.3.配置运行 配置 进入安装目录下的config目录，修改kibana.yml文件： 修改elasticsearch服务器的地址： 1elasticsearch.url: &quot;http://192.168.56.101:9200&quot; 运行 进入安装目录下的bin目录： 双击运行： 发现kibana的监听端口是5601 我们访问：http://127.0.0.1:5601 1.4.4.控制台选择左侧的DevTools菜单，即可进入控制台页面： 在页面右侧，我们就可以输入请求，访问Elasticsearch了。 1.5.安装ik分词器Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为ElasticSearch的集成插件了，与Elasticsearch一起维护升级，版本也保持一致，最新版本：6.3.0 1.5.1.安装上传课前资料中的zip包，解压到Elasticsearch目录的plugins目录中： 使用unzip命令解压： 1unzip elasticsearch-analysis-ik-6.3.0.zip -d ik-analyzer 然后重启elasticsearch： 1.5.2.测试大家先不管语法，我们先测试一波。 在kibana控制台输入下面的请求： 12345POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 运行得到结果： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中国人&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;国人&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125; ]&#125; 1.7.APIElasticsearch提供了Rest风格的API，即http请求接口，而且也提供了各种语言的客户端API 1.7.1.Rest风格API文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 1.7.2.客户端APIElasticsearch支持的客户端非常多：https://www.elastic.co/guide/en/elasticsearch/client/index.html 点击Java Rest Client后，你会发现又有两个： Low Level Rest Client是低级别封装，提供一些基础功能，但更灵活 High Level Rest Client，是在Low Level Rest Client基础上进行的高级别封装，功能更丰富和完善，而且API会变的简单 1.7.3.如何学习建议先学习Rest风格API，了解发起请求的底层实现，请求体格式等。 2.操作索引2.1.基本概念Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。 对比关系： 1234567索引（indices）--------------------------------Databases 数据库 类型（type）-----------------------------Table 数据表 文档（Document）----------------Row 行 字段（Field）-------------------Columns 列 详细说明： 概念 说明 索引库（indices) indices是index的复数，代表许多的索引， 类型（type） 类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念 文档（document） 存入索引库原始的数据。比如每一条商品信息，就是一个文档 字段（field） 文档中的属性 映射配置（mappings） 字段的数据类型、属性、是否索引、是否存储等特性 是不是与Lucene和solr中的概念类似。 另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的： 索引集（Indices，index的复数）：逻辑上的完整索引 collection1 分片（shard）：数据拆分后的各个部分 副本（replica）：每个分片的复制 要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。 2.2.创建索引2.2.1.语法Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求 创建索引的请求格式： 请求方式：PUT 请求路径：/索引库名 请求参数：json格式： 123456&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 2 &#125;&#125; settings：索引库的设置 number_of_shards：分片数量 number_of_replicas：副本数量 2.2.2.测试我们先用RestClient来试试 响应： 可以看到索引创建成功了。 2.2.3.使用kibana创建kibana的控制台，可以对http请求进行简化，示例： 相当于是省去了elasticsearch的服务器地址 而且还有语法提示，非常舒服。 2.3.查看索引设置 语法 Get请求可以帮我们查看索引信息，格式： 1GET /索引库名 或者，我们可以使用*来查询所有索引库配置： 2.4.删除索引删除索引使用DELETE请求 语法 1DELETE /索引库名 示例 再次查看heima2： 当然，我们也可以用HEAD请求，查看索引是否存在： 2.5.映射配置索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。 什么是映射？ 映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等 只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定） 2.5.1.创建映射字段 语法 请求方式依然是PUT 1234567891011PUT /索引库名/_mapping/类型名称&#123; &quot;properties&quot;: &#123; &quot;字段名&quot;: &#123; &quot;type&quot;: &quot;类型&quot;, &quot;index&quot;: true， &quot;store&quot;: true， &quot;analyzer&quot;: &quot;分词器&quot; &#125; &#125;&#125; 类型名称：就是前面将的type的概念，类似于数据库中的不同表字段名：任意填写 ，可以指定许多属性，例如： type：类型，可以是text、long、short、date、integer、object等 index：是否索引，默认为true store：是否存储，默认为false analyzer：分词器，这里的ik_max_word即使用ik分词器 示例 发起请求： 12345678910111213141516PUT heima/_mapping/goods&#123; "properties": &#123; "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125;, "images": &#123; "type": "keyword", "index": "false" &#125;, "price": &#123; "type": "float" &#125; &#125;&#125; 响应结果： 123&#123; &quot;acknowledged&quot;: true&#125; 2.5.2.查看映射关系 语法： 1GET /索引库名/_mapping 示例： 1GET /heima/_mapping 响应： 123456789101112131415161718192021&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; 2.5.3.字段属性详解2.5.3.1.typeElasticsearch中支持的数据类型非常丰富： 我们说几个关键的： String类型，又分两种： text：可分词，不可参与聚合 keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 2.5.3.2.indexindex影响字段的索引情况。 true：字段会被索引，则可以用来进行搜索。默认值就是true false：字段不会被索引，不能用来搜索 index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。 但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。 2.5.3.3.store是否将数据进行额外存储。 在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。 但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。 原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做_source的属性中。而且我们可以通过过滤_source来选择哪些要显示，哪些不显示。 而如果设置store为true，就会在_source以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。 2.5.3.4.boost激励因子，这个与lucene中一样 其它的不再一一讲解，用的不多，大家参考官方文档： 2.6.新增数据2.6.1.随机生成id通过POST请求，可以向一个已经存在的索引库中添加数据。 语法： 1234POST /索引库名/类型名&#123; &quot;key&quot;:&quot;value&quot;&#125; 示例： 123456POST /heima/goods/&#123; "title":"小米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2699.00&#125; 响应： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "result": "created", "_shards": &#123; "total": 3, "successful": 1, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 2&#125; 通过kibana查看数据： 123456get _search&#123; "query":&#123; "match_all":&#123;&#125; &#125;&#125; 123456789101112&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125;&#125; _source：源文档信息，所有的数据都在里面。 _id：这条文档的唯一标示，与文档自己的id字段没有关联 2.6.2.自定义id如果我们想要自己新增的时候指定id，可以这么做： 1234POST /索引库名/类型/id值&#123; ...&#125; 示例： 123456POST /heima/goods/2&#123; "title":"大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00&#125; 得到的数据： 1234567891011&#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125;&#125; 2.6.3.智能判断在学习Solr时我们发现，我们在新增数据时，只能使用提前配置好映射属性的字段，否则就会报错。 不过在Elasticsearch中并没有这样的规定。 事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。 测试一下： 12345678POST /heima/goods/3&#123; "title":"超米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00, "stock": 200, "saleable":true&#125; 我们额外添加了stock库存，和saleable是否上架两个字段。 来看结果： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "3", "_version": 1, "_score": 1, "_source": &#123; "title": "超米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899, "stock": 200, "saleable": true &#125;&#125; 在看下索引库的映射关系: 123456789101112131415161718192021222324252627&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "saleable": &#123; "type": "boolean" &#125;, "stock": &#123; "type": "long" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; stock和saleable都被成功映射了。 2.7.修改数据把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定id， id对应文档存在，则修改 id对应文档不存在，则新增 比如，我们把id为3的数据进行修改： 12345678PUT /heima/goods/3&#123; "title":"超大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00, "stock": 100, "saleable":true&#125; 结果： 1234567891011121314151617181920212223242526272829&#123; "took": 17, "timed_out": false, "_shards": &#123; "total": 9, "successful": 9, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "超大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 3899, "stock": 100, "saleable": true &#125; &#125; ] &#125;&#125; 2.8.删除数据删除使用DELETE请求，同样，需要根据id进行删除： 语法 1DELETE /索引库名/类型名/id值 示例： 3.查询我们从4块来讲查询： 基本查询 _source过滤 结果过滤 高级查询 排序 3.1.基本查询 基本语法 12345678GET /索引库名/_search&#123; "query":&#123; "查询类型":&#123; "查询条件":"查询条件值" &#125; &#125;&#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如：match_all， match，term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解 3.1.1 查询所有（match_all) 示例： 123456GET /heima/_search&#123; "query":&#123; "match_all": &#123;&#125; &#125;&#125; query：代表查询对象 match_all：代表查询所有 结果： 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; took：查询花费时间，单位是毫秒 time_out：是否超时 _shards：分片信息 hits：搜索结果总览对象 total：搜索到的总条数 max_score：所有结果中文档得分的最高分 hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息 _index：索引库 _type：文档类型 _id：文档id _score：文档得分 _source：文档的源数据 3.1.2 匹配查询（match）我们先加入一条数据，便于测试： 123456PUT /heima/goods/3&#123; "title":"小米电视4A", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00&#125; 现在，索引库中有2部手机，1台电视： or关系 match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系 12345678GET /heima/_search&#123; "query":&#123; "match":&#123; "title":"小米电视" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728"hits": &#123; "total": 2, "max_score": 0.6931472, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "tmUBomQB_mwm6wH_EC1-", "_score": 0.6931472, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ]&#125; 在上面的案例中，不仅会查询到电视，而且与小米相关的都会查询到，多个词之间是or的关系。 and关系 某些情况下，我们需要更精确查找，我们希望这个关系变成and，可以这样做： 1234567891011GET /heima/_search&#123; "query":&#123; "match": &#123; "title": &#123; "query": "小米电视", "operator": "and" &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 本例中，只有同时包含小米和电视的词条才会被搜索到。 or和and之间？ 在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。 有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。 match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量： 1234567891011GET /heima/_search&#123; "query":&#123; "match":&#123; "title":&#123; "query":"小米曲面电视", "minimum_should_match": "75%" &#125; &#125; &#125;&#125; 本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。 结果： 3.1.3 多字段查询（multi_match）multi_match与match类似，不同的是它可以在多个字段中查询 123456789GET /heima/_search&#123; "query":&#123; "multi_match": &#123; "query": "小米", "fields": [ "title", "subTitle" ] &#125; &#125;&#125; 本例中，我们会在title字段和subtitle字段中查询小米这个词 3.1.4 词条匹配(term)term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串 12345678GET /heima/_search&#123; "query":&#123; "term":&#123; "price":2699.00 &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; 3.1.5 多词条精确匹配(terms)terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 12345678GET /heima/_search&#123; "query":&#123; "terms":&#123; "price":[2699.00,2899.00,3899.00] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 3.2.结果过滤默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。 如果我们只想获取其中的部分字段，我们可以添加_source的过滤 3.2.1.直接指定字段示例： 123456789GET /heima/_search&#123; "_source": ["title","price"], "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 返回的结果： 1234567891011121314151617181920212223242526&#123; "took": 12, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "price": 2699, "title": "小米手机" &#125; &#125; ] &#125;&#125; 3.2.2.指定includes和excludes我们也可以通过： includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 二者都是可选的。 示例： 1234567891011GET /heima/_search&#123; "_source": &#123; "includes":["title","price"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 与下面的结果将是一样的： 1234567891011GET /heima/_search&#123; "_source": &#123; "excludes": ["images"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 3.3 高级查询3.3.1 布尔组合（bool)bool把各种其它查询通过must（与）、must_not（非）、should（或）的方式进行组合 12345678910GET /heima/_search&#123; "query":&#123; "bool":&#123; "must": &#123; "match": &#123; "title": "大米" &#125;&#125;, "must_not": &#123; "match": &#123; "title": "电视" &#125;&#125;, "should": &#123; "match": &#123; "title": "手机" &#125;&#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 10, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 0.5753642, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125; ] &#125;&#125; 3.3.2 范围查询(range)range 查询找出那些落在指定区间内的数字或者时间 1234567891011GET /heima/_search&#123; "query":&#123; "range": &#123; "price": &#123; "gte": 1000.0, "lt": 2800.00 &#125; &#125; &#125;&#125; range查询允许以下字符： 操作符 说明 gt 大于 gte 大于等于 lt 小于 lte 小于等于 3.3.3 模糊查询(fuzzy)我们新增一个商品： 123456POST /heima/goods/4&#123; "title":"apple手机", "images":"http://image.leyou.com/12479122.jpg", "price":6899.00&#125; fuzzy 查询是 term 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2： 12345678GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": "appla" &#125; &#125;&#125; 上面的查询，也能查询到apple手机 我们可以通过fuzziness来指定允许的编辑距离： 1234567891011GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": &#123; "value":"appla", "fuzziness":1 &#125; &#125; &#125;&#125; 3.4 过滤(filter) 条件查询中进行过滤 所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用filter方式： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 注意：filter中还可以再次进行bool组合条件过滤。 无查询条件，直接过滤 如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用constant_score取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。 123456789GET /heima/_search&#123; "query":&#123; "constant_score": &#123; "filter": &#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3000.00&#125;&#125; &#125; &#125;&#125; 3.5 排序3.4.1 单字段排序sort 可以让我们按照不同的字段进行排序，并且通过order指定排序的方式 123456789101112131415GET /heima/_search&#123; "query": &#123; "match": &#123; "title": "小米手机" &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125; &#125; ]&#125; 3.4.2 多字段排序假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序： 123456789101112131415GET /goods/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":200000,"lt":300000&#125;&#125; &#125; &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125;&#125;, &#123; "_score": &#123; "order": "desc" &#125;&#125; ]&#125; 4. 聚合aggregations聚合可以让我们极其方便的实现对数据的统计、分析。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。 4.1 基本概念Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫桶，一个叫度量： 桶（bucket） 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶，例如我们根据国籍对人划分，可以得到中国桶、英国桶，日本桶……或者我们按照年龄段对人进行划分：0~10,10~20,20~30,30~40等。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …… bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量 度量（metrics） 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量 比较常用的一些度量聚合方式： Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 …… 为了测试聚合，我们先批量导入一些数据 创建索引： 12345678910111213141516171819PUT /cars&#123; "settings": &#123; "number_of_shards": 1, "number_of_replicas": 0 &#125;, "mappings": &#123; "transactions": &#123; "properties": &#123; "color": &#123; "type": "keyword" &#125;, "make": &#123; "type": "keyword" &#125; &#125; &#125; &#125;&#125; 注意：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合 导入数据 1234567891011121314151617POST /cars/transactions/_bulk&#123; "index": &#123;&#125;&#125;&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125; 4.2 聚合为桶首先，我们按照 汽车的颜色color来划分桶 1234567891011GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125; &#125; &#125;&#125; size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率 aggs：声明这是一个聚合查询，是aggregations的缩写 popular_colors：给这次聚合起一个名字，任意。 terms：划分桶的方式，这里是根据词条划分 field：划分桶的字段 结果： 1234567891011121314151617181920212223242526272829303132333435&#123; "took": 1, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4 &#125;, &#123; "key": "blue", "doc_count": 2 &#125;, &#123; "key": "green", "doc_count": 2 &#125; ] &#125; &#125;&#125; hits：查询结果为空，因为我们设置了size为0 aggregations：聚合的结果 popular_colors：我们定义的聚合名称 buckets：查找到的桶，每个不同的color字段值都会形成一个桶 key：这个桶对应的color字段的值 doc_count：这个桶中的文档数量 通过聚合的结果我们发现，目前红色的小车比较畅销！ 4.3 桶内度量前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？ 因此，我们需要告诉Elasticsearch使用哪个字段，使用何种度量方式进行运算，这些信息要嵌套在桶内，度量的运算会基于桶内的文档进行 现在，我们为刚刚的聚合结果添加 求价格平均值的度量： 123456789101112131415161718GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合 avg_price：聚合的名称 avg：度量的类型，这里是求平均值 field：度量运算的字段 结果： 12345678910111213141516171819202122232425262728293031... "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;... 可以看到每个桶中都有自己的avg_price字段，这是度量聚合的结果 4.4 桶内嵌套桶刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。 比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照make字段再进行分桶 1234567891011121314151617181920212223GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, "maker":&#123; "terms":&#123; "field":"make" &#125; &#125; &#125; &#125; &#125;&#125; 原来的color桶和avg计算我们不变 maker：在嵌套的aggs下新添一个桶，叫做maker terms：桶的划分类型依然是词条 filed：这里根据make字段进行划分 部分结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374...&#123;"aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "honda", "doc_count": 3 &#125;, &#123; "key": "bmw", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;&#125;... 我们可以看到，新的聚合maker被嵌套在原来每一个color的桶中。 每个颜色下面都根据 make字段进行了分组 我们能读取到的信息： 红色车共有4辆 红色车的平均售价是 $32，500 美元。 其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。 4.5.划分桶的其它方式前面讲了，划分桶的方式有很多，例如： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。 接下来，我们再学习几个比较实用的： 4.5.1.阶梯分桶Histogram 原理： histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。 举例： 比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的： 0，200，400，600，… 上面列出的是每个阶梯的key，也是区间的启点。 如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下： 1bucket_key = Math.floor((value - offset) / interval) * interval + offset value：就是当前数据的值，本例中是450 offset：起始偏移量，默认为0 interval：阶梯间隔，比如200 因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400 操作一下： 比如，我们对汽车的价格进行分组，指定间隔interval为5000： 123456789101112GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "took": 21, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 35000, "doc_count": 0 &#125;, &#123; "key": 40000, "doc_count": 0 &#125;, &#123; "key": 45000, "doc_count": 0 &#125;, &#123; "key": 50000, "doc_count": 0 &#125;, &#123; "key": 55000, "doc_count": 0 &#125;, &#123; "key": 60000, "doc_count": 0 &#125;, &#123; "key": 65000, "doc_count": 0 &#125;, &#123; "key": 70000, "doc_count": 0 &#125;, &#123; "key": 75000, "doc_count": 0 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 你会发现，中间有大量的文档数量为0 的桶，看起来很丑。 我们可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤 示例： 12345678910111213GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000, "min_doc_count": 1 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "took": 15, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 完美，！ 如果你用kibana将结果变为柱形图，会更好看： 4.5.2.范围分桶range范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。 5.Spring Data ElasticsearchElasticsearch提供的Java客户端有一些不太方便的地方： 很多地方需要拼接Json字符串，在java中拼接字符串有多恐怖你应该懂的 需要自己把对象序列化为json存储 查询到结果也需要自己反序列化为对象 因此，我们这里就不讲解原生的Elasticsearch客户端API了。 而是学习Spring提供的套件：Spring Data Elasticsearch。 5.1.简介Spring Data Elasticsearch是Spring Data项目下的一个子模块。 查看 Spring Data的官网：http://projects.spring.io/spring-data/ Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。 它使得使用数据访问技术，关系数据库和非关系数据库，map-reduce框架和基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些令人兴奋的技术项目背后，是由许多公司和开发人员合作开发的。 Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。 包含很多不同数据操作的模块： Spring Data Elasticsearch的页面：https://projects.spring.io/spring-data-elasticsearch/ 特征： 支持Spring的基于@Configuration的java配置方式，或者XML配置方式 提供了用于操作ES的便捷工具类ElasticsearchTemplate。包括实现文档到POJO之间的自动智能映射。 利用Spring的数据转换服务实现的功能丰富的对象映射 基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式 根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询 5.2.创建Demo工程我们使用spring脚手架新建一个demo，学习Elasticsearch pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;elasticsearch&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml文件配置： 12345spring: data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.56.101:9300 5.3.实体类及注解首先我们准备好实体类： 12345678public class Item &#123; Long id; String title; //标题 String category;// 分类 String brand; // 品牌 Double price; // 价格 String images; // 图片地址&#125; 映射 Spring Data通过注解来声明字段的映射属性，有下面的三个注解： @Document 作用在类，标记实体类为文档对象，一般有四个属性 indexName：对应索引库名称 type：对应在索引库中的类型 shards：分片数量，默认5 replicas：副本数量，默认1 @Id 作用在成员变量，标记一个字段作为id主键 @Field 作用在成员变量，标记为文档的字段，并指定字段映射属性： type：字段类型，取值是枚举：FieldType index：是否索引，布尔类型，默认是true store：是否存储，布尔类型，默认是false analyzer：分词器名称：ik_max_word 示例： 1234567891011121314151617181920@Document(indexName = "item",type = "docs", shards = 1, replicas = 0)public class Item &#123; @Id private Long id; @Field(type = FieldType.Text, analyzer = "ik_max_word") private String title; //标题 @Field(type = FieldType.Keyword) private String category;// 分类 @Field(type = FieldType.Keyword) private String brand; // 品牌 @Field(type = FieldType.Double) private Double price; // 价格 @Field(index = false, type = FieldType.Keyword) private String images; // 图片地址&#125; 5.4.Template索引操作5.4.1.创建索引和映射 创建索引 ElasticsearchTemplate中提供了创建索引的API： 可以根据类的信息自动生成，也可以手动指定indexName和Settings 映射 映射相关的API： 可以根据类的字节码信息（注解配置）来生成映射，或者手动编写映射 我们这里采用类的字节码信息创建索引并映射： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastElasticsearchApplication.class)public class IndexTest &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreate()&#123; // 创建索引，会根据Item类的@Document注解信息来创建 elasticsearchTemplate.createIndex(Item.class); // 配置映射，会根据Item类中的id、Field等字段来自动完成映射 elasticsearchTemplate.putMapping(Item.class); &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445GET /item&#123; "item": &#123; "aliases": &#123;&#125;, "mappings": &#123; "docs": &#123; "properties": &#123; "brand": &#123; "type": "keyword" &#125;, "category": &#123; "type": "keyword" &#125;, "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "double" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125;, "settings": &#123; "index": &#123; "refresh_interval": "1s", "number_of_shards": "1", "provided_name": "item", "creation_date": "1525405022589", "store": &#123; "type": "fs" &#125;, "number_of_replicas": "0", "uuid": "4sE9SAw3Sqq1aAPz5F6OEg", "version": &#123; "created": "6020499" &#125; &#125; &#125; &#125;&#125; 5.3.2.删除索引删除索引的API： 可以根据类名或索引名删除。 示例： 1234@Testpublic void deleteIndex() &#123; elasticsearchTemplate.deleteIndex("heima");&#125; 结果： 5.4.Repository文档操作Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。 我们只需要定义接口，然后继承它就OK了。 12public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125; 来看下Repository的继承关系： 我们看到有一个ElasticsearchRepository接口： 5.4.1.新增文档123456789@Autowiredprivate ItemRepository itemRepository;@Testpublic void index() &#123; Item item = new Item(1L, "小米手机7", " 手机", "小米", 3499.00, "http://image.leyou.com/13123.jpg"); itemRepository.save(item);&#125; 去页面查询看看： 1GET /item/_search 结果： 123456789101112131415161718192021222324252627282930&#123; "took": 14, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.4.2.批量新增代码： 12345678@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(2L, "坚果手机R1", " 手机", "锤子", 3699.00, "http://image.leyou.com/123.jpg")); list.add(new Item(3L, "华为META10", " 手机", "华为", 4499.00, "http://image.leyou.com/3.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 再次去页面查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "2", "_score": 1, "_source": &#123; "id": 2, "title": "坚果手机R1", "category": " 手机", "brand": "锤子", "price": 3699, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "3", "_score": 1, "_source": &#123; "id": 3, "title": "华为META10", "category": " 手机", "brand": "华为", "price": 4499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.4.3.修改文档修改和新增是同一个接口，区分的依据就是id，这一点跟我们在页面发起PUT请求是类似的。 5.4.4.基本查询ElasticsearchRepository提供了一些基本的查询方法： 我们来试试查询所有： 123456789101112@Testpublic void testQuery()&#123; Optional&lt;Item&gt; optional = this.itemRepository.findById(1l); System.out.println(optional.get());&#125;@Testpublic void testFind()&#123; // 查询全部，并按照价格降序排序 Iterable&lt;Item&gt; items = this.itemRepository.findAll(Sort.by(Sort.Direction.DESC, "price")); items.forEach(item-&gt; System.out.println(item));&#125; 结果： 5.4.5.自定义方法Spring Data 的另一个强大功能，是根据方法名称自动实现功能。 比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。 当然，方法名称要符合一定的约定： Keyword Sample Elasticsearch Query String And findByNameAndPrice {&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Or findByNameOrPrice {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Is findByName {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Not findByNameNot {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Between findByPriceBetween {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} LessThanEqual findByPriceLessThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} GreaterThanEqual findByPriceGreaterThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Before findByPriceBefore {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} After findByPriceAfter {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Like findByNameLike {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} StartingWith findByNameStartingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} EndingWith findByNameEndingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}} Contains/Containing findByNameContaining {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}} In findByNameIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}} NotIn findByNameNotIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}} Near findByStoreNear Not Supported Yet ! True findByAvailableTrue {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} False findByAvailableFalse {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}} OrderBy findByAvailableTrueOrderByNameDesc {&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} 例如，我们来按照价格区间查询，定义这样的一个方法： 12345678910public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123; /** * 根据价格区间查询 * @param price1 * @param price2 * @return */ List&lt;Item&gt; findByPriceBetween(double price1, double price2);&#125; 然后添加一些测试数据： 1234567891011@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1L, "小米手机7", "手机", "小米", 3299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(2L, "坚果手机R1", "手机", "锤子", 3699.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(3L, "华为META10", "手机", "华为", 4499.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(4L, "小米Mix2S", "手机", "小米", 4299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(5L, "荣耀V10", "手机", "华为", 2799.00, "http://image.leyou.com/13123.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 不需要写实现类，然后我们直接去运行： 1234567@Testpublic void queryByPriceBetween()&#123; List&lt;Item&gt; list = this.itemRepository.findByPriceBetween(2000.00, 3500.00); for (Item item : list) &#123; System.out.println("item = " + item); &#125;&#125; 结果： 虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。 5.5.高级查询5.5.1.基本查询先看看基本玩法 12345678@Testpublic void testQuery()&#123; // 词条查询 MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery("title", "小米"); // 执行查询 Iterable&lt;Item&gt; items = this.itemRepository.search(queryBuilder); items.forEach(System.out::println);&#125; Repository的search方法需要QueryBuilder参数，elasticSearch为我们提供了一个对象QueryBuilders： QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。 结果： elasticsearch提供很多可用的查询方式，但是不够灵活。如果想玩过滤或者聚合查询等就很难了。 5.5.2.自定义查询先来看最基本的match query： 1234567891011121314@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.matchQuery("title", "小米")); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); items.forEach(System.out::println);&#125; NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体 Page&lt;item&gt;：默认是分页查询，因此返回的是一个分页的结果对象，包含属性： totalElements：总条数 totalPages：总页数 Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据 其它属性： 结果： 5.5.4.分页查询利用NativeSearchQueryBuilder可以方便的实现分页： 12345678910111213141516171819202122232425@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 初始化分页参数 int page = 0; int size = 3; // 设置分页参数 queryBuilder.withPageable(PageRequest.of(page, size)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); // 每页大小 System.out.println(items.getSize()); // 当前页 System.out.println(items.getNumber()); items.forEach(System.out::println);&#125; 结果： 可以发现，Elasticsearch中的分页是从第0页开始。 5.5.5.排序排序也通用通过NativeSearchQueryBuilder完成： 12345678910111213141516@Testpublic void testSort()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 排序 queryBuilder.withSort(SortBuilders.fieldSort("price").order(SortOrder.DESC)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); items.forEach(System.out::println);&#125; 结果： 5.6.聚合5.6.1.聚合为桶桶就是分组，比如这里我们按照品牌brand进行分组： 12345678910111213141516171819202122232425@Testpublic void testAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand")); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 System.out.println(bucket.getKeyAsString()); // 3.5、获取桶中的文档数量 System.out.println(bucket.getDocCount()); &#125;&#125; 显示的结果： 关键API： AggregationBuilders：聚合的构建工厂类。所有聚合都由这个类来构建，看看他的静态方法： AggregatedPage：聚合查询的结果类。它是Page&lt;T&gt;的子接口： AggregatedPage在Page功能的基础上，拓展了与聚合相关的功能，它其实就是对聚合结果的一种封装，大家可以对照聚合结果的JSON结构来看。 而返回的结果都是Aggregation类型对象，不过根据字段类型不同，又有不同的子类表示 我们看下页面的查询的JSON结果与Java类的对照关系： 5.6.2.嵌套聚合，求平均值代码： 1234567891011121314151617181920212223242526272829@Testpublic void testSubAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand") .subAggregation(AggregationBuilders.avg("priceAvg").field("price")) // 在品牌聚合桶内进行嵌套聚合，求平均值 ); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 3.5、获取桶中的文档数量 System.out.println(bucket.getKeyAsString() + "，共" + bucket.getDocCount() + "台"); // 3.6.获取子聚合结果： InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get("priceAvg"); System.out.println("平均售价：" + avg.getValue()); &#125;&#125; 结果：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day10-商品管理]]></title>
    <url>%2F2019%2F07%2F06%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday10-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.学习目标 独立实现商品新增后台 独立实现商品编辑后台 独立搭建前台系统页面 1.商品新增当我们点击新增商品按钮： 就会出现一个弹窗： 里面把商品的数据分为了4部分来填写： 基本信息：主要是一些简单的文本数据，包含了SPU和SpuDetail的部分数据，如 商品分类：是SPU中的cid1，cid2，cid3属性 品牌：是spu中的brandId属性 标题：是spu中的title属性 子标题：是spu中的subTitle属性 售后服务：是SpuDetail中的afterService属性 包装列表：是SpuDetail中的packingList属性 商品描述：是SpuDetail中的description属性，数据较多，所以单独放一个页面 规格参数：商品规格信息，对应SpuDetail中的genericSpec属性 SKU属性：spu下的所有Sku信息 对应到页面中的四个stepper-content： 1.1.弹窗事件弹窗是一个独立组件： 并且在Goods组件中已经引用它： 并且在页面中渲染： 在新增商品按钮的点击事件中，改变这个dialog的show属性： 1.2.基本数据我们先来看下基本数据： 1.2.1.商品分类商品分类信息查询我们之前已经做过，所以这里的级联选框已经实现完成： 刷新页面，可以看到请求已经发出： 效果： 1.2.2.品牌选择1.2.2.1页面品牌也是一个下拉选框，不过其选项是不确定的，只有当用户选择了商品分类，才会把这个分类下的所有品牌展示出来。 所以页面编写了watch函数，监控商品分类的变化，每当商品分类值有变化，就会发起请求，查询品牌列表： 选择商品分类后，可以看到请求发起： 接下来，我们只要编写后台接口，根据商品分类id，查询对应品牌即可。 1.2.2.2后台接口页面需要去后台查询品牌信息，我们自然需要提供： 请求方式：GET 请求路径：/brand/cid/{cid} 请求参数：cid 响应数据：品牌集合 BrandController 12345678@GetMapping("cid/&#123;cid&#125;")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandsByCid(@PathVariable("cid")Long cid)&#123; List&lt;Brand&gt; brands = this.brandService.queryBrandsByCid(cid); if (CollectionUtils.isEmpty(brands)) &#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(brands);&#125; BrandService 1234public List&lt;Brand&gt; queryBrandsByCid(Long cid) &#123; return this.brandMapper.selectBrandByCid(cid);&#125; BrandMapper 根据分类查询品牌有中间表，需要自己编写Sql： 12@Select("SELECT b.* from tb_brand b INNER JOIN tb_category_brand cb on b.id=cb.brand_id where cb.category_id=#&#123;cid&#125;")List&lt;Brand&gt; selectBrandByCid(Long cid); 效果： 1.2.3.其它文本框剩余的几个属性：标题、子标题等都是普通文本框，我们直接填写即可，没有需要特别注意的。 1.3.商品描述商品描述信息比较复杂，而且图文并茂，甚至包括视频。 这样的内容，一般都会使用富文本编辑器。 1.3.1.什么是富文本编辑器百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor 1.3.2.Vue-Quill-EditorGitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 1.3.3.使用指南使用非常简单：已经在项目中集成。以下步骤不需操作，仅供参考 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局引入： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = &#123;&#125;; /* &#123; default global options &#125; */Vue.use(VueQuillEditor, options); // options可选 局部引入： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import &#123;quillEditor&#125; from 'vue-quill-editor'var vm = new Vue(&#123; components:&#123; quillEditor &#125;&#125;) 我们这里采用局部引用： 第三步：页面使用： 1&lt;quill-editor v-model="goods.spuDetail.description" :options="editorOption"/&gt; 1.3.4.自定义的富文本编辑器不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 123&lt;v-stepper-content step="2"&gt; &lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 1.3.5.效果 1.4.商品规格参数规格参数的查询我们之前也已经编写过接口，因为商品规格参数也是与商品分类绑定，所以需要在商品分类变化后去查询，我们也是通过watch监控来实现： 可以看到这里是根据商品分类id查询规格参数：SpecParam。我们之前写过一个根据gid（分组id）来查询规格参数的接口，我们接下来完成根据分类id查询规格参数。 改造查询规格参数接口 我们在原来的根据 gid（规格组id)查询规格参数的接口上，添加一个参数：cid，即商品分类id。 等一下， 考虑到以后可能还会根据是否搜索、是否为通用属性等条件过滤，我们多添加几个过滤条件： 123456789101112131415@GetMapping("params")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParams( @RequestParam(value = "gid", required = false)Long gid, @RequestParam(value = "cid", required = false)Long cid, @RequestParam(value = "generic", required = false)Boolean generic, @RequestParam(value = "searching", required = false)Boolean searching)&#123; List&lt;SpecParam&gt; params = this.specificationService.queryParams(gid, cid, generic, searching); if (CollectionUtils.isEmpty(params))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(params);&#125; 改造SpecificationService： 12345678910111213/** * 根据gid查询规格参数 * @param gid * @return */public List&lt;SpecParam&gt; queryParams(Long gid, Long cid, Boolean generic, Boolean searching) &#123; SpecParam record = new SpecParam(); record.setGroupId(gid); record.setCid(cid); record.setGeneric(generic); record.setSearching(searching); return this.specParamMapper.select(record);&#125; 如果param中有属性为null，则不会把属性作为查询条件，因此该方法具备通用性，即可根据gid查询，也可根据cid查询。 测试： 刷新页面测试： 1.5.SKU信息Sku属性是SPU下的每个商品的不同特征，如图： 当我们填写一些属性后，会在页面下方生成一个sku表格，大家可以计算下会生成多少个不同属性的Sku呢？ 当你选择了上图中的这些选项时： 颜色共2种：迷夜黑，勃艮第红，绚丽蓝 内存共2种：4GB，6GB 机身存储1种：64GB，128GB 此时会产生多少种SKU呢？ 应该是 3 2 2 = 12种，这其实就是在求笛卡尔积。 我们会在页面下方生成一个sku的表格： 1.6.页面表单提交在sku列表的下方，有一个提交按钮： 并且绑定了点击事件： 点击后会组织数据并向后台提交： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465submit() &#123; // 表单校验。 if(!this.$refs.basic.validate)&#123; this.$message.error("请先完成表单内容！"); &#125; // 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中 const &#123; categories: [&#123; id: cid1 &#125;, &#123; id: cid2 &#125;, &#123; id: cid3 &#125;], ...goodsParams &#125; = this.goods; // 处理规格参数 const specs = &#123;&#125;; this.specs.forEach((&#123; id,v &#125;) =&gt; &#123; specs[id] = v; &#125;); // 处理特有规格参数模板 const specTemplate = &#123;&#125;; this.specialSpecs.forEach((&#123; id, options &#125;) =&gt; &#123; specTemplate[id] = options; &#125;); // 处理sku const skus = this.skus .filter(s =&gt; s.enable) .map((&#123; price, stock, enable, images, indexes, ...rest &#125;) =&gt; &#123; // 标题，在spu的title基础上，拼接特有规格属性值 const title = goodsParams.title + " " + Object.values(rest).map(v =&gt; v.v).join(" "); const obj = &#123;&#125;; Object.values(rest).forEach(v =&gt; &#123; obj[v.id] = v.v; &#125;); return &#123; price: this.$format(price), // 价格需要格式化 stock, indexes, enable, title, // 基本属性 images: images ? images.join(",") : '', // 图片 ownSpec: JSON.stringify(obj) // 特有规格参数 &#125;; &#125;); Object.assign(goodsParams, &#123; cid1, cid2, cid3, // 商品分类 skus // sku列表 &#125;); goodsParams.spuDetail.genericSpec = JSON.stringify(specs); goodsParams.spuDetail.specialSpec = JSON.stringify(specTemplate); // 提交到后台 this.$http(&#123; method: this.isEdit ? "put" : "post", url: "/item/goods", data: goodsParams &#125;) .then(() =&gt; &#123; // 成功，关闭窗口 this.$emit("close"); // 提示成功 this.$message.success("保存成功了"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;);&#125; 点击提交，查看控制台提交的数据格式： 整体是一个json格式数据，包含Spu表所有数据： brandId：品牌id cid1、cid2、cid3：商品分类id subTitle：副标题 title：标题 spuDetail：是一个json对象，代表商品详情表数据 afterService：售后服务 description：商品描述 packingList：包装列表 specialSpec：sku规格属性模板 genericSpec：通用规格参数 skus：spu下的所有sku数组，元素是每个sku对象： title：标题 images：图片 price：价格 stock：库存 ownSpec：特有规格参数 indexes：特有规格参数的下标 1.7.后台实现1.7.1.实体类SPU和SpuDetail实体类已经添加过，添加Sku和Stock对象： Sku 1234567891011121314151617@Table(name = "tb_sku")public class Sku &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long spuId; private String title; private String images; private Long price; private String ownSpec;// 商品特殊规格的键值对 private String indexes;// 商品特殊规格的下标 private Boolean enable;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 @Transient private Integer stock;// 库存&#125; 注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。 Stock 12345678@Table(name = "tb_stock")public class Stock &#123; @Id private Long skuId; private Integer seckillStock;// 秒杀可用库存 private Integer seckillTotal;// 已秒杀数量 private Integer stock;// 正常库存&#125; 1.7.2.GoodsController结合浏览器页面控制台，可以发现： 请求方式：POST 请求路径：/goods 请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个SpuBo对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段： 1234567public class SpuBo extends Spu &#123; String cname;// 商品分类名称 String bname;// 品牌名称 SpuDetail spuDetail;// 商品详情 List&lt;Sku&gt; skus;// sku列表&#125; 返回类型：无 在GoodsController中添加新增商品的代码： 12345@PostMapping("goods")public ResponseEntity&lt;Void&gt; saveGoods(@RequestBody SpuBo spuBo)&#123; this.goodsService.saveGoods(spuBo); return ResponseEntity.status(HttpStatus.CREATED).build();&#125; 注意：通过@RequestBody注解来接收Json请求 1.7.3.GoodsService这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存 1234567891011121314151617181920212223242526272829303132333435363738/** * 新增商品 * @param spuBo */@Transactionalpublic void saveGoods(SpuBo spuBo) &#123; // 新增spu // 设置默认字段 spuBo.setId(null); spuBo.setSaleable(true); spuBo.setValid(true); spuBo.setCreateTime(new Date()); spuBo.setLastUpdateTime(spuBo.getCreateTime()); this.spuMapper.insertSelective(spuBo); // 新增spuDetail SpuDetail spuDetail = spuBo.getSpuDetail(); spuDetail.setSpuId(spuBo.getId()); this.spuDetailMapper.insertSelective(spuDetail); saveSkuAndStock(spuBo);&#125;private void saveSkuAndStock(SpuBo spuBo) &#123; spuBo.getSkus().forEach(sku -&gt; &#123; // 新增sku sku.setSpuId(spuBo.getId()); sku.setCreateTime(new Date()); sku.setLastUpdateTime(sku.getCreateTime()); this.skuMapper.insertSelective(sku); // 新增库存 Stock stock = new Stock(); stock.setSkuId(sku.getId()); stock.setStock(sku.getStock()); this.stockMapper.insertSelective(stock); &#125;);&#125; 1.7.4.Mapper都是通用Mapper，略 目录结构： 2.商品修改2.1.编辑按钮点击事件在商品详情页，每一个商品后面，都会有一个编辑按钮： 点击这个按钮，就会打开一个商品编辑窗口，我们看下它所绑定的点击事件：（在item/Goods.vue） 对应的方法： 可以看到这里发起了两个请求，在查询商品详情和sku信息。 因为在商品列表页面，只有spu的基本信息：id、标题、品牌、商品分类等。比较复杂的商品详情（spuDetail)和sku信息都没有，编辑页面要回显数据，就需要查询这些内容。 因此，接下来我们就编写后台接口，提供查询服务接口。 2.2.查询SpuDetail接口 GoodsController 需要分析的内容： 请求方式：GET 请求路径：/spu/detail/{id} 请求参数：id，应该是spu的id 返回结果：SpuDetail对象 12345678@GetMapping("spu/detail/&#123;spuId&#125;")public ResponseEntity&lt;SpuDetail&gt; querySpuDetailBySpuId(@PathVariable("spuId")Long spuId)&#123; SpuDetail spuDetail = this.goodsService.querySpuDetailBySpuId(spuId); if (spuDetail == null) &#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(spuDetail);&#125; GoodsService 123456789/** * 根据spuId查询spuDetail * @param spuId * @return */public SpuDetail querySpuDetailBySpuId(Long spuId) &#123; return this.spuDetailMapper.selectByPrimaryKey(spuId);&#125; 测试 2.3.查询sku 分析 请求方式：Get 请求路径：/sku/list 请求参数：id，应该是spu的id 返回结果：sku的集合 GoodsController 12345678@GetMapping("sku/list")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkusBySpuId(@RequestParam("id")Long spuId)&#123; List&lt;Sku&gt; skus = this.goodsService.querySkusBySpuId(spuId); if (CollectionUtils.isEmpty(skus)) &#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(skus);&#125; GoodsService 需要注意的是，为了页面回显方便，我们一并把sku的库存stock也查询出来 123456789101112131415/** * 根据spuId查询sku的集合 * @param spuId * @return */public List&lt;Sku&gt; querySkusBySpuId(Long spuId) &#123; Sku sku = new Sku(); sku.setSpuId(spuId); List&lt;Sku&gt; skus = this.skuMapper.select(sku); skus.forEach(s -&gt; &#123; Stock stock = this.stockMapper.selectByPrimaryKey(s.getId()); s.setStock(stock.getStock()); &#125;); return skus;&#125; 测试： 2.4.页面回显随便点击一个编辑按钮，发现数据回显完成： 2.5.页面提交这里的保存按钮与新增其实是同一个，因此提交的逻辑也是一样的，这里不再赘述。 随便修改点数据，然后点击保存，可以看到浏览器已经发出请求： 2.6.后台实现接下来，我们编写后台，实现修改商品接口。 2.6.1.GoodsController 请求方式：PUT 请求路径：/ 请求参数：Spu对象 返回结果：无 12345@PutMapping("goods")public ResponseEntity&lt;Void&gt; updateGoods(@RequestBody SpuBo spuBo)&#123; this.goodsService.updateGoods(spuBo); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 2.6.2.GoodsServicespu数据可以修改，但是SKU数据无法修改，因为有可能之前存在的SKU现在已经不存在了，或者以前的sku属性都不存在了。比如以前内存有4G，现在没了。 因此这里直接删除以前的SKU，然后新增即可。 代码： 12345678910111213141516171819202122232425262728293031@Transactionalpublic void update(SpuBo spu) &#123; // 查询以前sku List&lt;Sku&gt; skus = this.querySkuBySpuId(spu.getId()); // 如果以前存在，则删除 if(!CollectionUtils.isEmpty(skus)) &#123; List&lt;Long&gt; ids = skus.stream().map(s -&gt; s.getId()).collect(Collectors.toList()); // 删除以前库存 Example example = new Example(Stock.class); example.createCriteria().andIn("skuId", ids); this.stockMapper.deleteByExample(example); // 删除以前的sku Sku record = new Sku(); record.setSpuId(spu.getId()); this.skuMapper.delete(record); &#125; // 新增sku和库存 saveSkuAndStock(spuBo); // 更新spu spu.setLastUpdateTime(new Date()); spu.setCreateTime(null); spu.setValid(null); spu.setSaleable(null); this.spuMapper.updateByPrimaryKeySelective(spu); // 更新spu详情 this.spuDetailMapper.updateByPrimaryKeySelective(spu.getSpuDetail());&#125; 2.6.3.mapper与以前一样。 2.7.其它商品的删除、上下架大家自行实现。 3.搭建前台系统后台系统的内容暂时告一段落，有了商品，接下来我们就要在页面展示商品，给用户提供浏览和购买的入口，那就是我们的门户系统。 门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。 依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。 3.1.静态资源webpack打包多页应用配置比较繁琐，项目结构也相对复杂。这里为了简化开发（毕竟我们不是专业的前端人员），我们不再使用webpack，而是直接编写原生的静态HTML。 3.1.1.创建工程创建一个新的工程： 3.1.2.导入静态资源将课前资料中的leyou-portal解压，并复制到这个项目下 解压缩： 项目结构： 3.2.live-server没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。 所以，这里我们使用另外一种热部署方式：live-server， 3.2.1.简介地址；https://www.npmjs.com/package/live-server 这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。 3.2.2.安装和运行参数安装，使用npm命令即可，这里建议全局安装，以后任意位置可用 1npm install -g live-server 运行时，直接输入命令： 1live-server 另外，你可以在运行命令后，跟上一些参数以配置： --port=NUMBER - 选择要使用的端口，默认值：PORT env var或8080 --host=ADDRESS - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”） --no-browser - 禁止自动Web浏览器启动 --browser=BROWSER - 指定使用浏览器而不是系统默认值 --quiet | -q - 禁止记录 --verbose | -V - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等） --open=PATH - 启动浏览器到PATH而不是服务器root --watch=PATH - 用逗号分隔的路径来专门监视变化（默认值：观看所有内容） --ignore=PATH- 要忽略的逗号分隔的路径字符串（anymatch -compatible definition） --ignorePattern=RGXP-文件的正则表达式忽略（即.*\.jade）（不推荐使用赞成--ignore） --middleware=PATH - 导出要添加的中间件功能的.js文件的路径; 可以是没有路径的名称，也可以是引用middleware文件夹中捆绑的中间件的扩展名 --entry-file=PATH - 提供此文件（服务器根目录）代替丢失的文件（对单页应用程序有用） --mount=ROUTE:PATH - 在定义的路线下提供路径内容（可能有多个定义） --spa - 将请求从/ abc转换为/＃/ abc（方便单页应用） --wait=MILLISECONDS - （默认100ms）等待所有更改，然后重新加载 --htpasswd=PATH - 启用期待位于PATH的htpasswd文件的http-auth --cors - 为任何来源启用CORS（反映请求源，支持凭证的请求） --https=PATH - 到HTTPS配置模块的路径 --proxy=ROUTE:URL - 代理ROUTE到URL的所有请求 --help | -h - 显示简洁的使用提示并退出 --version | -v - 显示版本并退出 3.2.3.测试我们进入leyou-portal目录，输入命令： 1live-server --port=9002 3.3.域名访问现在我们访问只能通过：http://127.0.0.1:9002 我们希望用域名访问：http://www.leyou.com 第一步，修改hosts文件，添加一行配置： 1127.0.0.1 www.leyou.com 第二步，修改nginx配置，将www.leyou.com反向代理到127.0.0.1:9002 1234567891011121314server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重新加载nginx配置：nginx.exe -s reload 3.4.common.js为了方便后续的开发，我们在前台系统中定义了一些工具，放在了common.js中： 部分代码截图： 首先对axios进行了一些全局配置，请求超时时间，请求的基础路径，是否允许跨域操作cookie等 定义了对象 ly ，也叫leyou，包含了下面的属性： getUrlParam(key)：获取url路径中的参数 http：axios对象的别名。以后发起ajax请求，可以用ly.http.get() store：localstorage便捷操作，后面用到再详细说明 formatPrice：格式化价格，如果传入的是字符串，则扩大100被并转为数字，如果传入是数字，则缩小100倍并转为字符串 formatDate(val, pattern)：对日期对象val按照指定的pattern模板进行格式化 stringify：将对象转为参数字符串 parse：将参数字符串变为js对象]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day09-商品规格管理]]></title>
    <url>%2F2019%2F07%2F04%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday09-%E5%95%86%E5%93%81%E8%A7%84%E6%A0%BC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解商品规格数据结构设计思路 实现商品规格查询 了解SPU和SKU数据结构设计思路 实现商品查询 了解商品新增的页面实现 独立编写商品新增后台功能 1.商品规格数据结构乐优商城是一个全品类的电商网站，因此商品的种类繁多，每一件商品，其属性又有差别。为了更准确描述商品及细分差别，抽象出两个概念：SPU和SKU，了解一下： 1.1.SPU和SKUSPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集 SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品 以图为例来看： 本页的 华为Mate10 就是一个商品集（SPU） 因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU） 可以看出： SPU是一个抽象的商品集概念，为了方便后台的管理。 SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU 1.2.数据库设计分析1.2.1.思考并发现问题弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。 首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？ 123456789id:主键title：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌 似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？ 不同商品的规格不一定相同，数据库中要如何保存？ 再看下SKU，大家觉得应该有什么字段？ 12345678id：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？ 碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？ 其实颜色、内存、硬盘属性都是规格参数中的字段。所以，要解决这个问题，首先要能清楚规格参数。 1.2.2.分析规格参数仔细查看每一种商品的规格你会发现： 虽然商品规格千变万化，但是同一类商品（如手机）的规格是统一的，有图为证： 华为的规格： 三星的规格： 1.2.3.SKU的特有属性SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。 不同种类的商品，一个手机，一个衣服，其SKU属性不相同。 同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。 这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，SKU的特有属性是商品规格参数的一部分： 也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分： spu下所有sku共享的规格属性（称为全局属性） 每个sku不同的规格属性（称为特有属性） 1.2.4.搜索属性打开一个搜索页，我们来看看过滤的条件： 你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到： 也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。要注意的是，无论是SPU的全局属性，还是SKU的特有属性，都有可能作为搜索过滤条件的，并不冲突，而是有一个交集： 1.3.规格参数表1.3.1.表结构我们看下规格参数的格式： 可以看到规格参数是分组的，每一组都有多个参数键值对。不过对于规格参数的模板而言，其值现在是不确定的，不同的商品值肯定不同，模板中只要保存组信息、组内参数信息即可。 因此我们设计了两张表： tb_spec_group：组，与商品分类关联 tb_spec_param：参数名，与组关联，一对多 1.3.2.规格组规格参数分组表：tb_spec_group 1234567CREATE TABLE `tb_spec_group` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id，一个分类下有多个规格组&apos;, `name` varchar(50) NOT NULL COMMENT &apos;规格组的名称&apos;, PRIMARY KEY (`id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数的分组表，每个商品分类下有多个规格参数组&apos;; 规格组有3个字段： id：主键 cid：商品分类id，一个分类下有多个模板 name：该规格组的名称。 1.3.2.规格参数规格参数表：tb_spec_param 1234567891011121314CREATE TABLE `tb_spec_param` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id&apos;, `group_id` bigint(20) NOT NULL, `name` varchar(255) NOT NULL COMMENT &apos;参数名&apos;, `numeric` tinyint(1) NOT NULL COMMENT &apos;是否是数字类型参数，true或false&apos;, `unit` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;数字类型参数的单位，非数字类型可以为空&apos;, `generic` tinyint(1) NOT NULL COMMENT &apos;是否是sku通用属性，true或false&apos;, `searching` tinyint(1) NOT NULL COMMENT &apos;是否用于搜索过滤，true或false&apos;, `segments` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;数值类型参数，如果需要搜索，则添加分段间隔值，如CPU频率间隔：0.5-1.0&apos;, PRIMARY KEY (`id`), KEY `key_group` (`group_id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数组下的参数名&apos;; 按道理来说，我们的规格参数就只需要记录参数名、组id、商品分类id即可。但是这里却多出了很多字段，为什么？ 还记得我们之前的分析吧，规格参数中有一部分是 SKU的通用属性，一部分是SKU的特有属性，而且其中会有一些将来用作搜索过滤，这些信息都需要标记出来。 通用属性 用一个布尔类型字段来标记是否为通用： generic来标记是否为通用属性： true：代表通用属性 false：代表sku特有属性 搜索过滤 与搜索相关的有两个字段： searching：标记是否用作过滤 true：用于过滤搜索 false：不用于过滤 segments：某些数值类型的参数，在搜索时需要按区间划分，这里提前确定好划分区间 比如电池容量，0~2000mAh，2000mAh~3000mAh，3000mAh~4000mAh 数值类型 某些规格参数可能为数值类型，这样的数据才需要划分区间，我们有两个字段来描述： numberic：是否为数值类型 true：数值类型 false：不是数值类型 unit：参数的单位 2.商品规格参数管理2.1.页面布局2.1.1.整体布局打开规格参数页面，看到如下内容： 商品分类树我们之前已经做过，所以这里可以直接展示出来。 因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现： 页面结构： 这里使用了v-layout来完成页面布局，并且添加了row属性，代表接下来的内容是行布局（左右）。 可以看出页面分成2个部分： &lt;v-flex xs3&gt;：左侧，内部又分上下两部分：商品分类树及标题 v-card-title：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板 v-tree：这里用到的是我们之前讲过的树组件，展示商品分类树， &lt;v-flex xs9 class=&quot;px-1&quot;&gt;：右侧：内部是规格参数展示 2.1.2.右侧规格当我们点击一个分类时，最终要达到的效果： 可以看到右侧分为上下两部分： 上部：面包屑，显示当前选中的分类 下部：table，显示规格参数信息 页面实现： 可以看到右侧并不是我们熟悉的 v-data-table，而是一个spec-group组件（规格组）和spec-param组件（规格参数），这是我们定义的独立组件： 在SpecGroup中定义了表格： 2.2.规格组的查询2.2.1.树节点的点击事件当我们点击树节点时，要将v-dialog打开，因此必须绑定一个点击事件：（Specification.vue） 我们来看下handleClick方法：（Specification.vue） 点击事件发生时，发生了两件事： 记录当前选中的节点，选中的就是商品分类 showGroup被置为true，则规格组就会显示了。 同时，我们把被选中的节点（商品分类）的id传递给了SpecGroup组件：（Specification.vue） 2.2.2.页面查询规格组来看下SpecGroup.vue中的实现： 我们查看页面控制台，可以看到请求已经发出： 2.2.3.后端代码 实体类 在leyou-item-interface中添加实体类： 内容： 12345678910111213141516@Table(name = "tb_spec_group")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; @Transient private List&lt;SpecParam&gt; params; // getter和setter省略&#125; 1234567891011121314151617@Table(name = "tb_spec_param")public class SpecParam &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private Long groupId; private String name; @Column(name = "`numeric`") private Boolean numeric; private String unit; private Boolean generic; private Boolean searching; private String segments; // getter和setter ...&#125; 在leyou-item-service中编写业务： mapper 12public interface SpecGroupMapper extends Mapper&lt;SpecGroup&gt; &#123;&#125; controller 先分析下需要的东西，在页面的ajax请求中可以看出： 请求方式：get 请求路径：/spec/groups/{cid} ，这里通过路径占位符传递商品分类的id 请求参数：商品分类id 返回结果：页面是直接把resp.data赋值给了groups： 那么我们返回的应该是规格组SpecGroup的集合 代码： 123456789101112131415161718192021@RestController@RequestMapping("spec")public class SpecificationController &#123; @Autowired private SpecificationService specificationService; /** * 根据分类id查询分组 * @param cid * @return */ @GetMapping("groups/&#123;cid&#125;") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; queryGroupsByCid(@PathVariable("cid")Long cid)&#123; List&lt;SpecGroup&gt; groups = this.specificationService.queryGroupsByCid(cid); if (CollectionUtils.isEmpty(groups))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(groups); &#125;&#125; service 1234567891011121314151617@Servicepublic class SpecificationService &#123; @Autowired private SpecGroupMapper groupMapper; /** * 根据分类id查询分组 * @param cid * @return */ public List&lt;SpecGroup&gt; queryGroupsByCid(Long cid) &#123; SpecGroup specGroup = new SpecGroup(); specGroup.setCid(cid); return this.groupMapper.select(specGroup); &#125;&#125; 页面访问测试： 目前，我们数据库只为手机分类（76）提供了规格组： 我们访问：http://api.leyou.com/api/item/spec/groups/76 然后在后台系统中测试： 2.3.规格参数查询2.3.1.表格切换当我们点击规格组，会切换到规格参数显示，肯定是在规格组中绑定了点击事件： 我们看下事件处理： 可以看到这里是使用了父子通信，子组件触发了select事件： 再来看下父组件的事件绑定： 事件处理： 这里我们记录了选中的分组，并且把标记设置为false，这样规格组就不显示了，而是显示：SpecParam 并且，我们把group也传递到spec-param组件： 2.3.2.页面查询规格参数我们来看SpecParam.vue的实现： 查看页面控制台，发现请求已经发出： 报404，因为我们还没有实现后台逻辑，接下来就去实现。 2.3.3.后台实现 SpecificationController 分析： 请求方式：GET 请求路径：/spec/params 请求参数：gid，分组id 返回结果：该分组下的规格参数集合List&lt;SpecParam&gt; 代码： 12345678910111213/** * 根据条件查询规格参数 * @param gid * @return */@GetMapping("params")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParams(@RequestParam("gid")Long gid)&#123; List&lt;SpecParam&gt; params = this.specificationService.queryParams(gid); if (CollectionUtils.isEmpty(params))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(params);&#125; SpecificationService 12345678910111213@Autowiredprivate SpecParamMapper paramMapper;/** * 根据条件查询规格参数 * @param gid * @return */public List&lt;SpecParam&gt; queryParams(Long gid) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); return this.paramMapper.select(param);&#125; SpecParamMapper 12public interface SpecParamMapper extends Mapper&lt;SpecParam&gt; &#123;&#125; 测试： 2.4.增、删、改（作业）增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。 3.SPU和SKU数据结构规格确定以后，就可以添加商品了,先看下数据库表 3.1.SPU表SPU表： 1234567891011121314CREATE TABLE `tb_spu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;标题&apos;, `sub_title` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;, `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;, `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;, `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;, `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;, `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT=&apos;spu表，该表描述的是一个抽象的商品，比如 iphone8&apos;; 与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。 我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail 123456789CREATE TABLE `tb_spu_detail` ( `spu_id` bigint(20) NOT NULL, `description` text COMMENT &apos;商品描述信息&apos;, `generic_spec` varchar(10000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;通用规格参数数据&apos;, `special_spec` varchar(1000) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;, `packing_list` varchar(3000) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;, `after_service` varchar(3000) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;, PRIMARY KEY (`spu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。 需要注意的是这两个字段：generic_spec和special_spec。 前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数信息，因此我们计划是这样： SPUDetail中保存通用的规格参数信息。 SKU中保存特有规格参数。 来看下我们的表如何存储这些信息。 3.1.1.generic_spec字段首先是generic_spec，其中保存通用规格参数信息的值，这里为了方便查询，使用了json格式： 整体来看： json结构，其中都是键值对： key：对应的规格参数的spec_param的id value：对应规格参数的值 3.1.2.special_spec字段我们说spu中只保存通用规格参数，那么为什么有多出了一个special_spec字段呢？ 以手机为例，品牌、操作系统等肯定是全局通用属性，内存、颜色等肯定是特有属性。 当你确定了一个SPU，比如小米的：红米4X 全局属性值都是固定的了： 12品牌：小米型号：红米4X 特有属性举例： 123颜色：[香槟金, 樱花粉, 磨砂黑]内存：[2G, 3G]机身存储：[16GB, 32GB] 颜色、内存、机身存储，作为SKU特有属性，key虽然一样，但是SPU下的每一个SKU，其值都不一样，所以值会有很多，形成数组。 我们在SPU中，会把特有属性的所有值都记录下来，形成一个数组： 里面又有哪些内容呢？ 来看数据格式： 也是json结构： key：规格参数id value：spu属性的数组 那么问题来：特有规格参数应该在sku中记录才对，为什么在spu中也要记录一份？ 因为我们有时候需要把所有规格参数都查询出来，而不是只查询1个sku的属性。比如，商品详情页展示可选的规格参数时： 刚好符合我们的结构，这样页面渲染就非常方便了。 3.2.SKU表1234567891011121314CREATE TABLE `tb_sku` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;, `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL COMMENT &apos;商品标题&apos;, `images` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;, `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;, `indexes` varchar(100) COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合&apos;, `own_spec` varchar(1000) COMMENT &apos;sku的特有规格参数，json格式&apos;, `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;, `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`), KEY `key_spu_id` (`spu_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8&apos;; 还有一张表，代表库存： 1234567CREATE TABLE `tb_stock` ( `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;, `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;, `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;, `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;, PRIMARY KEY (`sku_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos;; 问题：为什么要将库存独立一张表？ 因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。 特别需要注意的是sku表中的indexes字段和own_spec字段。sku中应该保存特有规格参数的值，就在这两个字段中。 3.2.1.indexes字段在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下： 123456789101112131415&#123; "4": [ "香槟金", "樱花粉", "磨砂黑" ], "12": [ "2GB", "3GB" ], "13": [ "16GB", "32GB" ]&#125; 这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。 比如： 红米4X，香槟金，2GB内存，16GB存储 红米4X，磨砂黑，2GB内存，32GB存储 你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样： 红米4X，0,0,0 红米4X，2,0,1 既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。 这个设计在商品详情页会特别有用： 当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。 3.2.2.own_spec字段看结构： 1&#123;"4":"香槟金","12":"2GB","13":"16GB"&#125; 保存的是特有属性的键值对。 SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的值。 3.3.导入图片信息现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机： 首先，把课前资料提供的数据上传到虚拟机下：/leyou/static目录：在leyou下创建static目录 然后，使用命令解压缩： 1unzip images.zip 修改Nginx配置，使nginx反向代理这些图片地址： 1vim /opt/nginx/config/nginx.conf 修改成如下配置： 12345678910111213141516171819server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 将其它图片代理指向本地的/leyou/static目录 location / &#123; root /leyou/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 不要忘记重新加载nginx配置 1nginx -s reload 4.商品查询4.1.效果预览接下来，我们实现商品管理的页面，先看下我们要实现的效果： 可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？ 4.2.页面请求先看整体页面结构（Goods.vue）： 并且在Vue实例挂载后就会发起查询(mounted调用getDataFromServer方法初始化数据)： 我们刷新页面，可以看到浏览器发起已经发起了查询商品数据的请求： 因此接下来，我们编写接口即可。 4.3.后台提供接口页面已经准备好，接下来在后台提供分页查询SPU的功能。 4.3.1.实体类在leyou-item-interface工程中添加实体类： SPU 1234567891011121314151617@Table(name = "tb_spu")public class Spu &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 // 省略getter和setter&#125; SPU详情 1234567891011@Table(name="tb_spu_detail")public class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specialSpec;// 商品特殊规格的名称及可选值模板 private String genericSpec;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务 // 省略getter和setter&#125; 4.4.2.mapper12public interface SpuMapper extends Mapper&lt;Spu&gt; &#123;&#125; 4.3.3.controller先分析： 请求方式：GET 请求路径：/spu/page 请求参数： page：当前页 rows：每页大小 key：过滤条件 saleable：上架或下架 返回结果：商品SPU的分页信息。 要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？ 我们可以新建一个类，继承SPU，并且拓展cname和bname属性，写到leyou-item-interface 12345678public class SpuBo extends Spu &#123; String cname;// 商品分类名称 String bname;// 品牌名称 // 略 。。&#125; 编写controller代码： 我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样 123456789101112131415161718192021@Controllerpublic class GoodsController &#123; @Autowired private GoodsService goodsService; @GetMapping("spu/page") public ResponseEntity&lt;PageResult&lt;SpuBo&gt;&gt; querySpuBoByPage( @RequestParam(value = "key", required = false)String key, @RequestParam(value = "saleable", required = false)Boolean saleable, @RequestParam(value = "page", defaultValue = "1")Integer page, @RequestParam(value = "rows", defaultValue = "5")Integer rows )&#123; PageResult&lt;SpuBo&gt; pageResult = this.goodsService.querySpuBoByPage(key, saleable, page, rows); if(CollectionUtils.isEmpty(pageResult.getItems()))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(pageResult); &#125;&#125; 4.4.4.service所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class GoodsService &#123; @Autowired private SpuMapper spuMapper; @Autowired private CategoryService categoryService; @Autowired private BrandMapper brandMapper; public PageResult&lt;SpuBo&gt; querySpuBoByPage(String key, Boolean saleable, Integer page, Integer rows) &#123; Example example = new Example(Spu.class); Example.Criteria criteria = example.createCriteria(); // 搜索条件 if (StringUtils.isNotBlank(key)) &#123; criteria.andLike("title", "%" + key + "%"); &#125; if (saleable != null) &#123; criteria.andEqualTo("saleable", saleable); &#125; // 分页条件 PageHelper.startPage(page, rows); // 执行查询 List&lt;Spu&gt; spus = this.spuMapper.selectByExample(example); PageInfo&lt;Spu&gt; pageInfo = new PageInfo&lt;&gt;(spus); List&lt;SpuBo&gt; spuBos = new ArrayList&lt;&gt;(); spus.forEach(spu-&gt;&#123; SpuBo spuBo = new SpuBo(); // copy共同属性的值到新的对象 BeanUtils.copyProperties(spu, spuBo); // 查询分类名称 List&lt;String&gt; names = this.categoryService.queryNamesByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); spuBo.setCname(StringUtils.join(names, "/")); // 查询品牌的名称 spuBo.setBname(this.brandMapper.selectByPrimaryKey(spu.getBrandId()).getName()); spuBos.add(spuBo); &#125;); return new PageResult&lt;&gt;(pageInfo.getTotal(), spuBos); &#125;&#125; 4.4.5.Category中拓展查询名称的功能页面需要商品的分类名称需要在这里查询，因此要额外提供查询分类名称的功能， 在CategoryService中添加功能： 123456789public List&lt;String&gt; queryNamesByIds(List&lt;Long&gt; ids) &#123; List&lt;Category&gt; list = this.categoryMapper.selectByIdList(ids); List&lt;String&gt; names = new ArrayList&lt;&gt;(); for (Category category : list) &#123; names.add(category.getName()); &#125; return names; // return list.stream().map(category -&gt; category.getName()).collect(Collectors.toList());&#125; mapper的selectByIdList方法是来自于通用mapper。不过需要我们在mapper上继承一个通用mapper接口： 123public interface CategoryMapper extends Mapper&lt;Category&gt;, SelectByIdListMapper&lt;Category, Long&gt; &#123; &#125; 4.5.测试刷新页面，查看效果： 基本与预览的效果一致，OK！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day08-品牌管理]]></title>
    <url>%2F2019%2F07%2F03%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday08-%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.学习目标 独立实现品牌新增 实现图片上传 了解FastDFS的安装 使用FastDFS客户端实现上传 1.品牌的新增昨天我们完成了品牌的查询，接下来就是新增功能。点击新增品牌按钮 Brand.vue页面有一个提交按钮： 点击触发addBrand方法： 把数据模型之的show置为true，而页面中有一个弹窗与show绑定： 弹窗中有一个表单子组件，并且是一个局部子组件，有页面可以找到该组件： 1.1.页面实现1.1.1.重置表单重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。 我们可以通过$refs内置对象来获取表单组件。 首先，在表单上定义ref属性： 然后，在页面查看this.$refs属性： 1234reset()&#123; // 重置表单 console.log(this);&#125; 查看如下： 看到this.$refs中只有一个属性，就是myBrandForm 我们在clear中来获取表单对象并调用reset方法： 要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。 1.1.2.表单校验1.1.2.1.校验规则Vuetify的表单校验，是通过rules属性来指定的： 校验规则的写法： 说明： 规则是一个数组 数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况： 返回true，代表成功， 返回错误提示信息，代表失败 1.1.2.2.编写校验我们有四个字段： name：做非空校验和长度校验，长度必须大于1 letter：首字母，校验长度为1，非空。 image：图片，不做校验，图片可以为空 categories：非空校验，自定义组件已经帮我们完成，不用写了 首先，我们定义规则： 然后，在页面标签中指定： 12&lt;v-text-field v-model="brand.name" label="请输入品牌名称" hint="例如：oppo" :rules="[rules.required, rules.nameLength]"&gt;&lt;/v-text-field&gt;&lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" hint="例如：O" :rules="[rules.letter]"&gt;&lt;/v-text-field&gt; 效果： 1.1.3.表单提交在submit方法中添加表单提交的逻辑： 1234567891011121314151617181920212223242526submit() &#123; console.log(this.$qs); // 表单校验 if (this.$refs.myBrandForm.validate()) &#123; // 定义一个请求参数对象，通过解构表达式来获取brand中的属性&#123;categories letter name image&#125; const &#123;categories, letter, ...params&#125; = this.brand; // params:&#123;name, image, cids, letter&#125; // 数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串 params.cids = categories.map(c =&gt; c.id).join(","); // 将字母都处理为大写 params.letter = letter.toUpperCase(); // 将数据提交到后台 // this.$http.post('/item/brand', this.$qs.stringify(params)) this.$http(&#123; method: this.isEdit ? 'put' : 'post', url: '/item/brand', data: params &#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit("close"); this.$message.success("保存成功！"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;); &#125;&#125; 通过this.$refs.myBrandForm选中表单，然后调用表单的validate方法，进行表单校验。返回boolean值，true代表校验通过 通过解构表达式来获取brand中的值，categories需要处理，单独获取。其它的存入params对象中 品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的是对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串 发起请求 弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件： 这个插件把$message对象绑定到了Vue的原型上，因此我们可以通过this.$message来直接调用。 包含以下常用方法： info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”) confirm：确认框。用法：this.$message.confirm(&quot;确认框的提示信息&quot;)，返回一个Promise。 1.2.后台实现新增1.2.1.controller还是一样，先分析四个内容： 请求方式：POST 请求路径：/brand 请求参数：brand对象，外加商品分类的id数组cids 返回值：无，只需要响应状态码 代码： 12345678910/** * 新增品牌 * @param brand * @param cids */@PostMappingpublic ResponseEntity&lt;Void&gt; saveBrand(Brand brand, @RequestParam("cids") List&lt;Long&gt; cids)&#123; this.brandService.saveBrand(brand, cids); return ResponseEntity.status(HttpStatus.CREATED).build();&#125; 1.2.2.Service这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。 1234567891011121314151617/** * 新增品牌 * * @param brand * @param cids */@Transactionalpublic void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; // 先新增brand this.brandMapper.insertSelective(brand); // 在新增中间表 cids.forEach(cid -&gt; &#123; this.brandMapper.insertCategoryAndBrand(cid, brand.getId()); &#125;);&#125; 这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增 1.2.3.Mapper通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增： 1234567891011public interface BrandMapper extends Mapper&lt;Brand&gt; &#123; /** * 新增商品分类和品牌中间表数据 * @param cid 商品分类id * @param bid 品牌id * @return */ @Insert("INSERT INTO tb_category_brand(category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)") int insertBrandAndCategory(@Param("cid") Long cid, @Param("bid") Long bid);&#125; 1.2.4.测试 400：请求参数不合法 1.3.解决4001.3.1.原因分析我们填写表单并提交，发现报错了。查看控制台的请求详情： 发现请求的数据格式是JSON格式。 原因分析： axios处理请求体的原则会根据请求数据的格式来定： 如果请求体是对象：会转为json发送 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。 如：name=jack&amp;age=12 1.3.2.QS工具QS是一个第三方库，我们可以用npm install qs --save来安装。不过我们在项目中已经集成了，大家无需安装： 这个工具的名字：QS，即Query String，请求参数字符串。 什么是请求参数字符串？例如： name=jack&amp;age=21 QS工具可以便捷的实现 JS的Object与QueryString的转换。 在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过this.$qs来获取这个工具： 我们将this.$qs对象打印到控制台： 123created()&#123; console.log(this.$qs);&#125; 发现其中有3个方法： 这里我们要使用的方法是stringify，它可以把Object转为QueryString。 测试一下，使用浏览器工具，把qs对象保存为一个临时变量temp1，然后调用stringify方法： 成功将person对象变成了 name=zhangsan&amp;age=30的字符串了 1.3.3.解决问题修改页面，对参数处理后发送： 然后再次发起请求，发现请求成功： 1.4.新增完成后关闭窗口我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。 这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。 因此，我们需要在新增的ajax请求完成以后，关闭窗口 但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？ 之前我们讲过一个父子组件的通信，有印象吗？ 第一步：在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了。父组件在使用子组件时，绑定事件，关联到这个函数：Brand.vue 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5" style="height:400px"&gt; &lt;brand-form @close="closeWindow" :oldBrand="oldBrand" :isEdit="isEdit"/&gt;&lt;/v-card-text&gt; 第二步，子组件通过this.$emit调用父组件的函数：BrandForm.vue 测试一下，保存成功： 我们优化一下，关闭的同时重新加载数据： 123456closeWindow()&#123; // 关闭窗口 this.show = false; // 重新加载数据 this.getDataFromServer();&#125; 2.实现图片上传刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。 文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。 2.1.搭建项目2.1.1.创建module 2.1.2.依赖我们需要EurekaClient和web依赖： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.upload&lt;/groupId&gt; &lt;artifactId&gt;leyou-upload&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3.编写配置12345678910111213141516server: port: 8082spring: application: name: upload-service servlet: multipart: max-file-size: 5MB # 限制文件上传的大小# Eurekaeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 需要注意的是，我们应该添加了限制文件大小的配置 2.1.4.引导类12345678@SpringBootApplication@EnableDiscoveryClientpublic class LeyouUploadApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouUploadApplication.class, args); &#125;&#125; 结构： 2.2.编写上传功能文件上传功能，也是自定义组件完成的，参照自定义组件用法指南： 在页面中的使用： 2.2.1.controller编写controller需要知道4个内容：结合用法指南 请求方式：上传肯定是POST 请求路径：/upload/image 请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipartFile 返回结果：上传成功后得到的文件的url路径，也就是返回String 代码如下： 123456789101112131415161718192021@Controller@RequestMapping("upload")public class UploadController &#123; @Autowired private UploadService uploadService; /** * 图片上传 * @param file * @return */ @PostMapping("image") public ResponseEntity&lt;String&gt; uploadImage(@RequestParam("file") MultipartFile file)&#123; String url = this.uploadService.upload(file); if (StringUtils.isBlank(url)) &#123; return ResponseEntity.badRequest().build(); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(url); &#125;&#125; 2.2.2.service在上传文件过程中，我们需要对上传的内容进行校验： 校验文件大小 校验文件的媒体类型 校验文件的内容 文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。 具体代码： 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class UploadService &#123; private static final List&lt;String&gt; CONTENT_TYPES = Arrays.asList("image/jpeg", "image/gif"); private static final Logger LOGGER = LoggerFactory.getLogger(UploadService.class); public String upload(MultipartFile file) &#123; String originalFilename = file.getOriginalFilename(); // 校验文件的类型 String contentType = file.getContentType(); if (!CONTENT_TYPES.contains(contentType))&#123; // 文件类型不合法，直接返回null LOGGER.info("文件类型不合法：&#123;&#125;", originalFilename); return null; &#125; try &#123; // 校验文件的内容 BufferedImage bufferedImage = ImageIO.read(file.getInputStream()); if (bufferedImage == null)&#123; LOGGER.info("文件内容不合法：&#123;&#125;", originalFilename); return null; &#125; // 保存到服务器 file.transferTo(new File("C:\\leyou\\images\\" + originalFilename)); // 生成url地址，返回 return "http://image.leyou.com/" + originalFilename; &#125; catch (IOException e) &#123; LOGGER.info("服务器内部错误：&#123;&#125;", originalFilename); e.printStackTrace(); &#125; return null; &#125;&#125; 这里有一个问题：为什么图片地址需要使用另外的url？ 图片不能保存在服务器内部，这样会对服务器产生额外的加载负担 一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量 2.2.3.测试上传我们通过RestClient工具来测试： 结果： 去目录下查看： 上传成功！ 2.3.绕过网关图片上传是文件的传输，如果也经过Zuul网关的代理，文件就会经过多次网路传输，造成不必要的网络负担。在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。 所以，我们上传文件的请求就不经过网关来处理了。 2.3.1.Zuul的路由过滤Zuul中提供了一个ignored-patterns属性，用来忽略不希望路由的URL路径，示例： 1zuul.ignored-patterns: /upload/** 路径过滤会对一切微服务进行判定。 Zuul还提供了ignored-services属性，进行服务过滤： 1zuul.ignored-services: upload-servie 我们这里采用忽略服务： 123zuul: ignored-services: - upload-service # 忽略upload-service服务 上面的配置采用了集合语法，代表可以配置多个。 2.3.2.Nginx的rewrite指令现在，我们修改页面的访问路径： 123456&lt;v-upload v-model="brand.image" url="/upload/image" :multiple="false" :pic-width="250" :pic-height="90" /&gt; 查看页面的请求路径： 可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？ 有同学会想：修改页面请求地址不就好了。 注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。 既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。 我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址: 12345location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600;&#125; 这样写大家觉得对不对呢？ 显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：http://127.0.0.1:8002/api/upload/image 前面多了一个/api Nginx提供了rewrite指令，用于对地址进行重写，语法规则： 1rewrite "用来匹配路径的正则" 重写后的路径 [指令]; 我们的案例： 1234567891011121314151617181920212223server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 上传路径的映射 location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600; rewrite "^/api/(.*)$" /$1 break; &#125; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理 proxy_pass：反向代理，这次我们代理到8082端口，也就是upload-service服务 rewrite &quot;^/api/(.*)$&quot; /$1 break，路径重写： &quot;^/api/(.*)$&quot;：匹配路径的正则表达式，用了分组语法，把/api/以后的所有部分当做1组 /$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 break：指令，常用的有2个，分别是：last、break last：重写路径结束后，将得到的路径重新进行一次路径匹配 break：重写路径结束后，不再重新匹配路径。 我们这里不能选择last，否则以新的路径/upload/image来匹配，就不会被正确的匹配到8082端口了 修改完成，输入nginx -s reload命令重新加载配置。然后再次上传试试。 2.4.跨域问题重启nginx，再次上传，发现跟上次的状态码已经不一样了，但是依然报错： 不过庆幸的是，这个错误已经不是第一次见了，跨域问题。 我们在upload-service中添加一个CorsFilter即可： 1234567891011121314151617181920212223@Configurationpublic class LeyouCorsConfiguration &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("POST"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 再次测试： 不过，非常遗憾的是，访问图片地址，却没有响应。 这是因为我们并没有任何服务器对应image.leyou.com这个域名。。 这个问题，我们暂时放下，回头再来解决。 2.5.文件上传的缺陷先思考一下，现在上传的功能，有没有什么问题？ 上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题： 单机器存储，存储能力有限 无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况 数据没有备份，有单点故障风险 并发能力差 这个时候，最好使用分布式文件存储来代替本地文件存储。 3.FastDFS3.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 3.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 3.3.FastDFS的架构3.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 3.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 3.4.安装和使用参考课前资料的： 3.5.java客户端余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。 这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。 配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。 地址：tobato/FastDFS_client 接下来，我们就用FastDFS改造leyou-upload工程。 3.5.1.引入依赖在父工程中，我们已经管理了依赖，版本为： 1&lt;fastDFS.client.version&gt;1.26.2&lt;/fastDFS.client.version&gt; 因此，这里我们直接在taotao-upload工程的pom.xml中引入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.5.2.引入配置类 纯java配置： 1234567@Configuration@Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter &#123; &#125; 3.5.3.编写FastDFS属性在application.yml配置文件中追加如下内容： 12345678fdfs: so-timeout: 1501 # 超时时间 connect-timeout: 601 # 连接超时时间 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址：你的虚拟机服务器地址+端口（默认是22122） - 192.168.56.101:22122 3.5.4.配置hosts将来通过域名：image.leyou.com这个域名访问fastDFS服务器上的图片资源。所以，需要代理到虚拟机地址： 配置hosts文件，使image.leyou.com可以访问fastDFS服务器 3.5.5.测试创建测试类： 把以下内容copy进去： 1234567891011121314151617181920212223242526272829303132333435363738@SpringBootTest@RunWith(SpringRunner.class)public class FastDFSTest &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException &#123; // 要上传的文件 File file = new File("C:\\Users\\joedy\\Pictures\\xbx1.jpg"); // 上传并保存图片，参数：1-上传的文件流 2-文件的大小 3-文件的后缀 4-可以不管他 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), "jpg", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); &#125; @Test public void testUploadAndCreateThumb() throws FileNotFoundException &#123; File file = new File("C:\\Users\\joedy\\Pictures\\xbx1.jpg"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), "png", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); &#125;&#125; 结果： 12group1/M00/00/00/wKg4ZVsWl5eAdLNZAABAhya2V0c424.jpgM00/00/00/wKg4ZVsWl5eAdLNZAABAhya2V0c424.jpg 123group1/M00/00/00/wKg4ZVsWmD-ARnWiAABAhya2V0c772.pngM00/00/00/wKg4ZVsWmD-ARnWiAABAhya2V0c772.pngM00/00/00/wKg4ZVsWmD-ARnWiAABAhya2V0c772_60x60.png 访问第二组第一个路径： 访问最后一个路径（缩略图路径），注意加组名（group1）： 3.5.6.改造上传逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class UploadService &#123; @Autowired private FastFileStorageClient storageClient; private static final List&lt;String&gt; CONTENT_TYPES = Arrays.asList("image/jpeg", "image/gif"); private static final Logger LOGGER = LoggerFactory.getLogger(UploadService.class); public String upload(MultipartFile file) &#123; String originalFilename = file.getOriginalFilename(); // 校验文件的类型 String contentType = file.getContentType(); if (!CONTENT_TYPES.contains(contentType))&#123; // 文件类型不合法，直接返回null LOGGER.info("文件类型不合法：&#123;&#125;", originalFilename); return null; &#125; try &#123; // 校验文件的内容 BufferedImage bufferedImage = ImageIO.read(file.getInputStream()); if (bufferedImage == null)&#123; LOGGER.info("文件内容不合法：&#123;&#125;", originalFilename); return null; &#125; // 保存到服务器 // file.transferTo(new File("C:\\leyou\\images\\" + originalFilename)); String ext = StringUtils.substringAfterLast(originalFilename, "."); StorePath storePath = this.storageClient.uploadFile(file.getInputStream(), file.getSize(), ext, null); // 生成url地址，返回 return "http://image.leyou.com/" + storePath.getFullPath(); &#125; catch (IOException e) &#123; LOGGER.info("服务器内部错误：&#123;&#125;", originalFilename); e.printStackTrace(); &#125; return null; &#125;&#125; 只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。 3.5.7.测试通过RestClient测试： 3.6.页面测试上传发现上传成功： 4.修改品牌（作业）修改的难点在于回显。 当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据： 4.1.点击编辑出现弹窗这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件： 123&lt;v-icon small class="mr-2" @click="editItem(props.item)"&gt; edit&lt;/v-icon&gt; 然后编写事件，改变show 的状态： 如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？ 4.2.回显数据回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。 第一步：在编辑时获取当前选中的品牌信息，并且记录到data中 先在data中定义属性，用来接收用来编辑的brand数据： 我们在页面触发编辑事件时，把当前的brand传递给editBrand方法： 1&lt;v-btn color="info" @click="editBrand(props.item)"&gt;编辑&lt;/v-btn&gt; 然后在editBrand中接收数据，赋值给oldBrand： 123456editItem(oldBrand)&#123; // 使编辑窗口可见 this.dialog = true; // 初始化编辑的数据 this.oldBrand = oldBrand;&#125; 第二步：把获取的brand数据 传递给子组件 12345&lt;!--对话框内容--&gt;&lt;v-card-text class="px-5"&gt; &lt;!--这是一个表单--&gt; &lt;my-brand-form @close="close" :oldBrand="oldBrand"&gt;&lt;/my-brand-form&gt;&lt;/v-card-text&gt; 第三步：在子组件（MyBrandForm.vue）中通过props接收要编辑的brand数据，Vue会自动完成回显 接收数据： 通过watch函数监控oldBrand的变化，把值copy到本地的brand： 12345678910111213141516171819watch: &#123; oldBrand: &#123;// 监控oldBrand的变化 handler(val) &#123; if(val)&#123; // 注意不要直接赋值，否则这边的修改会影响到父组件的数据，copy属性即可 this.brand = Object.deepCopy(val) &#125;else&#123; // 为空，初始化brand this.brand = &#123; name: '', letter: '', image: '', categories: [] &#125; &#125; &#125;, deep: true &#125;&#125; Object.deepCopy 自定义的对象进行深度复制的方法。 需要判断监听到的是否为空，如果为空，应该进行初始化 测试：发现数据回显了，除了商品分类以外： 4.3.商品分类回显为什么商品分类没有回显？ 因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息： 4.3.1.后台提供接口 controller 12345678910111213/** * 通过品牌id查询商品分类 * @param bid * @return */@GetMapping("bid/&#123;bid&#125;")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByBrandId(@PathVariable("bid") Long bid) &#123; List&lt;Category&gt; list = this.categoryService.queryByBrandId(bid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123public List&lt;Category&gt; queryByBrandId(Long bid) &#123; return this.categoryMapper.queryByBrandId(bid);&#125; mapper 因为需要通过中间表进行子查询，所以这里要手写Sql： 1234567/** * 根据品牌id查询商品分类 * @param bid * @return */@Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)")List&lt;Category&gt; queryByBrandId(Long bid); 4.3.2.前台查询分类并渲染我们在编辑页面打开之前，先把数据查询完毕： 123456789101112editBrand(oldBrand)&#123; // 根据品牌信息查询商品分类 this.$http.get("/item/category/bid/" + oldBrand.id) .then((&#123;data&#125;) =&gt; &#123; // 控制弹窗可见： this.dialog = true; // 获取要编辑的brand this.oldBrand = oldBrand // 回显商品分类 this.oldBrand.categories = data; &#125;)&#125; 再次测试：数据成功回显了 4.3.3.新增窗口数据干扰但是，此时却产生了新问题：新增窗口竟然也有数据？ 原因： 如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。 解决： 新增窗口打开前，把数据置空。 123456addBrand() &#123; // 控制弹窗可见： this.dialog = true; // 把oldBrand变为null this.oldBrand = null;&#125; 4.3.4.提交表单时判断是新增还是修改新增和修改是同一个页面，我们该如何判断？ 父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。 因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。 第一步：在父组件中记录状态： 第二步：在新增和修改前，更改状态： 第三步：传递给子组件 第四步，子组件接收标记： 标题的动态化： 表单提交动态： axios除了除了get和post外，还有一个通用的请求方式： 1234567891011121314// 将数据提交到后台// this.$http.post('/item/brand', this.$qs.stringify(params))this.$http(&#123; method: this.isEdit ? 'put' : 'post', // 动态判断是POST还是PUT url: '/item/brand', data: this.$qs.stringify(this.brand)&#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit("close"); this.$message.success("保存成功！");&#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！");&#125;); 5.删除（作业）]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day07-自定义组件用法指南]]></title>
    <url>%2F2019%2F07%2F02%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday07-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1.树组件的用法1.1.示例1234567&lt;v-tree url="/item/category/list" :isEdit="true" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick"/&gt; 效果： 1.2.属性列表 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 1.3.事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 1.4.完整node的信息回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 2.级联选择组件2.1.示例：12345&lt;v-cascader url="/item/category/list" multiple required v-model="brand.categories" label="请选择商品分类"/&gt; 2.2.效果： 2.3.结果值v-model绑定的数据结果： 2.4.属性列表： 属性名称 说明 数据类型 默认值 url 延迟加载数据的地址 [{id,name},{}] String 无 itemText 每个选项中用来显示的字段名称 String name itemValue 每个选项中用来作为值的字段名称 String id children 子选项数组在父选项中的字段名称 String children multiple 是否允许多选 boolean false showAllLevels 是否将级联的每级选项都作为结果展示。当multiple值为true时，这个值无效，即只会显示最后一级选项的结果 boolean false required 是否是必填项，如果是，会在文本提示后加* boolean false rules 自定义校验规则 Array 无 value 选择框的结果，可以通过v-model进行双向绑定 Array 无 label 提示用户的文字说明 String 无 2.5.说明：无论是单选还是多选，value的结果格式始终是一个数组。单选时数组的长度始终为1。 数组中的对象结构为： 1234&#123; &#123;itemValue&#125;:'', // 属性名取决于itemValue的值，默认是id &#123;itemText&#125;:''// 属性名取决于itemText的值，默认是name&#125; 3.文件上传组件3.1.示例：3.1.1.单图片上传：1234567&lt;v-upload v-model="brand.image" url="/item/upload" :multiple="false" :pic-width="150" :pic-height="150" /&gt; 上传前： 上传后： 3.1.2.多图片上传示例： 1234&lt;v-upload v-model="brand.image" url="/item/upload" /&gt; 效果： 3.2.属性列表： 属性名 说明 数据类型 默认值 url 上传文件的目标路径 String 无 value 上传成功的返回结果 单图片上传是String。多图片上传是String数组 无 multiple 是否运行多图片上传 Boolean true picWidth 单图片上传后的预览宽度 Number 150 picHeight 单图片上传后的预览高度 Number 150 3.3.说明可以通过v-model双向绑定，来获取图片上传的结果： 单图片上传时，value值是一个图片地址 多图片上传时，value值是一个图片地址数组 文件上传的参数名是：file 文件上传的返回值，就是图片的url路径 4.自定义富文本编辑器4.1.示例：1&lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image" fileName="file"/&gt; 4.2.效果： 4.3.属性说明属性列表： 属性名 说明 数据类型 默认值 value 编辑器的输出结果，可以用v-model双向绑定 String 无 upload-url 上传按钮对应的图片上传地址，以项目全局的url配置为前缀 String 无 file-name 上传文件的参数名 String file maxUploadSize 上传文件的大小限制，单位byte Number 500kb 备注： 默认支持的图片类型：jpg/png/jpeg/gif]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day07-商品查询]]></title>
    <url>%2F2019%2F07%2F02%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday07-%E5%95%86%E5%93%81%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.搭建后台管理前端1.1.导入已有资源后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在Intellij idea中导入新的工程： 选中我们的工程： 1.2.安装依赖你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 建议删除node_modules目录，重新安装。或者copy其他人的node_modules使用 1.3.运行一下看看 在package.json文件中有scripts启动脚本配置，可以输入命令：npm run dev或者npm start 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转： 1.4.目录结构 webpack：是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。并且提供了前端项目的热部署插件。 1.5.调用关系我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html：html模板文件。定义了空的div，其id为app。 main.js：实例化vue对象，并且通过id选择器绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是webpack打包的入口。 index.js：定义请求路径和组件的映射关系。相当于之前的&lt;vue-router&gt; App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终结论：一切路由后的内容都将通过App.vue在index.html中显示。 访问流程：用户在浏览器输入路径，例如：http://localhost:9001/#/item/brand –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中） 2.Vuetify框架2.1.为什么要学习UI框架Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 2.2.为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 2.3.怎么用？基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 2.4.项目页面布局接下来我们一起看下页面布局。 Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以外的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。 3.使用域名访问本地项目3.1.统一环境我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com，leyou.com 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 3.2.域名解析一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 12# My hosts127.0.0.1 localhost 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 3.3.解决域名解析问题我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 解压，运行exe文件，效果： 我们添加了两个映射关系（中间用空格隔开）： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 通过域名访问： 原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。 在webpack.dev.conf.js中取消host验证：disableHostCheck: true 重新执行npm run dev，刷新浏览器： OK！ 3.4.nginx解决端口问题域名问题解决了，但是现在要访问后台页面，还得自己加上端口：http://manage.taotao.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 3.4.1.什么是Nginx nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 3.4.2.nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 3.4.3.nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 3.4.4.安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程： 3.5.测试启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 4.实现商品分类查询商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，我们需要依次去完成：商品分类、品牌、商品的开发。 4.1.导入数据首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 4.2.实现功能在浏览器页面点击“分类管理”菜单： 根据这个路由路径到路由文件（src/route/index.js），可以定位到分类管理页面： 由路由文件知，页面是src/pages/item/Category.vue 商品分类使用了树状结构，而这种结构的组件vuetify并没有为我们提供，这里自定义了一个树状组件。不要求实现或者查询组件的实现，只要求可以参照文档使用该组件即可： 4.2.1.url异步请求点击商品管理下的分类管理子菜单，在浏览器控制台可以看到： 页面中没有，只是发起了一条请求：http://api.leyou.com/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径：/item/category/list，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://api.leyou.com/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是http://api.leyou.com，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 4.2.2.实体类在leyou-item-interface中添加category实体类： 内容： 1234567891011@Table(name="tb_category")public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; // 注意isParent生成的getter和setter方法需要手动加上Is private Integer sort; // getter和setter略&#125; 需要注意的是，这里要用到jpa的注解，因此我们在leyou-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 4.2.3.controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get，插叙肯定是get请求 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。也就是List&lt;Category&gt; 添加Controller： controller代码： 123456789101112131415161718192021222324252627@Controller@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父id查询子节点 * @param pid * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoriesByPid(@RequestParam("pid") Long pid) &#123; if (pid == null || pid.longValue() &lt; 0) &#123; // 响应400，相当于ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); return ResponseEntity.badRequest().build(); &#125; List&lt;Category&gt; categories = this.categoryService.queryCategoriesByPid(pid); if (CollectionUtils.isEmpty(categories)) &#123; // 响应404 return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(categories); &#125;&#125; 4.2.4.service一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 1234567891011121314151617@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据parentId查询子类目 * @param pid * @return */ public List&lt;Category&gt; queryCategoriesByPid(Long pid) &#123; Category record = new Category(); record.setParentId(pid); return this.categoryMapper.select(record); &#125;&#125; 4.2.5.mapper我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // mapper接口的包扫描public class LeyouItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouItemServiceApplication.class, args); &#125;&#125; 4.2.6.启动并测试我们不经过网关，直接访问：http://localhost:8081/category/list 然后试试网关是否畅通：http://api.leyou.com/api/item/category/list 一切OK！ 然后刷新后台管理页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 这其实是浏览器的同源策略造成的跨域问题。 5.跨域问题跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods http和https也属于跨域 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 5.1.为什么有跨域问题？跨域不一定都会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 5.2.解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 5.3.cors解决跨域5.3.1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 5.3.2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 5.3.2.1.简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 5.3.2.2.特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 5.3.3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在leyou-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class LeyouCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 重启测试，访问正常： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 6.品牌的查询商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 点击“品牌管理”菜单： 路由路径：/item/brand 根据路由文件知，对应的页面是：src/pages/item/Brand.vue 页面会发送如下请求： 6.1.后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 6.1.1.数据库表1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 6.1.2.实体类 12345678910@Table(name = "tb_brand")public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; 6.1.3.mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 6.1.4.controller编写controller先思考四个问题，参照前端页面的控制台 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Integer totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到leyou-common中，提高复用性： 不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 接下来，我们编写Controller 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; /** * 根据查询条件分页并排序查询品牌信息 * @param key * @param page * @param rows * @param sortBy * @param desc * @return */ @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandsByPage( @RequestParam(value = "key", required = false)String key, @RequestParam(value = "page", defaultValue = "1")Integer page, @RequestParam(value = "rows", defaultValue = "5")Integer rows, @RequestParam(value = "sortBy", required = false)String sortBy, @RequestParam(value = "desc", required = false)Boolean desc )&#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandsByPage(key, page, rows, sortBy, desc); if (CollectionUtils.isEmpty(result.getItems()))&#123; return ResponseEntity.notFound().build(); &#125; return ResponseEntity.ok(result); &#125;&#125; 6.1.5.Service123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; /** * 根据查询条件分页并排序查询品牌信息 * * @param key * @param page * @param rows * @param sortBy * @param desc * @return */ public PageResult&lt;Brand&gt; queryBrandsByPage(String key, Integer page, Integer rows, String sortBy, Boolean desc) &#123; // 初始化example对象 Example example = new Example(Brand.class); Example.Criteria criteria = example.createCriteria(); // 根据name模糊查询，或者根据首字母查询 if (StringUtils.isNotBlank(key)) &#123; criteria.andLike("name", "%" + key + "%").orEqualTo("letter", key); &#125; // 添加分页条件 PageHelper.startPage(page, rows); // 添加排序条件 if (StringUtils.isNotBlank(sortBy)) &#123; example.setOrderByClause(sortBy + " " + (desc ? "desc" : "asc")); &#125; List&lt;Brand&gt; brands = this.brandMapper.selectByExample(example); // 包装成pageInfo PageInfo&lt;Brand&gt; pageInfo = new PageInfo&lt;&gt;(brands); // 包装成分页结果集返回 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo.getList()); &#125;&#125; 6.1.6.测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 6.2.异步查询工具axios异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 6.2.1.axios入门Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 6.2.2.axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 6.2.3.项目中使用我们在组件Brand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： resp到底都有那些数据，查看控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 6.3.完成分页和过滤6.3.1.分页点击分页，会发起请求，通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询！ 具体实现： 成功实现分页功能： 6.3.2.过滤过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day05-vue入门]]></title>
    <url>%2F2019%2F07%2F01%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday05-vue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学习目标 会创建Vue实例，知道Vue的常见属性 会使用Vue的生命周期的钩子函数 会使用vue常见指令 会使用vue计算属性和watch监控 会编写Vue组件 掌握组件间通信 了解vue-router使用 0.前言前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 而我们今天要学习的，就是一款MVVM模式的框架：Vue 1.认识VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 2.Node和NPM前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。 2.1.下载Node.js下载地址：https://nodejs.org/en/ 推荐下载LTS版本。 课程中采用的是8.11.3版本。也是目前最新的。大家自行下载或者使用课前资料中提供的安装包。然后下一步安装即可。 完成以后，在控制台输入： 1node -v 看到版本信息： 2.2.NPMNode自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装。可能需要一点儿时间 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 3.快速入门接下来，我们快速领略下vue的魅力 3.1.创建工程创建一个新的空工程： 然后新建一个module： 选中static web，静态web项目： 位置信息： 3.2.安装vue3.2.1.下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 3.2.2.使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 3.2.3.推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 3.3.vue入门案例3.3.1.HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 3.3.2.vue声明式渲染然后我们通过Vue进行渲染： 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;，非常帅！！！&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el:"#app", // el即element，该vue实例要渲染的页面元素 data:&#123; // 渲染页面需要的数据 name: "啊柴" &#125; &#125;);&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你修改name属性时，页面会跟着变化： 3.3.3.双向绑定我们对刚才的案例进行简单修改： 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="num"&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125; &#125;);&lt;/script&gt; 我们在data添加了新的属性：num 在页面中有一个input元素，通过v-model与num进行绑定。 同时通过在页面输出 效果： 我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 3.3.4.事件处理我们在页面添加一个按钮： 1&lt;button v-on:click="num++"&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通click是无法直接操作num的。 效果： 4.Vue实例4.1.创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 4.2.模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id="app"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:"#app"&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 4.3.数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:"#app", data:&#123; name:"刘德华" &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 4.4.方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。 html: 1234&lt;div id="app"&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click="add"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 4.5.生命周期钩子4.5.1.生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 4.5.2.钩子函数123456789101112131415beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化时调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用。 beforeMount：页面加载完成，没有渲染。如：此时页面还是&#123;&#123;name&#125;&#125;mounted：我们可以将他理解为原生js中的window.onload=function(&#123;.,.&#125;),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function()&#123;….&#125;)，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的&#123;&#123;name&#125;&#125;已被渲染成峰哥beforeDestroy：该函数将在销毁实例前进行调用 。destroyed：改函数将在销毁实例时进行调用。beforeUpdate：组件更新之前。updated：组件更新之后。 例如：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的钩子函数： 12345678910111213141516// 创建vue实例var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125;, methods: &#123; add: function()&#123; this.num--; &#125; &#125;, created: function () &#123; this.num = 100; &#125;&#125;); 结果： 4.5.3.this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 123456methods: &#123; add: function()&#123; this.num--; console.log(this); &#125;&#125;, 控制台的输出： 5.指令什么是指令？ 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 5.1.插值表达式5.1.1.花括号格式： 1&#123;&#123;表达式&#125;&#125; 说明： 该表达式支持JS语法，可以调用js内置函数（必须有返回值） 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 示例： HTML： 1&lt;div id="app"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:"#app", data:&#123; name:"Jack" &#125;&#125;) 5.1.2.插值闪烁使用花括号方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的花括号，加载完毕后才显示正确数据，我们称为插值闪烁。 我们将网速调慢一些，然后试试看刚才的案例： 刷新页面： 5.1.3.v-text和v-html解决上面的问题，可以使用v-text和v-html指令来替代花括号 说明： v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 示例： HTML: 1234&lt;div id="app"&gt; v-text:&lt;span v-text="hello"&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html="hello"&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:"#app", data:&#123; hello: "&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;" &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 5.2.v-model刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="checkbox" v-model="language" value="Java" /&gt;Java&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="PHP" /&gt;PHP&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="Swift" /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(',')&#125;&#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 radio对应的值是input的value值 text 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： 5.3.v-on5.3.1.基本用法v-on指令用于给页面元素绑定事件。 语法： 1v-on:事件名=&quot;js片段或函数名&quot; 示例： 123456789101112131415161718192021&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="num++"&gt;增加一个&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click="decrement"&gt;减少一个&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; num:100 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 5.3.2.事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生* .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执行一次 阻止默认事件 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--右击事件，并阻止默认事件发生--&gt; &lt;button v-on:contextmenu.prevent="num++"&gt;增加一个&lt;/button&gt; &lt;br/&gt; &lt;!--右击事件，不阻止默认事件发生--&gt; &lt;button v-on:contextmenu="decrement($event)"&gt;减少一个&lt;/button&gt; &lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个同学被点击&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; num: 100 &#125;, methods: &#123; decrement(ev) &#123; // ev.preventDefault(); this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件） 5.3.3.按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13="submit"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 全部的按键别名： .enter* .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 5.3.4.组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 5.4.v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 5.4.1.遍历数组 语法： 1v-for=&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt; &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'峰哥', gender:'男', age: 18&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125;, &#125;)&lt;/script&gt; 效果： 5.4.2.数组角标在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 12345&lt;ul&gt; &lt;li v-for="(user, index) in users"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 5.4.3.遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for="value in object"v-for="(value,key) in object"v-for="(value,key,index) in object" 1个参数时，得到的是对象的属性值 2个参数时，第一个是属性值，第二个是属性名 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in user"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; user:&#123;name:'峰哥', gender:'男', age: 18&#125; &#125; &#125;)&lt;/script&gt; 效果： 5.4.4.key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for="(item,index) in items" :key=index&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 5.5.v-if和v-show5.5.1.基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if=&quot;布尔表达式&quot; 示例： 12345678910111213141516171819&lt;div id="app"&gt; &lt;button v-on:click="show = !show"&gt;点我呀&lt;/button&gt; &lt;br&gt; &lt;h1 v-if="show"&gt; 看到我啦？！ &lt;/h1&gt; &lt;h1 v-show="show"&gt; 看到我啦？！show &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125; &#125;)&lt;/script&gt; 效果： 5.5.2.与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 修改v-for中的案例，添加v-if： 12345&lt;ul&gt; &lt;li v-for="(user, index) in users" v-if="user.gender == '女'"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 只显示女性用户信息 5.5.3.v-else你可以使用 v-else 指令来表示 v-if 的“else 块”： 12345678&lt;div id="app"&gt; &lt;h1 v-if="Math.random() &gt; 0.5"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;/span&gt; &lt;h1 v-if="random &gt;= 0.75"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.5"&gt; 看到我啦？！if 0.5 &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.25"&gt; 看到我啦？！if 0.25 &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; random: 1 &#125; &#125;)&lt;/script&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 演示： 5.5.4.v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="show = !show"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if="show"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码： 5.6.v-bindhtml属性不能直接使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 12345678910111213&lt;div id="app"&gt; &lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt; &lt;div v-bind:title="title" style="border: 1px solid red; width: 50px; height: 50px;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; title: "title", &#125; &#125;)&lt;/script&gt; 效果： 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 5.6.1.绑定class样式 数组语法 我们可以借助于v-bind指令来实现： HTML： 123456789101112131415&lt;div id="app"&gt; &lt;div v-bind:class="activeClass"&gt;&lt;/div&gt; &lt;div v-bind:class="errorClass"&gt;&lt;/div&gt; &lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; activeClass: 'active', errorClass: ['text-danger', 'text-error'] &#125; &#125;)&lt;/script&gt; 渲染后的效果：（具有active和hasError的样式） 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class="static active"&gt;&lt;/div&gt; active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 5.6.2.绑定style样式 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 数据： 1234data: &#123; baseStyles: &#123;'background-color': 'red'&#125;, overridingStyles: &#123;border: '1px solid black'&#125;&#125; 渲染后的结果： 1&lt;div style="background-color: red; border: 1px solid black;"&gt;&lt;/div&gt; 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; 数据： 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 效果： 1&lt;div style="color: red; font-size: 30px;"&gt;&lt;/div&gt; 5.6.3.简写v-bind:class可以简写为:class 5.7.计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性（这里注意属性和方法，属性是没有()的，方法才有），来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + "-" + d.getMonth() + "-" + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id="app"&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 5.8.watchwatch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; message:"" &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 6.组件化在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 在vue里，所有的vue实例都是组件 6.1.全局组件我们通过Vue的component方法来定义一个全局组件。 12345678910111213141516171819&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 Vue.component("counter",&#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 效果： 6.2.组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像之前直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 6.3.局部组件一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = &#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:"#app", components:&#123; counter:counter // 将定义的对象注册为组件 &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象名 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 6.4.组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 6.4.1.props（父向子传递） 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据） 子组件通过props接收父组件数据，通过自定义属性的属性名 父组件使用子组件，并自定义了title属性： 12345678910111213141516&lt;div id="app"&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce title="大家好，我是柴宁"/&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("introduce",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;', props:['title'] // 通过props来接收一个父组件传递的属性 &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 效果： 6.4.2.props验证我们定义一个子组件，并接收复杂数据： 1234567891011121314const myList = &#123; template: '\ &lt;ul&gt;\ &lt;li v-for="item in items" :key="item.id"&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\ &lt;/ul&gt;\ ', props: &#123; items: &#123; type: Array, default: [], required: true &#125; &#125;&#125;; 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 我们在父组件中使用它： 12345&lt;div id="app"&gt; &lt;h2&gt;大学里已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items="lessons"/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:"#app", components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: 'java'&#125;, &#123;id:2, name: 'php'&#125;, &#123;id:3, name: 'ios'&#125;, ] &#125;&#125;) 效果： type类型，可以有： 注意：子组件模板有且只有一个根标签 6.4.3.动态静态传递给 prop 传入一个静态的值： 1&lt;introduce title="大家好，我是锋哥"/&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title="title"/&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes="42"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes="post.likes"&gt;&lt;/blog-post&gt; 6.4.4.子向父的通信：$emit来看这样的一个案例： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num="num"&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("counter", &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:'\ &lt;div&gt;\ &lt;button @click="num++"&gt;加&lt;/button&gt; \ &lt;button @click="num--"&gt;减&lt;/button&gt; \ &lt;/div&gt;', props:['num']// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 1234&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt;&lt;/div&gt; 在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： 12345678910111213141516Vue.component("counter", &#123; template:'\ &lt;div&gt;\ &lt;button @click="plus"&gt;加&lt;/button&gt; \ &lt;button @click="reduce"&gt;减&lt;/button&gt; \ &lt;/div&gt;', props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125;&#125;) vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 效果： 7.路由vue-router7.1.场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 7.1.1.编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 7.1.2.编写登录及注册组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及login.js及register.js： 编写组件，这里我们只写模板，不写功能。 login.js内容如下： 12345678910//组件内的template只能有一个根标签const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; register.js内容： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 7.1.3.在父组件中引用123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt; &lt;!-- 疑问：为什么不采用上面的写法？ 由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt; 所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式 --&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="user/login.js"&gt;&lt;/script&gt;&lt;script src="user/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 7.1.5.问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 7.2.vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 7.3.快速入门新建vue-router对象，并且指定路由规则： 12345678910111213// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写路由规则 &#123; path:"/login", // 请求路径，必须以“/”开头 component:loginForm // 组件名称 &#125;, &#123; path:"/register", component:registerForm &#125; ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day06-webpack]]></title>
    <url>%2F2019%2F07%2F01%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday06-webpack%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 独立搭建后台管理系统 了解系统基本结构 1.路由vue-router1.1.场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 1.1.1.编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src: 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 1.1.2.编写登录组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放如独立的JS文件中，我们新建一个login.js 编写组件，这里我们只写模板，不写功能： 123456789const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 1.1.3.编写注册组件新建单文件组件：register.js 编写模板： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 1.1.4.在父组件中引用在index.html中使用刚刚编写的两个组件 123456789101112131415161718192021&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="js/login.js"&gt;&lt;/script&gt;&lt;script src="js/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 1.1.5.问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 1.2.vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 1.3.快速入门新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 1.4.父子组件2.webpack2.1.认识webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 2.2.四个核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的启点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 2.3.安装webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 2.4.编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 2.4.1.入口entrywebpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到main.js中 1234567891011121314151617181920212223242526// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router'import loginForm from './js/login'import registerForm from './js/register'Vue.use(VueRouter)// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;)var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router&#125;) 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 12345678910const loginForm = &#123; template:` &lt;div&gt; &lt;h2&gt;登录页&lt;/h2&gt; 用户名：&lt;input type="text"&gt;&lt;br/&gt; 密码：&lt;input type="password"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:` &lt;div&gt; &lt;h2&gt;注册页&lt;/h2&gt; 用户名：&lt;input type="text"&gt;&lt;br/&gt; 密码：&lt;input type="password"&gt;&lt;br/&gt; 确认密码：&lt;input type="password"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default registerForm; vue-router使用模块话加载后，必须增加一句：Vue.use(VueRouter) 这样，main.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件&#125; 2.4.2.出口output出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 2.5.执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 2.6.测试运行在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../dist/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 2.7.打包CSS2.7.1.编写css文件我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 2.7.2.安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令： 1npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 2.7.3.在main.js引入css文件因为入口在main.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 2.7.4.在webpack.config.js添加加载器123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 2.7.5.重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： 2.8.script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是脚本的名称build 2.9.打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.10.热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件： 1npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123"scripts": &#123; "dev": "webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本： 1npm run dev 4）效果： 3.vue-cli3.1.介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令： 1npm install -g vue-cli 3.2.快速上手我们新建一个module： 打开终端并进入目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 3.3.项目结构安装好的项目结构： 入口文件： 3.4.单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的loginForm.js和registerForm.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，看到上面的data(){}了吧 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 3.5.运行看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面： 4.搭建后台管理前端4.1.导入已有资源后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在eclipse中导入新的工程： 选中我们的工程： 这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样： 4.2.安装依赖你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要通过命令来安装所需依赖即可。打开终端，进入项目目录，输入：npm install 大概需要1分钟。 4.3.运行一下看看输入命令： 1npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转： 5.Vuetify框架5.1.为什么要学习UI框架Vue负责的是虽然会帮我们进行视图的渲染，但是样式是有我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 5.2.为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 5.3.怎么用？基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 6.项目结构开始编码前，我们先了解下项目的结构： 6.1.目录结构首先是目录结构图： 6.2.调用关系我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html中定义了空的div，其id为app。 main.js中定义了Vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。 而main.js中只有一行内容：&lt;App/&gt;,这是使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。 App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终的结论是：一切路由后的内容都将通过App.vue在index.html中显示。 6.3.页面布局接下来我们一起看下页面布局： Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day04-乐优商城项目搭建]]></title>
    <url>%2F2019%2F06%2F30%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday04-%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 1.2.2.数据 来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：闲鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 技术经理： 产品经理：设计需求原型 测试： 前端：大前端：UI 前端页面。 后端： 移动端： 项目开发流程图： 公司现状： 2.乐优商城介绍2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单 可以评论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 … 3.项目搭建3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify（UI框架） 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.x和MyBatis3 Spring Boot 2.0.7版本 Spring Cloud 最新版 Finchley.SR2 Redis-4.0 RabbitMQ-3.4 Elasticsearch-6.3 nginx-1.14.2 FastDFS - 5.0.8 MyCat Thymeleaf mysql 5.6 3.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可（3.5.2） 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 3.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com，leyou.com leyou.cn 二级域名：manage.leyou.com/item , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 3.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是module 填写项目信息： 填写保存的位置信息： 然后将pom文件修改成我这个样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等，很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 可以删除src目录，工程结构如下： 3.5.创建EurekaServer3.5.1.创建工程我们的注册中心，起名为：leyou-registry 选择新建module： 不要选择骨架： 然后填写项目坐标，我们的项目名称为leyou-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2.添加依赖添加EurekaServer的依赖： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3.编写启动类12345678@SpringBootApplication@EnableEurekaServerpublic class LeyouRegistryApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouRegistryApplication.class, args); &#125;&#125; 3.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: leyou-registryeureka: client: service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka register-with-eureka: false # 把自己注册到eureka服务列表 fetch-registry: false # 拉取eureka服务信息 server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒钟，进行一次服务列表的清理 3.5.5.项目的结构目前，整个项目的结构如图： 3.6.创建Zuul网关3.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：leyou-gateway 填写保存的目录： 3.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot提供微服务检测接口，默认对外提供几个接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LeyouGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouGatewayApplication.class, args); &#125;&#125; 3.6.4.配置文件123456789101112server: port: 10010spring: application: name: leyou-gatewayeureka: client: registry-fetch-interval-seconds: 5 service-url: defaultZone: http://127.0.0.1:10086/eurekazuul: prefix: /api # 路由路径前缀 3.6.5.项目结构目前，leyou下有两个子模块： leyou-registry：服务的注册中心（EurekaServer） leyou-gateway：服务网关（Zuul） 目前，服务的结构如图所示： 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 3.7.创建商品微服务既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 3.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为leyou-item. 需要注意的是，我们的leyou-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，获取的接口数据，也需要对应的实体类来封装，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在leyou-item中创建两个子工程： leyou-item-interface：主要是对外暴露的接口及相关实体类 leyou-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 3.7.2.leyou-item依然是使用maven构建： 保存的位置： 因为是聚合工程，所以把项目打包方式设置为pom 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.leyou-item-interface在leyou-item工程上点击右键，选择new –&gt; module: 依然是使用maven构建，注意父工程是leyou-item： 注意：目录结构，保存到leyou-item下的leyou-item-interface目录中： 点击Finish完成。 此时的项目结构： 3.7.4.leyou-item-service与leyou-item-interface类似，我们选择在leyou-item上右键，新建module，然后填写项目信息： 填写存储位置 点击Finish完成。 3.7.5.整个微服务结构如图所示： 我们打开leyou-item的pom查看，会发现leyou-item-interface和leyou-item-service都已经成为module了： 可以删除leyou-item工程的src目录 3.7.6.添加依赖接下来我们给leyou-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jdbc启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springboot检测服务启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; leyou-item-interface中需要什么我们暂时不清楚，所以先不管。以后需要什么依赖，再引入。 3.7.7.编写启动和配置在整个leyou-item工程中，只有leyou-item-service是需要启动的。因此在其中编写启动类即可： 12345678@SpringBootApplication@EnableDiscoveryClientpublic class LeyouItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouItemServiceApplication.class, args); &#125;&#125; 然后是全局属性文件： 123456789101112131415161718192021server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/leyou username: root password: root hikari: max-lifetime: 28830000 # 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like '%timeout%';） maximum-pool-size: 9 # 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count)mybatis: type-aliases-package: com.leyou.item.pojoeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 5秒钟发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 3.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 修改leyou-gateway工程的application.yml配置文件： 1234zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 3.9.启动测试我们分别启动：leyou-registry，leyou-gateway，leyou-item-service 查看Eureka面板： 3.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，SpringBoot提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：leyou-common 右键leyou工程，使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4.ES6语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 4.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4.0 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 4.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 创建一个空的html页面： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script&gt;&lt;/script&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 结果： const const声明的变量是常量，不能被修改 4.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 4.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 4.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: "jack", // 以前： eat: function (food) &#123; console.log(this.name + "在吃" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + "在吃" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + "在吃" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log("hello," + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log("hello," + name); 4.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 12345let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选）。 第一个参数（函数）接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 4.3.6.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assign(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 4.3.7.数组扩展ES6给数组新增了许多方法： find(callback)：数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 findIndex(callback)：数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 includes(数组元素)：与find类似，如果匹配到元素，则返回true，代表找到了。]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day03-认识微服务2]]></title>
    <url>%2F2019%2F06%2F29%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday03-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A12%2F</url>
    <content type="text"><![CDATA[0.学习目标 会配置Hystix熔断 会使用Feign进行远程调用 能独立搭建Zuul网关 能编写Zuul的过滤器 1.Hystrix1.1.简介Hystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。 Hystrix也是Netflix公司的一款组件。 主页：https://github.com/Netflix/Hystrix/ 那么Hystix的作用是什么呢？具体要保护什么呢？ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.2.雪崩问题微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路： 如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。 如果此时，某个服务出现异常： 例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。 这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。 此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 Hystix解决雪崩问题的手段有两个： 线程隔离 服务熔断 1.3.线程隔离，服务降级1.3.1.原理线程隔离示意图： 解读： Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。 用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，或者请求超时，则会进行降级处理，什么是服务降级？ 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。 用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。 服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。 触发Hystix服务降级的情况： 线程池已满 请求超时 1.3.2.动手实践1.3.2.1.引入依赖首先在itcast-service-consumer的pom.xml中引入Hystrix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.2.开启熔断 可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication 因此，我们可以使用这个组合注解来代替之前的3个注解。 12345678910111213@SpringCloudApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 1.3.2.3.编写降级逻辑我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成： 12345678910111213141516171819@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand(fallbackMethod = "queryUserByIdFallBack") public String queryUserById(@RequestParam("id") Long id) &#123; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user; &#125; public String queryUserByIdFallBack(Long id)&#123; return "请求繁忙，请稍后再试！"; &#125;&#125; 要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。 说明： @HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法 测试： 当itcast-service-provder正常提供服务时，访问与以前一致。但是当我们将itcast-service-provider停机时，会发现页面返回了降级处理信息： 1.3.2.4.默认FallBack我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback： 1234567891011121314151617181920212223242526@Controller@RequestMapping("consumer/user")@DefaultProperties(defaultFallback = "fallBackMethod") // 指定一个类的全局熔断方法public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody @HystrixCommand // 标记该方法需要熔断 public String queryUserById(@RequestParam("id") Long id) &#123; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user; &#125; /** * 熔断方法 * 返回值要和被熔断的方法的返回值一致 * 熔断方法不需要参数 * @return */ public String fallBackMethod()&#123; return "请求繁忙，请稍后再试！"; &#125;&#125; @DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的失败降级方法 @HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法。 defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致 1.3.2.5.设置超时在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值： 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。该配置没有提示。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms 改造服务提供者 改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断： 123456789@GetMapping("&#123;id&#125;")public User queryUserById(@PathVariable("id") Long id) &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return this.userService.queryUserById(id);&#125; 1.4.服务熔断1.4.1.熔断原理熔断器，也叫断路器，其英文单词为：Circuit Breaker 熔断状态机3个状态： Closed：关闭状态，所有请求都正常访问。 Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。 Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时 1.4.2.动手实践为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑： 123456789@GetMapping("&#123;id&#125;")@HystrixCommandpublic String queryUserById(@PathVariable("id") Long id)&#123; if(id == 1)&#123; throw new RuntimeException("太忙了"); &#125; String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); return user;&#125; 这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑） 我们准备两个请求窗口： 一个请求：http://localhost/consumer/user/1，注定失败 一个请求：http://localhost/consumer/user/2，肯定成功 当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。 此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右： 不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略： 123circuitBreaker.requestVolumeThreshold=10circuitBreaker.sleepWindowInMilliseconds=10000circuitBreaker.errorThresholdPercentage=50 解读： requestVolumeThreshold：触发熔断的最小请求次数，默认20 errorThresholdPercentage：触发熔断的失败请求最小占比，默认50% sleepWindowInMilliseconds：休眠时长，默认是5000毫秒 2.Feign在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 1String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class); 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 2.1.简介有道词典的英文解释： 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 2.2.快速入门改造itcast-service-consumer工程 2.2.1.导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.2.开启Feign功能我们在启动类上，添加注解，开启Feign功能 12345678@SpringCloudApplication@EnableFeignClients // 开启feign客户端public class ItcastServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 删除RestTemplate：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。 2.2.3.Feign的客户端在itcast-service-consumer工程中，添加UserClient接口： 内容： 123456@FeignClient(value = "service-provider") // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping("user/&#123;id&#125;") User queryById(@PathVariable("id") Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，调用UserClient接口： 123456789101112131415@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private UserClient userClient; @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; User user = this.userClient.queryUserById(id); return user; &#125;&#125; 2.2.4.启动测试访问接口： 正常获取到了结果。 2.3.负载均衡Feign中本身已经集成了Ribbon依赖和自动配置： 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 2.4.Hystrix支持Feign默认也有对Hystrix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在itcast-service-consumer工程添加配置内容) 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像hystrix中那样简单了。 1）首先，我们要定义一个类UserClientFallback，实现刚才编写的UserClient，作为fallback的处理类 12345678910@Componentpublic class UserClientFallback implements UserClient &#123; @Override public User queryById(Long id) &#123; User user = new User(); user.setUserName("服务器繁忙，请稍后再试！"); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = "service-provider", fallback = UserClientFallback.class) // 标注该类是一个feign接口public interface UserClient &#123; @GetMapping("user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 3）重启测试： 2.5.请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 2.6.日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: cn.itcast: debug 2）编写配置类，定义日志级别 内容： 12345678@Configurationpublic class FeignLogConfiguration &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = "service-privider", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 4）重启项目，即可看到每次访问的日志： 3.Zuul网关通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 3.1.简介官网：https://github.com/Netflix/zuul Zuul：维基百科 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ 3.2.Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 3.3.快速入门3.3.1.新建工程填写基本信息： 添加Zuul依赖： 3.3.2.编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 3.3.3.编写引导类通过@EnableZuulProxy注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启网关功能public class ItcastZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastZuulApplication.class, args); &#125;&#125; 3.3.4.编写路由规则我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345678910server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名zuul: routes: service-provider: # 这里是路由id，随意写 path: /service-provider/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /service-provider/**开头的请求，代理到http://127.0.0.1:8081 3.3.5.启动测试访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:10010/service-provider/user/1 3.4.面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 对itcast-zuul工程修改优化： 3.4.1.添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.添加Eureka配置，获取服务信息12345eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka 3.4.3.开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.4.4.修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: service-provider: # 这里是路由id，随意写 path: /service-provider/** # 这里是映射路径 serviceId: service-provider # 指定服务名称 3.4.5.启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 3.5.简化的路由配置在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=service-provider：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于service-provider的配置可以简化为一条： 123zuul: routes: service-provider: /service-provider/** # 这里是映射路径 省去了对服务名称的配置。 3.6.默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：service-provider，则默认的映射路径就 是：/service-provider/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 3.7.路由前缀配置示例： 12345zuul: routes: service-provider: /service-provider/** service-consumer: /service-consumer/** prefix: /api # 添加路由前缀 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 3.8.过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 3.8.1.ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 route：在路由请求时调用 post：在route和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 3.8.2.过滤器执行生命周期这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 正常流程： 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。 所有内置过滤器列表： 3.8.3.使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 3.9.自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 3.9.1.定义过滤器类 内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Componentpublic class LoginFilter extends ZuulFilter &#123; /** * 过滤器类型，前置过滤器 * @return */ @Override public String filterType() &#123; return "pre"; &#125; /** * 过滤器的执行顺序 * @return */ @Override public int filterOrder() &#123; return 1; &#125; /** * 该过滤器是否生效 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 登陆校验逻辑 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; // 获取zuul提供的上下文对象 RequestContext context = RequestContext.getCurrentContext(); // 从上下文对象中获取请求对象 HttpServletRequest request = context.getRequest(); // 获取token信息 String token = request.getParameter("access-token"); // 判断 if (StringUtils.isBlank(token)) &#123; // 过滤该请求，不对其进行路由 context.setSendZuulResponse(false); // 设置响应状态码，401 context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); // 设置响应信息 context.setResponseBody("&#123;\"status\":\"401\", \"text\":\"request error!\"&#125;"); &#125; // 校验通过，把登陆信息放入上下文信息，继续向后执行 context.set("token", token); return null; &#125;&#125; 3.9.2.测试没有token参数时，访问失败： 添加token参数后： 3.10.负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms 4.总结]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day02-认识微服务]]></title>
    <url>%2F2019%2F06%2F28%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday02-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解系统架构的演变 了解RPC与Http的区别 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1.集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4.流动计算架构（SOA）SOA ：面向服务的架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 2.服务调用方式2.1.RPC和HTTP无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下2种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 现在热门的Rest风格，就可以通过http协议来实现。 如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。 相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。 2.2.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，不过这些不同的客户端，API各不相同 2.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 我们导入课前资料提供的demo工程： 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; // 调用springboot案例中的rest接口 User user = this.restTemplate.getForObject("http://localhost/user/1", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 3.初识SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 3.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） Zuul：网关组件，提供智能路由，访问过滤功能 Ribbon：客户端负载均衡的服务调用组件（客户端负载） Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) 架构图： 以上只是其中一部分。 3.2.版本因为Spring Cloud不同其他独立项目，它拥有很多子项目的大项目。所以它的版本是版本名+版本号 （如Angel.SR6）。 版本名：是伦敦的地铁名 版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 所以 Edgware.SR3就是Edgware的第3个Release版本。 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 4.微服务场景模拟首先，我们需要模拟一个服务调用的场景，搭建两个工程：itcast-service-provider（服务提供方）和itcast-service-consumer（服务调用方）。方便后面学习微服务架构 服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。 服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。 4.1.服务提供者我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。 4.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具： next–&gt;填写项目信息： next –&gt; 添加web依赖： 添加mybatis依赖： Next –&gt; 填写项目位置： 生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）： 依赖也已经全部自动引入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 非常快捷啊！ 4.1.2.编写代码 4.1.2.1.配置属性文件,这里我们采用了yaml语法，而不是properties： 123456789server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mybatis #你学习mybatis时，使用的数据库地址 username: root password: rootmybatis: type-aliases-package: cn.itcast.service.pojo 4.1.2.2.实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; public Date getUpdated() &#123; return updated; &#125; public void setUpdated(Date updated) &#123; this.updated = updated; &#125;&#125; 4.1.2.3.UserMapper123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 4.1.2.4.UserService12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 4.1.2.5.UserController添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; 4.1.3.启动并测试启动项目，访问接口：http://localhost:8081/user/1 4.2.服务调用者搭建itcast-service-consumer服务消费方工程。 4.2.1.创建工程与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。 pom： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.2.2.编写代码 首先在引导类中注册RestTemplate： 123456789101112@SpringBootApplicationpublic class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 编写配置（application.yml）： 12server: port: 80 编写UserController： 123456789101112131415@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; User user = this.restTemplate.getForObject("http://localhost:8081/user/" + id, User.class); return user; &#125;&#125; pojo对象（User）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; public Date getUpdated() &#123; return updated; &#125; public void setUpdated(Date updated) &#123; this.updated = updated; &#125;&#125; 4.2.3.启动测试因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost/consumer/user?id=1 一个简单的远程服务调用案例就实现了。 4.3.有没有问题？简单回顾一下，刚才我们写了什么： itcast-service-provider：一个提供根据id查询用户的微服务。 itcast-service-consumer：一个服务调用者，通过RestTemplate远程调用itcast-service-provider。 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚provider的状态，服务宕机也不知道 provider只有1台服务，不具备高可用性 即便provider形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 5.Eureka注册中心5.1.认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，itcast-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 5.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 5.3.入门案例5.3.1.搭建EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。因为，对于eureka来说：服务提供方和服务消费方都属于客户端 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.eureka&lt;/groupId&gt; &lt;artifactId&gt;itcast-eureka&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写application.yml配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 修改引导类，在类上添加@EnableEurekaServer注解： 12345678@SpringBootApplication@EnableEurekaServer // 声明当前springboot应用是一个eureka服务中心public class ItcastEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastEurekaApplication.class, args); &#125;&#125; 启动服务，并访问：http://127.0.0.1:10086 5.3.2.注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 修改itcast-service-provider工程 在pom.xml中，添加springcloud的相关依赖。 在application.yml中，添加springcloud的相关依赖。 在引导类上添加注解，把服务注入到eureka注册中心。 具体操作 5.3.2.1.pom.xml参照itcast-eureka，先添加SpringCloud依赖： 123456789101112&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 完整pom.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 5.3.2.2.application.yml12345678910111213141516server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/heima username: root password: root driverClassName: com.mysql.jdbc.Driver application: name: service-provider # 应用名称，注册到eureka后的服务名称mybatis: type-aliases-package: cn.itcast.service.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 5.3.2.3.引导类在引导类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 12345678@SpringBootApplication@EnableDiscoveryClientpublic class ItcastServiceProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceApplication.class, args); &#125;&#125; 重启项目，访问Eureka监控页面查看 我们发现service-provider服务已经注册成功了 5.3.3.从Eureka获取服务接下来我们修改itcast-service-consumer，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.service&lt;/groupId&gt; &lt;artifactId&gt;itcast-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;itcast-service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- SpringCloud的依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 修改配置 123456789server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://localhost:10086/eureka 在启动类开启Eureka客户端 12345678910111213@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ItcastServiceConsumerApplication &#123; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ItcastServiceConsumerApplication.class, args); &#125;&#125; 修改UserController代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 123456789101112131415161718192021222324@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; // eureka客户端，可以获取到eureka中服务的信息 @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("service-provider"); // 因为只有一个Service-provider。所以获取第一个实例 ServiceInstance instance = instances.get(0); // 获取ip和端口信息，拼接成服务地址 String baseUrl = "http://" + instance.getHost() + ":" + instance.getPort() + "/user/" + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： 5.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。 5.4.1.基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的itcast-eureka。 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的itcast-service-provider。 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的itcast-service-consumer。 5.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把itcast-eureka启动两次即可。 1）启动第一个eurekaServer，我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 启动报错，很正常。因为10087服务没有启动： 2）启动第二个eurekaServer，再次修改itcast-eureka的配置： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）访问集群，测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 10086： 10087： 5.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-eureka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。 第一层Map的Key就是服务id，一般是配置中的spring.application.name属性 第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：locahost:service-provider:8081 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 5.4.4.服务消费者 获取服务列表 当服务消费者启动时，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 5.4.5.失效剔除和自我保护 服务下线 当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生产环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka） 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 6.负载均衡Ribbon在刚才的案例中，我们启动了一个itcast-service-provider，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个itcast-service-provider的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 6.1.启动两个服务实例首先参照itcast-eureka启动两个ItcastServiceProviderApplication实例，一个8081，一个8082。 Eureka监控面板： 6.2.开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。 修改itcast-service-consumer的引导类，在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 123456789101112131415161718192021@Controller@RequestMapping("consumer/user")public class UserController &#123; @Autowired private RestTemplate restTemplate; //@Autowired //private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表 @GetMapping @ResponseBody public User queryUserById(@RequestParam("id") Long id)&#123; // 通过client获取服务提供方的服务列表，这里我们只有一个 // ServiceInstance instance = discoveryClient.getInstances("service-provider").get(0); String baseUrl = "http://service-provider/user/" + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; &#125;&#125; 访问页面，查看结果： 完美！ 6.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 在如下代码打断点： 一路源码跟踪：RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute： 点击进入AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute: 继续跟入：LoadBalancerInterceptor.intercept方法 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 6.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们注入这个类的对象，然后对其测试： 测试内容： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastServiceConsumerApplication.class)public class LoadBalanceTest &#123; @Autowired private RibbonLoadBalancerClient client; @Test public void testLoadBalance()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("service-provider"); System.out.println(instance.getHost() + ":" +instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口，在itcast-service-consumer的application.yml中添加如下配置： 123456789101112server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekaservice-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机：]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day01-springboot]]></title>
    <url>%2F2019%2F06%2F21%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%2Fday01-springboot%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. 翻译一下： Spring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。 我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。 其实人们把Spring Boot称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点： 复杂的配置 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 混乱的依赖管理 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ 1.3.SpringBoot的特点Spring Boot 主要特征是： 创建独立的spring应用程序 直接内嵌tomcat、jetty和undertow（不需要打包成war包部署） 提供了固定化的“starter”配置，以简化构建配置 尽可能的自动配置spring和第三方库 提供产品级的功能，如：安全指标、运行状况监测和外部化配置等 绝对不会生成代码，并且不需要XML配置 总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的入门体验 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 环境要求： 2.1.创建工程我们先新建一个空的demo工程，如下： 创建以moduel： 填写坐标信息： 目录结构： 创建完成后的目录结构： 2.2.引入依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.springboot&lt;/groupId&gt; &lt;artifactId&gt;itcast-springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.编写HelloController 代码： 12345678910111213@RestController@EnableAutoConfigurationpublic class HelloController &#123; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloController.class, args); &#125;&#125; 2.4.启动测试 bingo！访问成功！ 2.5.详解入门工程中：pom.xml里引入了启动器的概念以@EnableAutoConfiguration注解。 2.5.1.启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.5.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. 简单翻译以下： 开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。 2.6.优化入门程序现在工程中只有一个Controller，可以这么玩；那么如果有多个Controller，怎么办呢？ 添加Hello2Controller： 代码： 123456789@RestControllerpublic class Hello2Controller &#123; @GetMapping("show2") public String test()&#123; return "hello Spring Boot2!"; &#125;&#125; 启动重新启动，访问show2测试，失败： 难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。 所以，springboot程序引入了一个全局的引导类。 2.5.1.添加引导类通常请求下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。 在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class： 内容如下： 1234567@EnableAutoConfigurationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 并修改HelloController，去掉main方法及@EnableAutoConfiguration： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125;&#125; 启动引导类，访问show测试： 发现所有的Controller都不能访问，为什么？ 回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——@ComponentScan注解 2.5.2.@ComponentScanspring框架除了提供配置方式的注解扫描&lt;context:component-scan /&gt;，还提供了注解方式的注解扫描@ComponentScan。 在TestApplication.class中，使用@ComponentScan注解： 123456789@EnableAutoConfiguration@ComponentScanpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 重新启动，访问show或者show2： 我们跟进该注解的源码，并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。一般启动类会放在一个比较浅的包目录中。 2.5.3.@SpringBootApplication我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解 使用@SpringBootApplication改造TestApplication： 12345678@SpringBootApplicationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 点击进入，查看源码： 发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration：开启自动配置 @ComponentScan：开启注解扫描 2.5.4.@SpringBootConfiguration@SpringBootConfiguration注解的源码： 我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 3.默认配置原理springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢? 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @Value：属性注入 @PropertySource：指定外部属性文件。 我们接下来用java配置来尝试实现连接池配置 3.2.1.引入依赖首先在pom.xml中，引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot2-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 3.2.2.添加jdbc.properties1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 3.2.3.配置数据源创建JdbcConfiguration类： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfiguration &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明JdbcConfiguration是一个配置类。 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值。 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签 然后就可以在任意位置通过@Autowired注入DataSource了！ 3.2.4.测试我们在HelloController中测试： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("show") public String test()&#123; return "hello Spring Boot!"; &#125;&#125; 在test方法中打一个断点，然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）新建JdbcProperties，用来进行属性注入： 代码： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致，并且必须具有getter和setter方法 需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们把jdbc.properties名称改为application.properties 2）在JdbcConfiguration中使用这个属性： 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties： @Autowired注入 123456789101112131415161718@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Autowired private JdbcProperties jdbcProperties; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbcProperties.getUrl()); dataSource.setDriverClassName(jdbcProperties.getDriverClassName()); dataSource.setUsername(jdbcProperties.getUsername()); dataSource.setPassword(jdbcProperties.getPassword()); return dataSource; &#125;&#125; 构造函数注入 12345678910111213141516@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; private JdbcProperties jdbcProperties; public JdbcConfiguration(JdbcProperties jdbcProperties)&#123; this.jdbcProperties = jdbcProperties; &#125; @Bean public DataSource dataSource() &#123; // 略 &#125;&#125; @Bean方法的参数注入 123456789@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfiguration &#123; @Bean public DataSource dataSource(JdbcProperties jdbcProperties) &#123; // ... &#125;&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 3.4.更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfiguration &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 3.5.SpringBoot中的默认配置通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是怎么配置的，在哪里配置的呢？ 为何依赖引入就会触发配置呢？ 这些默认配置的属性来自哪里呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 3.6.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 4.SpringBoot实战接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 4.1.创建工程 4.2.编写基本代码 pom.xml: 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 参照上边的项目，编写引导类： 1234567@SpringBootApplicationpublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class); &#125;&#125; 编写UserController： 123456789@RestController@RequestMapping("user")public class UserController &#123; @GetMapping("hello") public String test()&#123; return "hello ssm"; &#125;&#125; 4.3.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 4.3.1.修改端口添加全局配置文件：application.properties 端口通过以下方式配置 12# 映射端口server.port=80 重启服务后测试： 4.3.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 4.3.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 实现如下： 首先我们定义一个拦截器： 123456789101112131415161718@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle method is running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle method is running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion method is running!"); &#125;&#125; 然后定义配置类，注册拦截器： 123456789101112131415@Configurationpublic class MvcConfiguration implements WebMvcConfigurer &#123; @Autowired private HandlerInterceptor myInterceptor; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns("/**"); &#125;&#125; 接下来运行并查看日志： 123preHandle method is running!postHandle method is running!afterCompletion method is running! 你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置org.springframework包的日志级别为debuglogging.level.org.springframework=debug 再次运行查看： 4.4.整合连接池jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 在pom.xml中引入jdbc的启动器： 12345678910&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 4.5.整合mybatis4.5.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官方自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; user对象参照课前资料，需要通用mapper的注解： 接下来，就去集成通用mapper。 4.5.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 4.6.整合事务其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 4.7.启动测试在UserController中添加测试方法，内容： 1234567891011121314151617@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("&#123;id&#125;") public User queryUserById(@PathVariable("id")Long id)&#123; return this.userService.queryById(id); &#125; @GetMapping("hello") public String test()&#123; return "hello ssm"; &#125;&#125; 我们启动项目，查看： 4.8.完整项目结构 完整的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.user&lt;/groupId&gt; &lt;artifactId&gt;itcast-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用mapper --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 完整的application.properties： 123456789101112server.port=80logging.level.org.springframework=debugspring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=root# mybatis 别名扫描mybatis.type-aliases-package=cn.itcast.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉# mybatis.mapper-locations=classpath:mappers/*.xml 5.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 5.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 5.2.提供数据编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 5.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 5.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125;"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;user.birthday&#125;"&gt;1980-02-30&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 5.5.测试接下来，我们打开页面测试一下： 5.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： 在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。 eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.x 单元测试]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%90%8E%E7%AB%AF%2Fspring%2FSpringBoot2.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。 我曾经在 单元测试指南 一文中写到过单元测试的必要性和 Java 单元测试相关的工具及方法。单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。在 SpringBoot2.x 集成和写单元测试更加容易了。 创建 SpringBoot2.x 项目在 start.spring.io 中创建一个自己的 SpringBoot2.x 项目，目前版本2.1.3。选出自己需要的一些组件生成项目即可，我这里选了如下几个： Web: Web项目 JPA: 数据库持久层采用Spring Data JPA，方便实用 Lombok: 可以通过注解大量减少Java中重复代码的书写 HSQLDB: 内存数据库，用来对 Repository 层做单元测试 生成之后可以在 pom.xml 中看到 SpringBoot2.x 项目中已经引入了spring-boot-starter-test这个启动组件，包含了几乎绝大多数测试场景需要的组件。然后通过mvn clean install来构建本项目或者直接导入 IDE 开发工具即可。 下面将以对博客信息做简单修改和查询为示例来说明在 Spring Boot 中如何分别对 DAO，Service，Controller 做单元测试。 DAO 层的单元测试新建数据库脚本DAO 层的测试我这里采用的是 HSQLDB 的内存数据库，最好准备一些初始化的数据表结构和脚本，当然也可用直接通过官方示例的 JPA特性和 API 代码来初始化数据。这里我还是通过脚本的方式来做，便于统一管理和维护表结构和数据。 在 src/test 目录下新建 resources 资源目录，并在 resources 目录下新建 db 目录，在 db 目录下分别，新建用于管理的表结构文件(schema.sql)和初始化数据文件(data.sql)的 SQL 脚本。 schema.sql 文件中的内容如下： 1234567891011121314151617181920-- 创建数据库表所在的模式 schema.CREATE SCHEMA test;commit;-- 在 test 模式下创建数据库表.DROP TABLE IF EXISTS test.t_test_blog;CREATE TABLE test.t_test_blog ( c_id varchar(32) NOT NULL, c_author varchar(255), c_content varchar(255), dt_publish_time timestamp(6) NULL, c_title varchar(255), c_url varchar(255), n_status int, c_create_user varchar(255), dt_create_time timestamp(6) NULL, dt_update_time timestamp(6) NULL, constraint pk_test_blog primary key(c_id));commit; data.sql 文件中的内容如下： 1234-- 初始化插入一些博客信息数据.INSERT INTO test.t_test_blog VALUES ('1', '张三', '这是内容', '2019-03-01 00:41:01', 'Spring从入门到精通', 'https://baidu.com', '1', 'tom', '2019-03-01 00:41:33', '2019-03-01 00:41:36');INSERT INTO test.t_test_blog VALUES ('2', '李四', '这是Mybatis的内容', '2019-03-01 00:41:01', 'Mybatis基础', 'https://qq.com', '2', 'jack', '2019-03-01 00:41:33', '2019-03-01 00:41:36');commit; 增加 yaml 配置文件及内容在 resources 目录下新建 application-hsqldb.yml 配置文件，用于存放 HSQLDB 及 JPA 相关的配置信息，主要配置内容如下： 1234567891011121314spring: datasource: url: jdbc:hsqldb:mem:db_test # 以内存数据库的方式来运行. username: root password: 123456 driver-class-name: org.hsqldb.jdbc.JDBCDriver platform: hsqldb schema: classpath:db/schema.sql data: classpath:db/data.sql jpa: show-sql: true hibernate: ddl-auto: none # 这里没用 JPA 的自动生成表结构等功能，你可以视自己的具体情况来开启. generate-ddl: false # 启动时是否初始化数据库. 准备实体 POJO 和 DAO 层 Repository 类博客信息的实体 POJO 类如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.blinkfox.springbootsample.pojo;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import lombok.Getter;import lombok.Setter;import lombok.experimental.Accessors;/** * 博客实体. * * @author blinkfox on 2019-2-26. */@Getter@Setter@Accessors(chain = true)@Entity@Table(name = "t_test_blog", schema = "test")public class Blog &#123; /** * ID. */ @Id @Column(name = "c_id") private String id; /** * 作者. */ @Column(name = "c_author") private String author; /** * 标题. */ @Column(name = "c_title") private String title; /** * 内容. */ @Column(name = "c_content") private String content; /** * 发布时间. */ @Column(name = "dt_publish_time") private Date publishTime; /** * 链接地址. */ @Column(name = "c_url") private String url; /** * 状态. */ @Column(name = "n_status") private Integer status; /** * 创建用户. */ @Column(name = "c_create_user") private String createUser; /** * 创建时间. */ @Column(name = "dt_create_time") private Date createTime; /** * 最后更新时间. */ @Column(name = "dt_update_time") private Date updateTime;&#125; 下面是 BlogRepository 中的一个简单的自定义 @Query 查询，当然你也可以采用名称的规则来写本查询，我这里为了做示例，使用了 @Query 查询。 12345678910111213141516171819202122package com.blinkfox.springbootsample.repository;import com.blinkfox.springbootsample.pojo.Blog;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.stereotype.Repository;/** * BlogRepository. * * @author blinkfox on 2019-02-27. */@Repositorypublic interface BlogRepository extends JpaRepository&lt;Blog, String&gt; &#123; @Query("SELECT b FROM Blog AS b WHERE b.title like 'Spring%'") List&lt;Blog&gt; querySpringBlogs();&#125; BlogRepository 的单元测试然后在 Intellij IDEA 中通过 Ctrl + Shift + T 来为 BlogRepository 生成它对应的单元测试类 BlogRepositoryTest。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.blinkfox.springbootsample.repository;import com.blinkfox.springbootsample.pojo.Blog;import java.util.List;import java.util.Optional;import javax.annotation.Resource;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit4.SpringRunner;/** * BlogRepositoryTest. * * @author blinkfox on 2019-03-01. */@RunWith(SpringRunner.class)@ActiveProfiles("hsqldb")@DataJpaTestpublic class BlogRepositoryTest &#123; @Resource private BlogRepository blogRepository; /** * 测试新增博客的情况. */ @Test public void save() &#123; String id = "newblogId"; String title = "Java 从入门到放弃"; blogRepository.save(new Blog().setId(id).setTitle(title)); Optional&lt;Blog&gt; blogOptional = blogRepository.findById(id); Assert.assertTrue(blogOptional.isPresent() &amp;&amp; title.equals(blogOptional.get().getTitle())); &#125; /** * 测试查询所有 Spring 相关的博客信息. */ @Test public void querySpringBlogs() &#123; List&lt;Blog&gt; blogs = blogRepository.querySpringBlogs(); Assert.assertEquals(1, blogs.size()); Assert.assertEquals("Spring从入门到精通", blogs.get(0).getTitle()); &#125;&#125; 这样就完成了 DAO 层代码的测试，以上程序主要依托于内存数据库 HSQLDB 和 Spring Data JPA。 Service 层的单元测试实际开发过程中，Service 层中的类依赖了 DAO 层中的类或其他 Service 类。为了隔离对其他 Service 类或 DAO 层中的类的依赖，只测试本 Service 类中的方法逻辑，就需要 Mock 数据和做打桩等操作。Spring Boot 中原生集成了 Mockito，可以非常方便我们对 Java 代码做单元测试。 新建 BlogService 类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.blinkfox.springbootsample.service;import com.blinkfox.springbootsample.pojo.Blog;import com.blinkfox.springbootsample.repository.BlogRepository;import java.util.List;import java.util.Optional;import javax.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;/** * BlogService. * * @author blinkfox on 2019-03-01. */@Slf4j@Servicepublic class BlogService &#123; @Resource private BlogRepository blogRepository; /** * 查询所有 Spring 相关的博客信息. * * @return 博客信息 */ public List&lt;Blog&gt; getSpringBlogs() &#123; log.info("进入了获取 Spring 相关博客的 Service 方法."); return blogRepository.querySpringBlogs(); &#125; /** * 根据博客ID来修改该博客的名称. * * @param id 博客ID * @param title 博客标题 */ public void modifyTitileById(String id, String title) &#123; Optional&lt;Blog&gt; blogOptional = blogRepository.findById(id); if (!blogOptional.isPresent()) &#123; log.warn("需要修改名称的博客不存在，id为【&#123;&#125;】请检查！", id); return; &#125; blogRepository.save(blogOptional.get().setTitle(title)); &#125;&#125; BlogService 的单元测试通过 BlogService 可以生成和书写出其对应的单元测试类和测试方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.blinkfox.springbootsample.service;import com.blinkfox.springbootsample.pojo.Blog;import com.blinkfox.springbootsample.repository.BlogRepository;import java.util.ArrayList;import java.util.List;import java.util.Optional;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.Mockito;import org.mockito.junit.MockitoJUnitRunner;/** * BlogServiceTest. * * @author blinkfox on 2019-03-01. */@RunWith(MockitoJUnitRunner.class)public class BlogServiceTest &#123; @Mock private BlogRepository blogRepository; @InjectMocks private BlogService blogService; /** * 测试service层中获取Spring相关博客的方法. */ @Test public void getSpringBlogs() &#123; // 构造需要返回的博客信息集合数据. Blog blog = new Blog() .setId("1") .setTitle("Spring Action"); List&lt;Blog&gt; blogList = new ArrayList&lt;&gt;(); blogList.add(blog); Mockito.when(blogRepository.querySpringBlogs()) .thenReturn(blogList); List&lt;Blog&gt; blogs = blogService.getSpringBlogs(); // 断言验证查询到的数据. Assert.assertEquals(1, blogs.size()); Assert.assertEquals("Spring Action", blog.getTitle()); &#125; /** * 测试根据博客ID来修改该博客的名称成功时的情况. */ @Test public void modifyTitileById() &#123; // Mock 相关数据和类方法的行为. String id = "1"; Mockito.when(blogRepository.findById(id)) .thenReturn(Optional.of(new Blog())); Mockito.when(blogRepository.save(Mockito.any())) .thenReturn(new Blog()); blogService.modifyTitileById(id, "算法导论"); // 验证 blogRepository.save(s) 方法被调用过一次. Mockito.verify(blogRepository).save(Mockito.any()); &#125; /** * 测试根据博客ID来修改该博客的名称失败时的情况. */ @Test public void modifyTitileByIdWithFailure() &#123; // Mock 未根据 ID 找到对应的博客信息的情况. String id = "1"; Mockito.when(blogRepository.findById(id)) .thenReturn(Optional.ofNullable(null)); blogService.modifyTitileById(id, "算法导论"); // 验证 blogRepository.save(s) 方法并没有被调用过. Mockito.verify(blogRepository, Mockito.never()).save(Mockito.any()); &#125;&#125; 注意：这里的 @RunWith 采用的是 Mocktio 提供的 MockitoJUnitRunner。 这样就完成了 Service 层的单元测试，也是我们业务开发中需要重点关注和测试业务逻辑的一层。 Controller 层的单元测试Controller 层测试的重点是测试接口是否能正常工作。可以用到 Spring Boot 中提供的 @WebMvcTest 注解来模拟 Web 层的单元测试。当然，也需要通过 Mock 的方式类隔离对 Service 层各个类的依赖影响。 新建 BlogController 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.blinkfox.springbootsample.controller;import com.blinkfox.springbootsample.pojo.Blog;import com.blinkfox.springbootsample.service.BlogService;import java.util.List;import javax.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * BlogController. * * @author blinkfox on 2019-02-28. */@Slf4j@RequestMapping("/blogs")@RestControllerpublic class BlogController &#123; @Resource private BlogService blogService; /** * 获取所有 Spring 相关的博客信息. * * @return Spring相关的博客信息 */ @GetMapping public ResponseEntity&lt;List&lt;Blog&gt;&gt; getSpringBlogs() &#123; return ResponseEntity.ok(blogService.getSpringBlogs()); &#125; /** * 根据博客ID修改博客名称. * * @param id 博客ID * @param title 博客标题 * @return 空 */ @PatchMapping("/&#123;id&#125;") public ResponseEntity&lt;Void&gt; modifyTitileById(@PathVariable("id") String id, @RequestParam("title") String title) &#123; try &#123; blogService.modifyTitileById(id, title); log.info("修改博客名称成功."); return new ResponseEntity&lt;&gt;(HttpStatus.OK); &#125; catch (Exception e) &#123; log.error("修改博客名称出错，id为【&#123;&#125;】.", id); return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125;&#125; BlogController 的单元测试通过 BlogController 可以生成和书写出其对应的单元测试类和测试方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.blinkfox.springbootsample.controller;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.blinkfox.springbootsample.service.BlogService;import java.util.ArrayList;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mockito;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;/** * BlogControllerTest. * * @author blinkfox on 2019-03-02. */@RunWith(SpringRunner.class)@WebMvcTest(BlogController.class)public class BlogControllerTest &#123; @Resource private MockMvc mockMvc; @MockBean private BlogService blogService; /** * 测试获取所有 Spring 相关的博客信息. * * @throws Exception 异常 */ @Test public void getSpringBlogs() throws Exception &#123; Mockito.when(blogService.getSpringBlogs()) .thenReturn(new ArrayList&lt;&gt;()); this.mockMvc.perform(get("/blogs")) .andExpect(status().isOk()); &#125; /** * 测试修改博客标题成功时的情况. * * @throws Exception 异常 */ @Test public void modifyTitileById() throws Exception &#123; Mockito.doNothing() .when(blogService).modifyTitileById(Mockito.anyString(), Mockito.anyString()); this.mockMvc.perform(patch("/blogs/1?title=Spring实战")) .andExpect(status().isOk()); &#125; /** * 测试修改博客标题失败时的情况. * * @throws Exception 异常 */ @Test public void modifyTitileByIdWithException() throws Exception &#123; Mockito.doThrow(RuntimeException.class) .when(blogService).modifyTitileById(Mockito.anyString(), Mockito.anyString()); this.mockMvc.perform(patch("/blogs/1?title=Spring实战")) .andExpect(status().is5xxServerError()); &#125;&#125; 以上就完成了对 Controller 层的单元测试。 总结在 Spring Boot 中做单元测试的将会非常容易。上面只是 Spring Boot 中提供的部分方式，Spring Boot 文档 中还有其他更多的测试场景和测试方法供你去参考和使用。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>单元测试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码性能评估库Stalker介绍]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E5%BA%93Stalker%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[English Document 这是一个简单的用来对Java代码做性能评估的工具库。 特性 轻量级（jar包仅26kb） API简单易用 易于集成或扩展 Maven集成12345&lt;dependency&gt; &lt;groupId&gt;com.blinkfox&lt;/groupId&gt; &lt;artifactId&gt;stalker&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; API 介绍和使用预先准备在对Java方法做性能测试之前，先准备好待测试的类和方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 用于测量（仅测试使用）该类中的方法的执行耗时的类. * * @author blinkfox on 2019-02-03. */public class MyTestService &#123; private static final Logger log = LoggerFactory.getLogger(MyTestService.class); /** * 测试方法1，模拟业务代码耗时 2~5 ms，且会有约 1% 的几率执行异常. */ public void hello() &#123; // 模拟运行时抛出异常. if (new Random().nextInt(100) == 5) &#123; throw new MyServiceException("My Service Exception."); &#125; // 模拟运行占用约 2~5 ms 的时间. this.sleep(2L + new Random().nextInt(3)); &#125; /** * 测试方法2，模拟业务代码运行占用约 2 ms 的时间. */ public void fastHello() &#123; this.sleep(2L); &#125; /** * 本线程调用该方法时，睡眠指定时间，用来模拟业务耗时. * * @param time 时间 */ private void sleep(long time) &#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; log.info("InterruptedException", e); Thread.currentThread().interrupt(); &#125; &#125;&#125; Stalker类1. 最简示例以下代码将会预热5次，然后在单线程下正式执行10次，从而将运行结果计算统计并输出出来： 123public static void main(String[] args) &#123; Stalker.run(() -&gt; new MyTestService().hello());&#125; 以上结果将默认在控制台输出： 1234567+-----------------------------------------------------------------------------------------------------------------------------------------+| threads: 1, concurrens: 1, warmups:5, runs: 10, printErrorLog: false |+---+----------+-------+---------+---------+----------+---------+---------+---------+---------+---------------------+---------------------+| | Costs | Total | Success | Failure | Sum | Avg | Min | Max | StdDev | 95% LowerConfidence | 95% UpperConfidence |+---+----------+-------+---------+---------+----------+---------+---------+---------+---------+---------------------+---------------------+| 1 | 35.33 ms | 10 | 10 | 0 | 35.29 ms | 3.53 ms | 2.56 ms | 4.81 ms | 0.85 ms | 3.0 ms | 4.06 ms |+---+----------+-------+---------+---------+----------+---------+---------+---------+---------+---------------------+---------------------+ 2. 更全示例以下代码表示，两个方法hello()和fastHello()将会预热1000次，在1000个线程200个并发下，每次执行10次： 123Stalker.run(Options.of(1000, 200).warmups(1000).runs(10), () -&gt; new MyTestService().hello(), () -&gt; new MyTestService().fastHello()); 以上结果将默认在控制台输出： 12345678+------------------------------------------------------------------------------------------------------------------------------------------+| threads: 1000, concurrens: 200, warmups:1000, runs: 10, printErrorLog: false |+---+-----------+-------+---------+---------+---------+---------+---------+----------+---------+---------------------+---------------------+| | Costs | Total | Success | Failure | Sum | Avg | Min | Max | StdDev | 95% LowerConfidence | 95% UpperConfidence |+---+-----------+-------+---------+---------+---------+---------+---------+----------+---------+---------------------+---------------------+| 1 | 454.33 ms | 10000 | 9900 | 100 | 36.79 s | 3.72 ms | 2.01 ms | 11.89 ms | 1.31 ms | 3.69 ms | 3.74 ms || 2 | 159.94 ms | 10000 | 10000 | 0 | 21.72 s | 2.17 ms | 2.01 ms | 3.24 ms | 0.15 ms | 2.17 ms | 2.18 ms |+---+-----------+-------+---------+---------+---------+---------+---------+----------+---------+---------------------+---------------------+ 结果说明： Costs: 实际正式运行所消耗的总时间 Total: 正式运行的总次数 Success: 正式运行的成功次数 Failure: 正式运行的失败次数 Sum: 每次运行的耗时结果求和之后的值 Avg: 所有运行耗时结果的算术平均数 Min: 所有运行耗时结果中最小值 Max: 所有运行耗时结果中最大值 StdDev: 所有运行耗时结果的标准方差 95% LowerConfidence: 95%置信区间的最小边界值 95% LowerConfidence: 95%置信区间的最大边界值 3. 主要方法 void run(Runnable... runnables): 对若干个要执行的代码做性能测量评估. void run(Options options, Runnable... runnables): 通过自定义的Options对若干个要执行的代码做性能测量评估. Options类Options表示做性能测量时的选项参数 主要属性如下 name: 选项参数的名称 threads: 正式执行的线程数，默认为1。 concurrens: 正式多线程下执行的并发数，默认为1。 warmups: 单线程下的预热次数，默认5。 runs: 每个线程正式执行的次数，默认10。 printErrorLog: 是否打印错误日志，默认false。 outputs: 将测量结果通过多种方式(集合)输出出来，默认为输出到控制台，可自定义实现MeasureOutput接口。 主要方法以下是构造Options实例的若干重载方法： Options of(String name) Options of(int runs) Options of(String name, int runs) Options of(int threads, int concurrens) Options of(String name, int threads, int concurrens) Options of(String name, int threads, int concurrens, int runs) 其他方法： boolean valid(): 校验Options相关参数是否合法 Options named(String name): 设置 Options 实例的 name 属性 Options threads(int threads): 设置 Options 实例的 threads 属性 Options concurrens(int concurrens): 设置 Options 实例的 concurrens 属性 Options warmups(int warmups): 设置 Options 实例的 warmups 属性 Options runs(int runs): 设置 Options 实例的 runs 属性 Options printErrorLog(boolean printErrorLog): 设置 Options 实例的 printErrorLog 属性 Options outputs(MeasureOutput... measureOutputs): 自定义设置 Options 实例的 MeasureOutput 输出通道 Assert类Assert类主要用来做断言使用。 示例123Assert.assertFaster(Options.of(), () -&gt; new MyTestService().fastHello(), () -&gt; new MyTestService().hello()); 许可证本 stalker 类库遵守 Apache License 2.0 许可证。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个极简的 Java ASCII 表格生成库]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%90%8E%E7%AB%AF%2FJava%2F%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84%20Java%20ASCII%20%E8%A1%A8%E6%A0%BC%E7%94%9F%E6%88%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[一个轻量级、零依赖的 Java ASCII 表格生成库。 特性 轻量级、无依赖（jar包仅9kb） API简单易用 易于集成或定制修改，仅一个Java文件，且代码规范 集成使用Maven集成12345&lt;dependency&gt; &lt;groupId&gt;com.blinkfox&lt;/groupId&gt; &lt;artifactId&gt;mini-table&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; API 使用示例1（无标题）123456String table = new MiniTable() .addHeaders("header1", "header2") .addDatas("col11", "col12") .addDatas("col21", "col22") .render();System.out.println(table); 输出结果: 123456+---------+---------+| header1 | header2 |+---------+---------+| col11 | col12 || col21 | col22 |+---------+---------+ 示例2（有标题）1234567String table = new MiniTable("The Title") .addHeaders("Name", "Sex", "Age", "Email", "Phone") .addDatas("LiLei", "male", 25, "lilei@gmail.com", "13809345219") .addDatas("hanMeiMei", "female", 23, "hmm@163.com", "13515343853") .addDatas("ZhangSan", "female", 32, "zhangsan@gmail.com", "13920199836") .render();System.out.println(table); 输出结果: 123456789+-------------------------------------------------------------+| The Title |+-----------+--------+-----+--------------------+-------------+| Name | Sex | Age | Email | Phone |+-----------+--------+-----+--------------------+-------------+| LiLei | male | 25 | lilei@gmail.com | 13809345219 || hanMeiMei | female | 23 | hmm@163.com | 13515343853 || ZhangSan | female | 32 | zhangsan@gmail.com | 13920199836 |+-----------+--------+-----+--------------------+-------------+ 许可证本 mini-table 类库遵守 Apache License 2.0 许可证。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之桥接模式]]></title>
    <url>%2F2018%2F12%2F19%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式动机设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案： 第一种设计方案是为每一种形状都提供一套各种颜色的版本。 第二种设计方案是根据实际需要对形状和颜色进行组合 对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。 模式定义 桥接模式(Bridge Pattern)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。 模式角色桥接模式包含如下角色： Abstraction：抽象类角色 RefinedAbstraction：扩充抽象类 Implementor：实现化角色 ConcreteImplementor：具体实现化角色的实现类 UML类图 代码示例首先，是实现化角色Abstraction类： 123456789101112131415161718/** * 实现化角色 Implementor. * * @author blinkfox on 2018-12-17. */public interface Implementor &#123; /** * 基本方法1. */ void doSomething(); /** * 基本方法2. */ void doAnything();&#125; 然后，是各个具体的实现化角色类： 123456789101112131415161718192021222324/** * ConcreteImplementor1. * * @author blinkfox on 2018-12-17. */public class ConcreteImplementor1 implements Implementor &#123; /** * 基本方法1. */ @Override public void doSomething() &#123; System.out.println("ConcreteImplementor1 的业务逻辑 doSomething."); &#125; /** * 基本方法2. */ @Override public void doAnything() &#123; System.out.println("ConcreteImplementor1 的业务逻辑 doAnything."); &#125;&#125; 123456789101112131415161718192021222324/** * ConcreteImplementor2. * * @author blinkfox on 2018-12-17. */public class ConcreteImplementor2 implements Implementor &#123; /** * 基本方法1. */ @Override public void doSomething() &#123; System.out.println("ConcreteImplementor2 的业务逻辑 doSomething."); &#125; /** * 基本方法2. */ @Override public void doAnything() &#123; System.out.println("ConcreteImplementor2 的业务逻辑 doAnything."); &#125;&#125; 接下来，是抽象类角色Abstraction类： 1234567891011121314151617181920212223242526272829303132333435363738package com.blinkfox.patterns.bridge;/** * 抽象化角色 Abstraction. * * @author blinkfox on 2018-12-17. */public abstract class Abstraction &#123; /** 定义对实现化角色的引用. */ private Implementor impl; /** * 构造方法. * * @param impl 实现类的实例 */ public Abstraction(Implementor impl) &#123; this.impl = impl; &#125; /** * impl 的 getter方法. * * @return impl */ public Implementor getImpl() &#123; return impl; &#125; /** * 自身的请求处理方法. */ public void request() &#123; this.impl.doSomething(); &#125;&#125; 再次，是扩展的具体抽象化角色类RefinedAbstraction： 123456789101112131415161718192021222324252627/** * RefinedAbstraction. * * @author blinkfox on 2018-12-17. */public class RefinedAbstraction extends Abstraction &#123; /** * 构造方法. * * @param impl 实现类的实例 */ public RefinedAbstraction(Implementor impl) &#123; super(impl); &#125; /** * 覆盖后的请求处理方法. */ @Override public void request() &#123; System.out.println("RefinedAbstraction 开始做业务处理."); super.request(); super.getImpl().doAnything(); &#125;&#125; 最后，是客户端场景类： 1234567891011121314151617181920/** * Client. * * @author blinkfox on 2018-12-17. */public class Client &#123; /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; // 定义一个实现化角色和抽象化角色,并执行请求方法. Implementor impl = new ConcreteImplementor1(); Abstraction abs = new RefinedAbstraction(impl); abs.request(); &#125;&#125; 模式分析理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 优点桥接模式的优点: 分离抽象接口及其实现部分。 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 实现细节对客户透明，可以对用户隐藏实现细节。 缺点桥接模式的缺点: 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。 适用环境在以下情况下可以使用桥接模式： 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 模式应用一个Java桌面软件总是带有所在操作系统的视感(LookAndFeel)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是Motif用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在Macintosh上面使用的用户看到的则是Macintosh用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。 模式扩展适配器模式与桥接模式的联用: 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。 总结 桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。 桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。 在桥接模式中，抽象化(Abstraction)与实现化(Implementation)脱耦，它们可以沿着各自的维度独立变化。 桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。 桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。 参考自：桥接模式]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之适配器模式]]></title>
    <url>%2F2018%2F12%2F12%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式动机 在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种结构型模式。 模式结构参与角色适配器模式包含如下角色： Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 Client：客户类 UML类图 代码示例首先，是目标角色接口和具体目标实现类： 12345678910111213/** * Target 目标角色类. * * @author blinkfox on 2018-12-11. */public interface Target &#123; /** * 目标角色自己的方法. */ void request();&#125; 12345678910111213141516/** * 具体的目标角色实现类. * * @author blinkfox on 2018-12-11. */public class ConcreteTarget implements Target &#123; /** * 目标角色自己的方法. */ @Override public void request() &#123; System.out.println("hello, I'm concrete target method."); &#125;&#125; 其次，是适配者类： 123456789101112131415/** * 适配者类. * * @author blinkfox on 2018-12-11. */public class Adaptee &#123; /** * 这是原有的业务逻辑方法. */ public void doSomething() &#123; System.out.println("Hello, I'm Adaptee method."); &#125;&#125; 然后，是适配器角色类： 1234567891011121314151617/** * 适配器类. * * @author blinkfox on 2018-12-11. */public class Adapter extends Adaptee implements Target &#123; /** * 适配了目标角色自己的方法. */ @Override public void request() &#123; super.doSomething(); System.out.println("适配器适配了目标角色方法."); &#125;&#125; 最后，是客户端场景类： 1234567891011121314151617181920212223/** * 客户端场景类. * * @author blinkfox on 2018-12-11. */public class Client &#123; /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; // 原有业务逻辑. Target target = new ConcreteTarget(); target.request(); // 增加了适配器角色后的业务逻辑. Target adaptTarget = new Adapter(); adaptTarget.request(); &#125;&#125; 模式分析适用环境在以下情况下可以使用适配器模式： 系统需要使用现有的类，而这些类的接口不符合系统的需要。 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 缺点如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 模式应用Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。 总结 结构型模式描述如何将类或者对象结合在一起形成更大的结构。 适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。 在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。 适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。 参考自：适配器模式]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件程序设计原则]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[一、前言软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。 软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点： 僵化：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能 脆弱：每当你做一次改动，总会引起系统中预期之外的部分出现故障 死板：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来 下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。 二、通用设计原则1. KISS所谓KISS原则，即：Keep It Simple,Stupid，指设计时要坚持简约原则，避免不必要的复杂化，并且易于修改。 Everything should be made as simple as possible, but not simpler. - Albert Einstein 简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。 让别的软件工程师以一种最容易的方式使用你的方案。 简单不是走捷径，不是为手边的问题找一个最快的方案。 当系统变得更庞大更复杂的时候依然能够被理解。 如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。 我的理解：保持简单但不能掩盖软件丰富的内涵。即简约而不简单！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。 2. DRY所谓DRY原则，即：Don&#39;t Repeat Yourself，不要让自己重复。 重复代码是软件程序变烂的万恶之首。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。 所以，去掉重复的信息会让你的代码结构发生本质的变化。 “重复代码”有很多变体： 魔法数字、魔法字符串等 相同代码块 相似的代码逻辑及操作 对于消除重复的代码有事不过三法则。 第一次先写了一段代码。 第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。 再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。 我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。 3. Maximize Cohesion， Minimize Coupling所谓Maximize Cohesion,Minimize Coupling原则，即：高内聚低耦合。这是判断设计好坏的标准，主要是看模块内的内聚性是否高，模块间的耦合度是否低。 耦合性：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 内聚性：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 Java中实现高内聚低耦合的常用方式： 少使用类的继承，多用接口隐藏实现的细节。 模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。 遵循一个定义只在一个地方出现。 少使用全局变量。 类属性和方法的声明少用public，多用private关键字， 多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。 尽量不用“硬编码”的方式写程序。 最后当然就是避免直接操作或调用其它模块或类（内容耦合）。 4. SOC所谓SOC原则，即：关注点分离（Separation of Concerns）。不同领域的功能，应该由不同的代码和最小重迭的模块组成。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。 MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构： Model层表示应用程序的数据核心，通常负责在数据库中存取数据。 View是应用程序的显示层，通常是依据模型的数据而建立。 Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。 MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。 好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》) 分离方式下面将介绍一些分层的思想和方式: 纵向分离: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。 横向分离: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。 切面分离: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。 依赖方向分离: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。 关注数据分离: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。 关注行为分离: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。 扩展分离: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。 反转分离: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系。 5. YAGNI所谓YAGNI原则，即：You Ain’t Gonna Need It，你不需要它。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该为了眼前的需求做设计而不是未来。 只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries 即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因： 你节约了时间，因为你避免了编写最终证明不必要的代码。 你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。 我的理解：YAGNI 原则，本质上是告诫我们写代码不要画蛇添足，否则就会弄巧成拙了。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。 6. Boy-Scout RuleBoy-Scout Rule，译为：童子军规则。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。 童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。 关于童子军规则中所提倡的对代码坏味道的尽早修复，我也想起来了我们所熟知的“破窗效应”和“讳疾忌医”的典故： 破窗效应 如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论 “环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。” “这个代码以前的其他人也都是这样写的。” “反正也不是只有我才这么写代码的。” 不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之。 讳疾忌医的典故 《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。 代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。 所以，请记住童子军规则对我们的启示：始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治。 其他原则： 避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth 最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。 代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。 别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。 为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。” 正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。 做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。 隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。 科里定律(Curly&#39;s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。 墨菲定律（Murphy&#39;s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下： 任何事都没有表面看起来那么简单； 所有的事都会比你预计的时间长； 会出错的事总会出错； 如果你担心某种情况发生，那么它就更有可能发生。 三、面向对象设计原则1. SRP所谓SRP原则，即：Single Responsibility Principle，单一职责原则。原始定义如下： There should never be more than one reason for a class to change.(只有一个引起类改变的原因) 在面向对象编程领域中，单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 单一职责的好处： 类的复杂性降低，实现什么职责都有清晰明确的定义; 可读性提高，复杂性降低，可维护性提高; 变更引起的风险降低。 单一职责原则的注意点： 单一职责最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。 2. LSP所谓LSP原则，即：Liskov Substitution principle，里氏替换原则。原始定义如下： Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象） 更通俗的定义即为：子类可以扩展父类的功能，但不能改变父类原有的功能。里氏替换原则包含了一下4层含义： 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。 覆盖或实现父类的方法时输出结果可以被缩小。 优点： 提高代码的重用性，子类拥有父类的方法和属性； 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 缺点： 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。 3. ISP所谓ISP原则，即：Interface Segregation Principle，接口隔离原则。原始定义如下： Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。) The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。) 即，接口尽量细化，接口中的方法尽量少。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 4. OCP所谓OCP原则，即：Open Closed Principle，开闭原则。原始定义如下： software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭) 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：对扩展开放，对修改关闭。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。 软件系统中包含的各种组件，例如模块（Module）、类（Class）以及功能（Function）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。 实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。 开闭原则的好处： 可复用性好; 可维护性好。 5. DIP所谓DIP原则，即：Dependency Inversion Principle，依赖倒置原则。原始定义如下： High-level modules should not depend on low-level modules. Both should depend on abstractions.(高层模块不应该依赖低层模块，两者都应该依赖其抽象) Abstractions should not depend on details. Details should depend on abstractions.(抽象不应该依赖细节；细节应该依赖抽象) 面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。 依赖倒置原则主要有以下三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）； 抽象不应该依赖细节（具体实现）； 细节（具体实现）应该依赖抽象。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想就是面向接口编程。 6. LOD | LKP所谓LOD原则，即：Law of Demeter，迪米特法则，又叫最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下： talk only to your immediate friends.(只与直接的朋友通信) 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。 7. CRP所谓CRP原则，即：Composite Reuse Principle，组合复用原则。 组合复用原则的核心思想是：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。 继承的缺点主要有以下几点： 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。 基类的实现发生了改变，派生类的实现也不得不改变。 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。 由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处： 新对象存取组成对象的唯一方法是通过组成对象的getter/setter方法。 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。 组合复用所需要的依赖较少。 每一个新的类可以将焦点集中到一个任务上。 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。 组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。 组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 使用继承时必须满足Is-A的关系是才能使用继承，而组合却是一种Has-A的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把Has-A当成了Is-A。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab CI/CD 介绍和使用]]></title>
    <url>%2F2018%2F11%2F22%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2Fdevops%2FGitLab%20CI%20%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、持续集成介绍 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。—— Martin Fowler 1 概念 持续集成(Continuous Integration)：频繁地(一天多次)将代码集成到主干。让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。” 持续交付(Continuous Delivery)：频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续部署(continuous Deployment)：代码通过评审以后，自动部署到生产环境。是持续部署是持续交付的下一步，持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 2 持续集成的好处 自动化构建且状态对每个人可见。可以使用Maven、Gradle等来实现自动化构建，可以在构建过程中实现自动化测试（前提是有写单元测试用例）。集成服务器在持续集成过程中发现问题可以及时发送警告给相关的干系人。 解放了重复性劳动。自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。 更快地发现和修复问题。持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。 更快的交付成果。更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。 减少手工的错误。在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。 减少了等待时间。缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。 更高的产品质量。集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。 3 常用持续集成工具 Jenkins GitLab CI TeamCity Travis CI Bamboo CircleCI … 二、Gitlab 持续集成 1 概念介绍(1) GitLabGitLab 是一个利用Ruby on Rails开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。 (2) GitLab CI/CDGitLab CI/CD 是GitLab Continuous Integration（Gitlab持续集成）的简称。GitLab 自GitLab 8.0开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次push或者合并请求（Merge Request）都会触发CI Pipeline。 (3) GitLab RunnerGitLab Runner GitLab Runner是一个开源项目，可以运行在 GNU / Linux，macOS 和 Windows 操作系统上。每次push的时候 GitLab CI 会根据.gitlab-ci.yml配置文件运行你流水线（Pipeline）中各个阶段的任务（Job），并将结果发送回 GitLab。GitLab Runner 是基于 Gitlab CI 的 API 进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和 Gitlab 安装在同一台机器上，且考虑到 GitLab Runner 的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。 Gitlab Runner 分为三种： 共享Runner(Shared runners) 专享Runner(Specific runners) 分组Runner(Group Runners) (4) PipelinesPipelines 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次push或者Merge Request都会触发生成一条新的Pipeline。 下面是流水线示例图： (5) StagesStages 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点： 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在.gitlab-ci.yml文件中配置上一阶段失败时下一阶段也执行） 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 下面是一个流水线内的阶段任务示例图： (6) JobsJobs 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点： 相同 Stage 中的 Jobs 无执行顺序要求，会并行执行 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在.gitlab-ci.yml文件中配置允许某 Job 可以失败，也算该 Stage 成功） (7) .gitlab-ci.ymlGitLab 中默认开启了 Gitlab CI/CD 的支持，且使用YAML文件.gitlab-ci.yml来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在.gitlab-ci.yml配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。 下面是.gitlab-ci.yml文件的一个简单的Hello World示例： 123456789101112131415161718# 定义 test 和 package 两个 Stagesstages: - test - package# 定义 package 阶段的一个 jobpackage-job: stage: package script: - echo "Hello, package-job" - echo "I am in package stage"# 定义 test 阶段的一个 jobtest-job: stage: test script: - echo "Hello, test-job" - echo "I am in test stage" 以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的script关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。 注：猜猜上面例子的运行结果？ (8) BadgesBadges 即：徽章，当 Pipelines 执行过程中或者执行完成时会生成徽章，你可以将这些徽章加入到你的README.md文件中，便于从仓库主页看到最新的构建状态。 徽章的链接形如下： 1http://example.gitlab.com/namespace/project/badges/branch/build.svg 我们用 GitLab 项目的徽章作为例子，效果如下： 2 安装 GitLab Runner这里有 GitLab Runner安装相关的资源和文档可供大家参考。以下仅以咱们公司常用的Centos为例来做安装说明。 (1) 在线安装12345# 添加官方的repo.curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash# yum 安装Gtilab Runner.sudo yum install gitlab-runner (2) 离线安装12345# 安装Gitsudo yum –y install git# rpm离线安装事先下载好的 Gitlab Runner rpm包.rpm -ivh gitlab-runner-10.5.0-1.x86_64.rpm 注：Gitlab Runner 依赖了Git，所以，离线安装 Gitlab Runner 之前得首先安装Git，离线安装包可以从这里下载。 3 注册 Gitlab Runner安装了 GitLab Runner 之后,就可以为 GitLab 中的仓库注册一个 Runner，注册的交互式命令如下： 1sudo gitlab-runner register 命令的交互式的过程如下： 12345678910111213141516171819202122# 输入注册命令sudo gitlab-runner register# 输入公司的 GitLab 网站地址Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )http://gitlab.xxxx.com/# 你项目仓库的token，token可以在 Settings -&gt; CI/CD -&gt; Runners settings 中找到.Please enter the gitlab-ci token for this runnerxxx# 输入描述这个 runner 的名称Please enter the gitlab-ci description for this runner[hostame] my-runner# 输入 runner 的标签Please enter the gitlab-ci tags for this runner (comma separated):my-tag,another-tag# 输入 runner 的执行器.Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell 以上流程注册成功之后，就可以在你的项目仓库中 Settings -&gt; CI/CD -&gt; Runners settings 看到这个 Runner 了。 4 Gitlab Runner 常用命令汇总下面的表格中列出了一些常用的Gitlab Runner命令，以供参考： 命令 描述 gitlab-runner run 运行一个runner服务 gitlab-runner register 注册一个新的runner gitlab-runner start 启动服务 gitlab-runner stop 关闭服务 gitlab-runner restart 重启服务 gitlab-runner status 查看各个runner的状态 gitlab-runner unregister 注销掉某个runner gitlab-runner list 显示所有运行着的runner gitlab-runner verify 检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。 三、一个Web项目 CI/CD 简单示例接下来，用一个实际项目来演示 GitLab CI/CD 的配置和使用，其中主要包括：编译测试、项目打包、部署服务、Sonar手动检查、Sonar定时检查五个阶段。 下面用一个传统的 Java web 项目(这里称之为cidemo)和Tomcat来作为示例，并用来展示常用配置的使用。当我每次push代码或者Merge Request时，都会生成一条流水线，且会自动执行我们上面所说的一些阶段，而Sonar手动检查我们设置为手动操作，且再额外配置Sonar定时检查的任务。 注：我 Gitlab Runner 是安装在Centos环境中，并使用的shell执行器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 定义stagesstages: - test - install - run - sonar# 定义安装包的存放位置和Tomcat服务器的地址的变量，便于后续部署使用.variables: CIDEMO_PACKAGE_DIR: '/home/gitlab-runner/packages/cidemo/' SERVER_HOME_DIR: '/home/gitlab-runner/tomcat/cidemo-tomcat/'###################### 构建编译和单元测试的job. #######################编译测试任务: stage: test only: - branches script: - mvn clean test###################### Maven安装得到war包的job. #######################打包任务: stage: install only: - develop script: - mvn install - echo '准备将最新的war包复制、保存到某个目录里面供后续使用.' - rm -rf $CIDEMO_PACKAGE_DIR/*.war - cp target/*.war $CIDEMO_PACKAGE_DIR/cidemo.war####################### 部署运行war包的job. #######################部署运行任务: stage: run only: - develop script: - echo '准备部署和运行war包！(为了方便部署到了Tomcat中运行)' - cd $SERVER_HOME_DIR - sh bin/shutdown.sh - rm -rf webapps/cidemo.war - cp $CIDEMO_PACKAGE_DIR/cidemo.war $SERVER_HOME_DIR/webapps/cidemo.war - nohup sh ./bin/startup.sh &gt; logs/cidemo_nohup.log 2&gt;&amp;1 &amp;###################### Sonar手动构建的job. #######################Sonar手动检查: stage: sonar when: manual only: - develop script: - echo '准备对项目代码做sonar的质量检查！' - mvn compile &amp;&amp; mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34###################### Sonar每晚定时构建的job. #######################Sonar定时检查: stage: sonar only: - schedules script: - echo '开始定时对项目代码做sonar的质量检查！' - mvn compile &amp;&amp; mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34 四、Gitlab CI/CD yaml 常用配置介绍开始构建之前.gitlab-ci.yml文件定义了一系列带有约束说明的任务。这些任务都是以任务名开始并且至少要包含script部分，.gitlab-ci.yml允许指定无限量 jobs。每个 jobs 必须有一个唯一的名字，且名字不能是下面列出的保留字段： image services stages types before_script after_script variables cache job由一列参数来定义 jobs 的行为： Keyword Required Description script yes Runner执行的命令或脚本 extends no 定义此作业将继承的配置条目 image no 所使用的docker镜像，查阅使用docker镜像 services no 所使用的docker服务，查阅使用docker镜像 stage no 定义job stage（默认：test） type no stage的别名（已弃用） variables no 定义job级别的变量 only no 定义一列git分支，并为其创建job except no 定义一列git分支，不创建job tags no 定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags） allow_failure no 允许job失败。失败的job不影响commit状态 when no 定义何时开始job。可以是on_success，on_failure，always或者manual dependencies no 定义job依赖关系，这样他们就可以互相传递artifacts cache no 定义应在后续运行之间缓存的文件列表 before_script no 重写一组在作业前执行的命令 after_script no 重写一组在作业后执行的命令 environment no 定义此作业完成部署的环境名称 coverage no 定义给定作业的代码覆盖率设置 etry no 定义在发生故障时可以自动重试作业的时间和次数 parallel no 定义应并行运行的作业实例数 extends 是在 GitLab 11.3 中引入的。 extends定义了一个使用extends的作业将继承的条目名称。它是使用YAML锚点的替代方案，并且更加灵活和可读： 12345678910111213.tests: script: rake test stage: test only: refs: - branchesrspec: extends: .tests script: rake rspec only: variables: - $RSPEC 在上面的示例中，rspec作业继承自.tests模板作业。 GitLab 将根据键执行反向深度合并。 GitLab将： 将rspec内容以递归方式合并到.tests中。 不合并键的值。 这实际生成的是以下rspec作业： 12345678rspec: script: rake rspec stage: test only: refs: - branches variables: - $RSPEC 注: rake test已被rake rspec脚本覆盖。 image 和 services这两个关键字允许使用一个自定义的 Docker 镜像和一系列的服务，并且可以用于整个 job 周期。详细配置文档请查看a separate document。 before_script 和 after_scriptbefore_script用来定义所有 job 之前运行的命令，after_script用来定义所有 job 之后运行的命令。它们可以是一个数组或者是多行字符串。 stagesstages 用来定义可以被 job 调用的 stages。stages 的规范允许有灵活的多级 pipelines。 stages中的元素顺序决定了对应job的执行顺序： 相同 stage 的 job 可以平行执行。 下一个 stage 的 job 会在前一个 stage 的 job 成功后开始执行。 接下仔细看看这个例子，它包含了3个 stage： 1234stages: - build - test - deploy 首先，所有 build 的 jobs 都是并行执行的。 所有 build 的 jobs 执行成功后，test 的 jobs 才会开始并行执行。 所有 test 的 jobs 执行成功，deploy 的 jobs 才会开始并行执行。 所有的 deploy 的 jobs 执行成功，commit才会标记为success。 任何一个前置的 jobs 失败了，commit会标记为failed并且下一个 stages 的 jobs 都不会执行。 这有两个特殊的例子值得一提： 如果.gitlab-ci.yml中没有定义stages，那么 job’s stages 会默认定义为build，test和deploy。 如果一个 job 没有指定 stage，那么这个任务会分配到 test stage。 only 和 exceptonly和except是两个参数用分支策略来限制 jobs 构建： only定义哪些分支和标签的git项目将会被job执行。 except定义哪些分支和标签的git项目将不会被job执行。 下面是refs策略的使用规则： only 和 except 可同时使用。如果only和except在一个 job 配置中同时存在，则以 only 为准，跳过 except(从下面示例中得出)。 only 和 except 可以使用正则表达式。 only 和 except 允许使用特殊的关键字：branches，tags和triggers。 only 和 except 允许使用指定仓库地址但不是forks的仓库(查看示例3)。 在下面这个例子中，job 将只会运行以issue-开始的refs(分支)，然而except中设置将被跳过。 1234567job: # use regexp only: - /^issue-.*$/ # use special keyword except: - branches 在下面这个例子中，job 将只会执行有tags的refs，或者通过API触发器明确地请求构建。 12345job: # use special keywords only: - tags - triggers 下面这个例子将会为所有的分支执行job，但 master 分支除外。 12345job: only: - branches@gitlab-org/gitlab-ce except: - master@gitlab-org/gitlab-ce variablesGItLab CI 允许在.gitlab-ci.yml文件中添加变量，并在 job 环境中起作用。因为这些配置是存储在 git 仓库中，所以最好是存储项目的非敏感配置，例如： 12variables: DATABASE_URL:"postgres://postgres@postgres/my_database" 这些变量可以被后续的命令和脚本使用。 除了用户自定义的变量外，Runner 也可以定义它自己的变量。CI_COMMIT_REG_NAME就是一个很好的例子，它的值表示用于构建项目的分支或tag名称。除了在.gitlab-ci.yml中设置变量外，还有可以通过 GitLab 的界面上设置私有变量。 这里有更多关于variables的介绍。 cachecache: paths使用paths指令选择要缓存的文件或目录。也可以使用通配符。 如果 cache 定义在 jobs 的作用域之外，那么它就是全局缓存，所有 jobs 都可以使用该缓存。 缓存binaries和.config中的所有文件： 123456rspec: script: test cache: paths: - binaries/ - .config 缓存git中没有被跟踪的文件： 1234rspec: script: test cache: untracked: true 缓存binaries下没有被git跟踪的文件： 123456rspec: script: test cache: untracked: true paths: - binaries/ job 中优先级高于全局的。下面这个rspec job中将只会缓存binaries/下的文件： 12345678910cache: paths: - my/filesrspec: script: test cache: key: rspec paths: - binaries/ 注意，缓存是在 jobs 之前进行共享的。如果你不同的 jobs 缓存不同的文件路径，必须设置不同的cache:key，否则缓存内容将被重写。缓存只是尽力而为之，所以别期望缓存会一直存在。 cache: keykey指令允许我们定义缓存的作用域(亲和性)，可以是所有 jobs 的单个缓存，也可以是每个 job，也可以是每个分支或者是任何你认为合适的地方。它也可以让你很好的调整缓存，允许你设置不同 jobs 的缓存，甚至是不同分支的缓存。 cache:key可以使用任何的预定义变量。 默认key是默认设置的这个项目缓存，因此默认情况下，从GitLab 9.0开始，每个 pipelines 和 jobs 中可以共享一切。 配置示例 缓存每个job： 123cache: key: "$CI_JOB_NAME" untracked: true 缓存每个分支： 123cache: key: "$CI_COMMIT_REF_NAME" untracked: true 缓存每个 job 且每个分支： 123cache: key: "$CI_JOB_NAME/$CI_COMMIT_REF_NAME" untracked: true 缓存每个分支且每个stage： 123cache: key: "$CI_JOB_STAGE/$CI_COMMIT_REF_NAME" untracked: true 如果使用的Windows Batch(windows批处理)来跑脚本需要用%替代$： 123cache: key: "%CI_JOB_STAGE%/%CI_COMMIT_REF_NAME%" untracked: true allow_failureallow_failure可以用于当你想设置一个 job 失败的之后并不影响后续的CI组件的时候。失败的 jobs 不会影响到commit状态。 当开启了允许 job 失败，所有的 intents 和 purposes 里的 pipeline 都是成功/绿色，但是也会有一个”CI build passed with warnings“信息显示在Merge Request或commit或job page。这被允许失败的作业使用，但是如果失败表示其他地方应采取其他（手动）步骤。 下面的这个例子中，job1和job2将会并列进行，如果job1失败了，它也不会影响进行中的下一个 stage，因为这里有设置了allow_failure: true。 123456789101112131415job1: stage: test script: - execute_script_that_will_fail allow_failure: truejob2: stage: test script: - execute_script_that_will_succeedjob3: stage: deploy script: - deploy_to_staging whenwhen用于实现在发生故障或尽管失败时运行的作业。when可以设置以下值： on_success - 只有前面 stages 的所有工作成功时才执行。这是默认值。 on_failure - 当前面 stages 中任意一个jobs失败后执行。 always - 无论前面 stages 中 jobs 状态如何都执行。 manual - 手动执行(GitLab8.10增加)。更多请查看手动操作。 artifactsartifacts用于指定成功后应附加到 job 的文件和目录的列表。只能使用项目工作间内的文件或目录路径。在job成功完成后artifacts将会发送到GitLab中，同时也会在 GitLab UI 中提供下载。如果想要在不通的 job 之间传递artifacts，请查阅依赖关系。以下是一些例子： 发送binaries和.config中的所有文件： 1234artifacts: paths: - binaries/ - .config 发送所有没有被Git跟踪的文件： 12artifacts: untracked: true 发送没有被Git跟踪和binaries中的所有文件： 1234artifacts: untracked: true paths: - binaries/ 五、其他相关内容1 API触发器 TriggersTriggers 可用于强制使用API调用重建特定分支，tag或commits。API的使用示例可以在Settings -&gt; CI/CD -&gt; Pipeline triggers中找到。 在triggers文档中查看更多。 2 配置定时任务GitLab CI 中可以在 GitLab Settings -&gt; CI/CD -&gt; Schedules中配置定时任务，点击New Schedule按钮，可以配置你流水线的定时执行任务，包括：描述信息、定时的Cron表达式、目标分支、变量等信息。 然后在需要定时执行的作业的only分支写上schedules即可。 3 校验 .gitlab-ci.ymlGitLab CI 的每个实例都有一个名为Lint的嵌入式调试工具。 你可以在 GitLab 实例的-/ci/lint下找到该链接。 4 配置邮件发送如果希望在每次构建完成后（或者在仅构建失败的情况下），想邮件发送给相关开发人员，则可以在 GitLab Settings -&gt; Integrations 中找到Pipelines emails，点击进去就可以配置邮件发送相关的内容了。 5 GitLab PagesGitLab Pages是用于托管静态文件的服务。而pages是一个特殊的job，用于将静态的内容上传到GitLab，可用于为您的网站提供服务。它有特殊的语法，因此必须满足以下两个要求： 任何静态内容必须放在public/目录下 artifacts必须定义在public/目录下 下面的这个例子是将所有文件从项目根目录移动到public/目录。.public工作流是cp，并且它不会循环复制public/本身。 1234567891011pages: stage: deploy script: - mkdir .public - cp -r * .public - mv .public public artifacts: paths: - public only: - master 更多内容请查看GitLab Pages用户文档。 6 跳过 jobs如果你的commit信息中包含[ci skip]或者[skip ci]，不论大小写，那么这个commit将会创建但是 jobs 也会跳过。 参考文档 官方文档地址 segmentfault yaml配置中文翻译]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>GitLab CI</tag>
        <tag>DevOps</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 文档风格的 Typora 主题]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FMarkdown%2FVue%20%E6%96%87%E6%A1%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%20Typora%20%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[typora-vue-theme 是 Typora Markdown 文档编辑器中一款类似Vue文档风格的主题。 简介Typora是一款支持实时预览的 Markdown 编辑器和阅读器，支持Windows、macOS、Linux三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。typora-vue-theme就是参考了Vue文档风格而开发的一个 Typora 自定义主题。 安装主题 下载本主题中的vue.css、vue-dark.css文件和包含字体的vue文件夹； 打开 Typora，点击“偏好设置” =&gt; “打开主题文件夹”按钮，将弹出 Typora 的主题文件夹； 将下载好的vue.css和vue-dark.css文件和包含字体的vue文件夹放到 Typora 的主题文件夹中； 关闭并重新打开 Typora，从菜单栏中选择 “主题” =&gt; “Vue” 或者 “Vue Dark” 即可。 效果图 Vue Dark 感谢: 本主题中的vue-dark.css来自typora-vue-dark-theme.]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU多级缓存]]></title>
    <url>%2F2018%2F11%2F18%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FCPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[一、什么是CPU缓存1. CPU缓存的来历众所周知,CPU是计算机的大脑，它负责执行程序的指令，而内存负责存数据, 包括程序自身的数据。在很多年前，CPU的频率与内存总线的频率在同一层面上。内存的访问速度仅比寄存器慢一些。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。所以，CPU的运算速度要比内存读写速度快很多，这样会使CPU花费很长的时间等待数据的到来或把数据写入到内存中。所以，为了解决CPU运算速度与内存读写速度不匹配的矛盾，就出现了CPU缓存。 2. CPU缓存的概念CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上。 为了简化与内存之间的通信，高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为缓存行(Cache Line)的固定大小的数据块组成的，典型的一行是64字节。 3. CPU缓存的意义CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。所以，缓存的意义满足以下两种局部性原理： 时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。 二、CPU的三级缓存1. CPU的三级缓存随着多核CPU的发展，CPU缓存通常分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存。 下面是三级缓存的处理速度参考表： 从CPU到 大约需要的CPU周期 大约需要的时间(单位ns) 寄存器 1 cycle L1 Cache ~3-4 cycles ~0.5-1 ns L2 Cache ~10-20 cycles ~3-7 ns L3 Cache ~40-45 cycles ~15 ns 跨槽传输 ~20 ns 内存 ~120-240 cycles ~60-120ns 下图是Intel Core i5-4285U的CPU三级缓存示意图： 就像数据库缓存一样，获取数据时首先会在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。 2. 带有高速缓存CPU执行计算的流程 程序以及数据被加载到主内存 指令和数据被加载到CPU的高速缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 目前流行的多级缓存结构如下图： 三、CPU缓存一致性协议(MESI)MESI（Modified Exclusive Shared Or Invalid）(也称为伊利诺斯协议，是因为该协议由伊利诺斯州立大学提出的）是一种广泛使用的支持写回策略的缓存一致性协议。为了保证多个CPU缓存中共享数据的一致性，定义了缓存行(Cache Line)的四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。 1. MESI协议中的状态CPU中每个缓存行（Caceh line)使用4种状态进行标记，使用2bit来表示: 状态 描述 监听任务 状态转换 M 修改 (Modified) 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 E 独享、互斥 (Exclusive) 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 当CPU修改该缓存行中内容时，该状态可以变成Modified状态 S 共享 (Shared) 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 当有一个CPU修改该缓存行时，其它CPU中该缓存行可以被作废（变成无效状态 Invalid）。 I 无效 (Invalid) 该Cache line无效。 无 无 注意：对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。 从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。 MESI状态转换图： 下图表示了当一个缓存行(Cache line)的调整的状态的时候，另外一个缓存行(Cache line)需要调整的状态。 状态 M E S I M × × × √ E × × × √ S × × √ √ I √ √ √ √ 举个示例： 假设cache 1 中有一个变量x = 0的 Cache line 处于S状态(共享)。那么其他拥有x变量的 cache 2、cache 3 等x的 Cache line调整为S状态（共享）或者调整为I状态（无效）。 2. 多核缓存协同操作(1) 内存变量假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、c。在主内存中定义了x的引用值为0。 (2) 单核读取执行流程是： CPU A发出了一条指令，从主内存中读取x。 从主内存通过 bus 读取到 CPU A 的缓存中（远端读取 Remote read）,这时该 Cache line 修改为 E 状态（独享）。 (3) 双核读取执行流程是： CPU A发出了一条指令，从主内存中读取x。 CPU A从主内存通过bus读取到 cache a 中并将该 Cache line 设置为E状态。 CPU B发出了一条指令，从主内存中读取x。 CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x存储于 cache a 和 cache b 中，x在 chche a 和 cache b 中都被设置为S状态(共享)。 (4) 修改数据执行流程是： CPU A 计算完成后发指令需要修改x. CPU A 将x设置为M状态（修改）并通知缓存了x的 CPU B, CPU B 将本地 cache b 中的x设置为I状态(无效) CPU A 对x进行赋值。 (5) 同步数据那么执行流程是： CPU B 发出了要读取x的指令。 CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享） CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。 3. CPU 存储模型简介MESI协议为了保证多个 CPU cache 中共享数据的一致性，定义了 Cache line 的四种状态，而 CPU 对 cache 的4种操作可能会产生不一致状态，因此 cache 控制器监听到本地操作和远程操作的时候，需要对地址一致的 Cache line 状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。 但是，缓存的一致性消息传递是要时间的，这就使得状态切换会有更多的延迟。某些状态的切换需要特殊的处理，可能会阻塞处理器。这些都将会导致各种各样的稳定性和性能问题。比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。因为这个等待远远比一个指令的执行时间长的多。所以，为了为了避免这种阻塞导致时间的浪费，引入了存储缓存(Store Buffer)和无效队列(Invalidate Queue)。 (1) 存储缓存在没有存储缓存时，CPU 要写入一个量，有以下情况： 量不在该 CPU 缓存中，则需要发送 Read Invalidate 信号，再等待此信号返回，之后再写入量到缓存中。 量在该 CPU 缓存中，如果该量的状态是 Exclusive 则直接更改。而如果是 Shared 则需要发送 Invalidate 消息让其它 CPU 感知到这一更改后再更改。 这些情况中，很有可能会触发该 CPU 与其它 CPU 进行通讯，接着需要等待它们回复。这会浪费大量的时钟周期！为了提高效率，可以使用异步的方式去处理：先将值写入到一个 Buffer 中，再发送通讯的信号，等到信号被响应，再应用到 cache 中。并且此 Buffer 能够接受该 CPU 读值。这个 Buffer 就是 Store Buffer。而不须要等待对某个量的赋值指令的完成才继续执行下一条指令，直接去 Store Buffer 中读该量的值，这种优化叫Store Forwarding。 (2) 无效队列同理，解决了主动发送信号端的效率问题，那么，接受端 CPU 接受到 Invalidate 信号后如果立即采取相应行动(去其它 CPU 同步值)，再返回响应信号，则时钟周期也太长了，此处也可优化。接受端 CPU 接受到信号后不是立即采取行动，而是将 Invalidate 信号插入到一个队列 Queue 中，立即作出响应。等到合适的时机，再去处理这个 Queue 中的 Invalidate 信号，并作相应处理。这个 Queue 就是Invalidate Queue。 四、乱序执行乱序执行（out-of-orderexecution）：是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据各电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路。 这好比请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好”春节”后再交给B写”联欢”，然后再由C写”晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。 但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按”春节联欢晚会”的顺序排好才能挂出去。 所以，CPU 为什么会有乱序执行优化？本质原因是CPU为了效率，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令。而且允许排在前面的长费时指令后于排在后面的指令执行完。 CPU 执行乱序主要有以下几种： 写写乱序(store store)：a=1;b=2; -&gt; b=2;a=1; 写读乱序(store load)：a=1;load(b); -&gt; load(b);a=1; 读读乱序(load load)：load(a);load(b); -&gt; load(b);load(a); 读写乱序(load store)：load(a);b=2; -&gt; b=2;load(a); 总而言之，CPU的乱序执行优化指的是处理器为提高运算速度而做出违背代码原有顺序的优化。 参考文章： 从Java视角理解系统结构（二）CPU缓存 CPU缓存一致性协议MESI]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>CPU缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试指南]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%90%8E%E7%AB%AF%2FJava%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一、必要性在我们公司中要做单元测试，确实比较难，因为公司缺少这种氛围，有也只是局部的，大多数工程师没有这方面的习惯和素养，很多人都是有一定的抵触的心理，经过我私下的了解大概有以下几种原因吧。 写单元测试太耗费时间了，项目要赶进度，编写单元测试会导致不能按时完成开发任务，导致项目延期； 做传统xx管理系统的项目，业务逻辑比较简单，主要就是对业务数据做增删改查，单元测试意义和价值不高； 公司有专门的测试人员，很多问题在集成测试时一定能发现。 以前项目上从没写过单元测试，没有经验，不知道怎么编写单元测试； 这其中对单元测试就有些误解了，单元测试有几个比较常见的典型场景： 开发前写单元测试，通过测试描述需求，即测试驱动开发。 在开发过程中及时得到反馈，提前规避隐患和发现问题。 应用于自动化构建或持续集成流程，对每次代码修改做回归测试。 作为重构的基础，验证重构是否可靠。 还有最重要的一点：编写单元测试的难易程度能够直接反应出代码的设计水平，能写出单元测试和写不出单元测试之间体现了编程能力上的巨大的鸿沟。无论是什么样的程序员，坚持编写一段时间的单元测试之后，都会明显感受到代码设计能力的巨大提升。 公司开发人员的代码质量往往不是很高，尤其是对代码的拆分和逻辑的抽象还处于懵懂阶段。要对这类代码写单测，即使是工作了3，4年的高级码农也是一个挑战，对新人来说几乎是不可能完成的任务。这也让很多开发人员有了写单元测试很难的感觉。所以，写单元测试的难易程度跟代码的质量关系最大，并且是决定性的。项目里无论用了哪个测试框架都不能解决代码本身难以测试的问题。 诚然，写单元测试在开发期间的确是会耗费更多时间的，尤其是要追求很高(超过80%，甚至100%)的代码覆盖率，更是需要耗费大量心血才能达到的。对于一些只需一次交付，很少维护的项目来说，意义和价值确实不是很大。但这本质上是属于为了赚快钱，不负责任的行为了，毕竟谁都无法保障自己写的程序，真的没有丝毫问题。这个问题的出现并不是个人的问题，而是反映了公司项目管理中的问题。当然，个人的原因也存在，就是如何在有限的时间里，提高效率。 目前公司的大多数项目其实都有着至少两年的维护时间的，很多开发人员都不愿意把自己的时间耗在一个代码很烂、没有单元测试保障且经常变更需求的项目里面。总之，包括我本人在内，都是有项目维护恐惧症的，更愿意投入到新项目的开发中。但是新项目里面还是没有单元测试的保障，代码质量逐渐低劣，如此就又形成了一个不断的循环之中。无法挣脱这个循环的人员就只能选择离职了，也许不慎又到了新的漩涡里面。 一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。 单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。所以，在新项目中逐步推广和编写单元测试是有必要的，这将大大提高项目中代码的质量和可靠性，有些老项目中就算了吧，往往维护人员的负面情绪可能会更多，一些新的功能特性倒是可以试试。虽然写好单元测试很难，但写单元测试的难度其实是小于决定写单元测试的勇气的。 二、基本概念单元测试：单元测试又称模块测试，属于白盒测试，是最小单位的测试。模块分为程序模块和功能模块。功能模块指实现了一个完整功能的模块（单元），一个完整的程序单元具备输入、加工和输出三个环节。而且每个程序单元都应该有正规的规格说明，使之对其输入、加工和输出的关系做出名明确的描述。 驱动测试：驱动被测试模块正常运行起来的实体。通俗的说法就是你负责测试模块/方法是中间的，没有main()方法入口，怎么编译，怎么启动呢？就需要写一个带main()的方法来调用你的模块/方法，这个就是驱动测试。 测试桩：代替被测模块调用的子模块的实体，该实体一般为桩函数（stub）。通俗的说法就是你负责测试的模块/方法所调用的模块/方法，所以你需要模仿他们做一个返回值（假的，但符合设计）。 测试覆盖：评测测试过程中已经执行的代码的多少。 测试覆盖率：代码的覆盖程度，一种度量方式。针对代码的测试覆盖率有很多种度量方式，常见的有以下几种: 语句覆盖 判定覆盖 路径覆盖 测试覆盖率数据到底有多大意义。主要有以下几个观点： 路径覆盖率 &gt; 判定覆盖 &gt; 语句覆盖 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。 不要过于相信覆盖率数据，100%的测试覆盖率并不能保证bug的不出现。 代码覆盖率只是一个最基本的前提，一定要保证，但不是意味着达到指标就代表测试的完成 测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。 三、单元测试工具在Java中有非常多的单元测试的工具或框架可供选择，我这里只选择一些常用的、主流的单元测试框架或者工具来作介绍和使用。 JUnit：Java中最有名、使用最广泛的单元测试框架 Mockito：模拟框架，可以让你用干净而简单的API编写测试 Spring Test: 使用 Spring Test 来对Spring相关的项目做单元测试，其中会结合或者集成其他测试框架和工具 spring-boot-starter-test: SpringBoot项目中的单元测试 JaCoCo: 使用离线和运行时字节码工具来收集代码覆盖率指标的框架。 1. JUnit4JUnit 是使用 Java 语言编写的用于编写和运行可重复的自动化测试的开源测试框架。除了 Junit 之外，TestNg也是Java中非常受欢迎的单元测试框架。两种框架在功能上看起来非常相似，这里有一篇关于JUnit 4 与 TestNG 的对比，还有一篇较为全面的介绍TestNG的教程，总体来说，TestNG 比 Junit4 功能更强大一些，但是相比 Junit5 而言，TestNG 又落后了一代。开源的轮子滚滚向前，都是一代新的轮子超越一代老的轮子。所以，我们这里就只选择 Junit 来作单元测试框架的介绍了吧。 目前最新版本是 JUnit5.2.0，相比 JUnit4 而言有很大的改变，这里主要讲解 JUnit4 的使用(目前的新老项目中应该使用的更多)，并对 JUnit5 做简要介绍。学习了 Junit4 的主要使用方式之后，大家再去看JUnit5 用户指南在将来逐渐使用起来更好些。 (1). 简单示例1234567891011121314151617import static org.junit.Assert.*;import org.junit.Test;public class CalculateTest &#123; @Test public void testSum() &#123; Calculate calculation = new Calculate(); int sum = calculation.sum(2, 5); int testSum = 7; System.out.println("@Test sum(): " + sum + " = " + testSum); assertEquals(sum, testSum); &#125;&#125; (2). 注解 @Test: 测试方法，在这里还可以测试期望异常和超时时间。 @Before: 每个测试方法执行之前执行的方法。 @BeforeClass: 一个测试类中所有测试方法执行之前执行的方法，只执行一次，且方法必须为static的。 @After: 每个测试方法执行之后执行的方法。 @AfterClass: 一个测试类中所有测试方法执行之后执行的方法，只执行一次，且方法必须为static的。 @Ignore: 忽略的测试方法。 @RunWith: 指定测试类使用某个运行器。 @Parameters: 参数化测试，指定测试类的测试数据集合。 @FixMethodOrder: 注解在测试类上指定测试方法按一定顺序规则来执行，有三种。 一个测试类单元测试的执行顺序为： @BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass 每一个测试方法的执行顺序为： @Before –&gt; @Test –&gt; @After 综合示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import static org.junit.Assert.*;import java.util.*;import org.junit.*;public class AnnotationsTest &#123; private ArrayList testList; @BeforeClass public static void onceExecutedBeforeAll() &#123; System.out.println("@BeforeClass: onceExecutedBeforeAll"); &#125; @Before public void executedBeforeEach() &#123; testList = new ArrayList(); System.out.println("@Before: executedBeforeEach"); &#125; @AfterClass public static void onceExecutedAfterAll() &#123; System.out.println("@AfterClass: onceExecutedAfterAll"); &#125; @After public void executedAfterEach() &#123; testList.clear(); System.out.println("@After: executedAfterEach"); &#125; @Test public void EmptyCollection() &#123; assertTrue(testList.isEmpty()); System.out.println("@Test: EmptyArrayList"); &#125; @Test public void OneItemCollection() &#123; testList.add("oneItem"); assertEquals(1, testList.size()); System.out.println("@Test: OneItemArrayList"); &#125; @Ignore public void executionIgnored() &#123; System.out.println("@Ignore: This execution is ignored"); &#125;&#125; 如果我们运行上面的测试，控制台输出将是以下几点： 12345678@BeforeClass: onceExecutedBeforeAll@Before: executedBeforeEach@Test: EmptyArrayList@After: executedAfterEach@Before: executedBeforeEach@Test: OneItemArrayList@After: executedAfterEach@AfterClass: onceExecutedAfterAll (3). 断言断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。JUnit4.x中的断言核心方法如下： assertArrayEquals(expecteds, actuals): 查看两个数组是否相等。 assertEquals(expected, actual): 查看两个对象是否相等。类似于字符串比较使用的equals()方法。 assertNotEquals(first, second): 查看两个对象是否不相等。 assertNull(object): 查看对象是否为空。 assertNotNull(object): 查看对象是否不为空。 assertSame(expected, actual): 查看两个对象的引用是否相等。类似于使用“==”比较两个对象。 assertNotSame(unexpected, actual): 查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象。 assertTrue(condition): 查看运行结果是否为true。 assertFalse(condition): 查看运行结果是否为false。 assertThat(actual, matcher): 查看实际值是否满足指定的条件。 fail(): 让测试失败。 (4). 套件测试测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，@RunWith和@Suite注释用来运行套件测试。简单示例如下： 1234567public class TestJunit1 &#123; @Test public void testPrint1() &#123; System.out.println("Test Junit 1..."); &#125;&#125; 1234567public class TestJunit2 &#123; @Test public void testPrint2() &#123; System.out.println("Test Junit 2..."); &#125;&#125; 12345678@RunWith(Suite.class)@Suite.SuiteClasses(&#123; TestJunit1.class, TestJunit2.class&#125;)public class JunitTestSuite &#123;&#125; (5). 参数化测试一个测试类也可以被看作是一个参数化测试类。但它要满足下列所有要求： 该类被注解为@RunWith(Parameterized.class)。 这个类有一个构造函数，存储测试数据。 这个类有一个静态方法生成并返回测试数据，并注明@Parameters注解。 这个类有一个测试，它需要注解@Test到方法。 简单示例如下： 12345678910111213141516171819202122232425262728293031323334353637import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;@RunWith(Parameterized.class)public class CalculateTest &#123; private int expected; private int first; private int second; public CalculateTest(int expectedResult, int firstNumber, int secondNumber) &#123; this.expected = expectedResult; this.first = firstNumber; this.second = secondNumber; &#125; @Parameters public static Collection addedNumbers() &#123; return Arrays.asList(new Integer[][] &#123; &#123; 3, 1, 2 &#125;, &#123; 5, 2, 3 &#125;, &#123; 7, 3, 4 &#125;, &#123; 9, 4, 5 &#125;, &#125;); &#125; @Test public void sum() &#123; Calculate add = new Calculate(); System.out.println("Addition with parameters : " + first + " and " + second); assertEquals(expected, add.sum(first, second)); &#125;&#125; 运行CalculateTest测试用例，控制台输出如下： 12345678Addition with parameters : 1 and 2Adding values: 1 + 2Addition with parameters : 2 and 3Adding values: 2 + 3Addition with parameters : 3 and 4Adding values: 3 + 4Addition with parameters : 4 and 5Adding values: 4 + 5 (6). 忽略测试有时可能会发生我们的代码还没有准备好的情况，这时测试用例去测试这个方法或代码的时候会造成失败。@Ignore注释会在这种情况时帮助我们。 一个含有@Ignore注释的测试方法将不会被执行。 如果一个测试类有@Ignore注释，则它的测试方法将不会执行 123456789public class JunitTest3 &#123; @Test @Ignore("该测试方法还没准备好运行.") public void testHello() &#123; System.out.println("Hello World!"); &#125;&#125; 在上面的示例中，JUnit将不会执行testHello()方法。 (7). 异常测试它用于测试由方法抛出的异常。 12345678910import org.junit.*;public class JunitTest4 &#123; @Test(expected = ArithmeticException.class) public void testWithException() &#123; int i = 1 / 0; &#125;&#125; 在上面的示例中，testWithException()方法将抛出ArithmeticException异常，因为这是一个预期的异常，因此单元测试会通过。 (8). 超时测试超时测试是指，一个单元测试运行时间是否超过指定的毫秒数，测试将终止并标记为失败。 123456789101112import org.junit.*;public class JunitTest5 &#123; @Test(timeout = 1000) public void testTimeout() &#123; while (true) &#123; // do nothing. &#125; &#125;&#125; 在上面的示例中，testTimeout()方法将不会返回，因此JUnit引擎会将其标记为失败，并抛出一个异常。java.lang.Exception:test timed out after 1000 milliseconds。 (9). Hamcrest在实际开发中，一些基本的断言，如eqaul, null, true它们的可读性并不是很好。而且很多时候我们要比较对象、集合、Map等数据结构。这样我们要么进行大段的字段获取再断言。或者干脆自己编写表达式并断言其结果。JUnit4.4 引入了 Hamcrest 框架，Hamcest 提供了一套匹配符 Matcher，这些匹配符更接近自然语言，可读性高，更加灵活。 Hamcrest提供了大量被称为“匹配器”的方法。其中每个匹配器都设计用于执行特定的比较操作。Hamcrest 的可扩展性很好，让你能够创建自定义的匹配器。最重要的是，JUnit 也包含了 Hamcrest 的核心，提供了对 Hamcrest 的原生支持，可以直接使用 Hamcrest。当然要使用功能齐备的Hamcrest，还是要引入对它的依赖。 看个对比例子，前者使用Junit的 断言，后者使用 Hamcrest 的断言。 123456789101112131415@Testpublic void test_with_junit_assert() &#123; int expected = 51; int actual = 51; assertEquals("failure - They are not same!", expected, actual);&#125;@Testpublic void test_with_hamcrest_assertThat() &#123; int expected = 51; int actual = 51; assertThat("failure - They are not same!", actual, equalTo(expected));&#125; 123456// 联合匹配符not和equalTo表示“不等于”assertThat( something, not( equalTo( "developer" ) ) ); // 联合匹配符not和containsString表示“不包含子字符串”assertThat( something, not( containsString( "Works" ) ) ); // 联合匹配符anyOf和containsString表示“包含任何一个子字符串”assertThat(something, anyOf(containsString("developer"), containsString("Works"))); 使用 assertThat 的优点： Hamcrest 一条 assertThat 即可以替代其他所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。 assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活 assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。 可以将这些 Matcher 匹配符联合起来灵活使用，达到更多目的。 JUnit 4.4 自带了一些 Hamcrest 的匹配符 Matcher，但是只有有限的几个，在类org.hamcrest.CoreMatchers中定义，要想使用他们，必须导入包 org.hamcrest.CoreMatchers.*。 Hamcrest 提供了很强大的一些api 供我们进行测试断言。 12345678910111213141516171819202122232425262728核心： anything - 总是匹配,如果你不关心测试下的对象是什么是有用的 describedAs - 添加一个定制的失败表述装饰器 is - 改进可读性装饰器 - 见下 “Sugar”逻辑： allOf - 如果所有匹配器都匹配才匹配,像Java里的&amp;&amp; anyOf - 如果任何匹配器匹配就匹配,像Java里的|| not - 如果包装的匹配器不匹配器时匹配,反之亦然对象： equalTo - 测试对象相等使用Object.equals方法 hasToString - 测试Object.toString方法 instanceOf, isCompatibleType - 测试类型 notNullValue, nullValue - 测试null sameInstance - 测试对象实例Beans： hasProperty - 测试JavaBeans属性集合： array - 测试一个数组元素test an array’s elements against an array of matchers hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值 hasItem, hasItems - 测试一个集合包含一个元素 hasItemInArray - 测试一个数组包含一个元素数字： closeTo - 测试浮点值接近给定的值 greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序文本： equalToIgnoringCase - 测试字符串相等忽略大小写 equalToIgnoringWhiteSpace - 测试字符串忽略空白 containsString, endsWith, startsWith - 测试字符串匹配 以下示例代码列举了大部分 assertThat 的使用例子，供大家学习使用时参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//---------------- 字符相关匹配符 ----------------/**equalTo匹配符断言被测的testedValue等于expectedValue，* equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法*/assertThat(testedValue, equalTo(expectedValue));/**equalToIgnoringCase匹配符断言被测的字符串testedString*在忽略大小写的情况下等于expectedString*/assertThat(testedString, equalToIgnoringCase(expectedString));/**equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString*在忽略头尾的任意个空格的情况下等于expectedString，*注意：字符串中的空格不能被忽略*/assertThat(testedString, equalToIgnoringWhiteSpace(expectedString);/**containsString匹配符断言被测的字符串testedString包含子字符串subString**/assertThat(testedString, containsString(subString));/**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/assertThat(testedString, endsWith(suffix));/**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/assertThat(testedString, startsWith(prefix));// ---------------- 一般匹配符 ----------------/**nullValue()匹配符断言被测object的值为null*/assertThat(object,nullValue());/**notNullValue()匹配符断言被测object的值不为null*/assertThat(object,notNullValue());/**is匹配符断言被测的object等于后面给出匹配表达式*/assertThat(testedString, is(equalTo(expectedValue)));/**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/assertThat(testedValue, is(expectedValue));/**is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写，*断言testedObject为Cheddar的实例*/assertThat(testedObject, is(Cheddar.class));/**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/assertThat(testedString, not(expectedString));/**allOf匹配符断言符合所有条件，相当于“与”（&amp;&amp;）*/assertThat(testedNumber, allOf(greaterThan(8), lessThan(16)));/**anyOf匹配符断言符合条件之一，相当于“或”（||）*/assertThat(testedNumber, anyOf(greaterThan(16), lessThan(8)));// ---------------- 数值相关匹配符 ----------------/**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/assertThat(testedDouble, closeTo(20.0, 0.5));/**greaterThan匹配符断言被测的数值testedNumber大于16.0*/assertThat(testedNumber, greaterThan(16.0));/** lessThan匹配符断言被测的数值testedNumber小于16.0*/assertThat(testedNumber, lessThan (16.0));/** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/assertThat(testedNumber, greaterThanOrEqualTo (16.0));/** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/assertThat(testedNumber, lessThanOrEqualTo (16.0));// ---------------- 集合相关匹配符 ----------------/**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为"key"对应元素值为"value"的Entry项*/assertThat(mapObject, hasEntry("key", "value"));/**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/assertThat(iterableObject, hasItem (element));/** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/assertThat(mapObject, hasKey ("key"));/** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/assertThat(mapObject, hasValue(value)); 2. JUnit5(1). Junit5简介JUnit 5 跟以前的JUnit版本不一样，它由几大不同的模块组成，这些模块分别来自三个不同的子项目。 JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage JUnit Platform是在JVM上 启动测试框架 的基础平台。它还定义了TestEngine API，该API可用于开发在平台上运行的测试框架。此外，平台还提供了一个从命令行或者 Gradle 和 Maven 插件来启动的 控制台启动器 ，它就好比一个 基于 JUnit4 的 Runner 在平台上运行任何TestEngine。 JUnit Jupiter是一个组合体，它是由在JUnit 5中编写测试和扩展的新 编程模型 和 扩展模型 组成。另外，Jupiter子项目还提供了一个TestEngine，用于在平台上运行基于Jupiter的测试。 JUnit Vintage 提供了一个TestEngine，用于在平台上运行基于JUnit 3和JUnit 4的测试。 JUnit 5需要Java 8（或更高）的运行时环境。不过，你仍然可以测试那些由老版本JDK编译的代码。 (2). 简单示例123456789101112import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class FirstJUnit5Tests &#123; @Test void myFirstTest() &#123; assertEquals(2, 1 + 1); &#125;&#125; 表面上来看，使用方式和 Junit4 差别不大，但是与 JUnit4 比较起来还是有些不同的。 导入测试测试注解（@Test）和断言方法（assertEquals）的包路径不同。 不需要手动把测试和测试方法声明为public了。 (3). 注解JUnit Jupiter支持使用下面表格中的注解来配置测试和扩展框架。 所有的核心注解都位于junit-jupiter-api模块的org.junit.jupiter.api`包中。 @Test: 表示该方法是一个测试方法。与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖。 @ParameterizedTest: 表示该方法是一个参数化测试（可以用不同的参数多次运行试）。这样的方法会被继承，除非它们被覆盖。 @RepeatedTest: 表示该方法是一个重复测试的测试模板(让某个测试方法运行多次)。这样的方法会被继承，除非它们被覆盖。 @TestFactory: 表示该方法是一个动态测试的测试工厂。这样的方法会被继承，除非它们被覆盖。 @TestInstance: 用于配置所标注的测试类的测试实例生命周期。这些注解会被继承。 @TestTemplate: 表示该方法是一个测试模板，它会依据注册的提供者所返回的调用上下文的数量被多次调用。这样的方法会被继承，除非它们被覆盖。 @DisplayName: 为测试类或测试方法声明一个自定义的显示名称(空格、特殊字符甚至是emojis表情)。该注解不能被继承。 @BeforeEach: 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前执行；类似于 JUnit4 的@Before。这样的方法会被继承，除非它们被覆盖。 @AfterEach: 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；类似于 JUnit4 的@After。这样的方法会被继承，除非它们被覆盖。 @BeforeAll: 表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前执行；类似于 JUnit4 的@BeforeClass。这样的方法会被继承（除非它们被隐藏或覆盖），并且它必须是static方法（除非”per-class” 测试实例生命周期被使用）。 @AfterAll: 表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；类似于 JUnit4 的@AfterClass。这样的方法会被继承（除非它们被隐藏 或覆盖），并且它必须是static方法（除非”per-class” 测试实例生命周期被使用）。 @Nested: 表示使用了该注解的类是一个内嵌、非静态的测试类(让测试编写者能够表示出几组测试用例之间的关系)。@BeforeAll和@AfterAll方法不能直接在@Nested测试类中使用，（除非”per-class”测试实例生命周期被使用）。该注解不能被继承。 @Tag: 用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或 JUnit4 的分类。该注解能被继承，但仅限于类级别，而非方法级别。 @Disable: 用于禁用一个测试类或测试方法；类似于 JUnit4 的@Ignore。该注解不能被继承。 @ExtendWith: 用于注册自定义扩展。该注解不能被继承。 注：被@Test、@TestTemplate、@RepeatedTest、@BeforeAll、@AfterAll、@BeforeEach 或 @AfterEach 注解标注的方法不可以有返回值。 在 JUnit5 中的一个测试类的基本生命周期示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@DisplayName("Junit5的测试示例类")class LifecycleTest &#123; @BeforeAll @DisplayName("资源初始化方法") static void initializeExternalResources() &#123; System.out.println("Initializing external resources..."); &#125; @BeforeEach void initializeMockObjects() &#123; System.out.println("Initializing mock objects..."); &#125; @Test void someTest() &#123; System.out.println("Running some test..."); assertTrue(true); &#125; @Test void otherTest() &#123; assumeTrue(true); System.out.println("Running another test..."); assertNotEquals(1, 42, "Why wouldn't these be the same?"); &#125; @Test @Disabled @DisplayName("该方法先不执行.") void disabledTest() &#123; System.exit(1); &#125; @AfterEach void tearDown() &#123; System.out.println("Tearing down..."); &#125; @AfterAll static void freeExternalResources() &#123; System.out.println("Freeing external resources..."); &#125;&#125; 由于 JUnit5 中的新特性很多，限于篇幅就简单介绍到这里了，如想详细了解 Junit5 的更多特性，请前往Junit5官网和JUnit5用户指南中文版去查看。 3. Mockito在软件开发中提及Mock，通常理解为模拟对象。为什么需要模拟? 在我们一开始学编程时,我们所写的对象通常都是独立的，并不依赖其他的类，也不会操作别的类。但实际上，软件中是充满依赖关系的，比如我们会基于 service 业务操作类,而 service 类又是基于数据访问类(DAO)的，依次下去，形成复杂的依赖关系。 单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。 有些时候，我们代码所需要的依赖可能尚未开发完成，甚至还不存在，那如何让我们的开发进行下去呢？使用mock可以让开发进行下去，mock技术的目的和作用就是模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开。 我们可以自己编写自定义的 Mock 对象实现 Mock 技术，但是编写自定义的 Mock 对象需要额外的编码工作，同时也可能引入错误。现在实现 Mock 技术的优秀开源框架有很多，Mockito就是一个优秀的用于单元测试的 Mock 框架。 除了Mockito以外，还有一些类似的框架，比如： EasyMock：早期比较流行的 MocK 测试框架。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。 PowerMock：这个工具是在 EasyMock 和 Mockito 上扩展出来的，目的是为了解决 EasyMock 和 Mockito 不能解决的问题（比如对static, final, private方法均不能 Mock）。其实测试架构设计良好的代码，一般并不需要这些功能，但如果是在已有项目上增加单元测试，老代码有问题且不能改时，就不得不使用这些功能了。 JMockit：JMockit 是一个轻量级的mock框架是用以帮助开发人员编写测试程序的一组工具和API，该项目完全基于Java 5 SE的 java.lang.instrument包开发，内部使用ASM库来修改Java的Bytecode`。 WireMock: 模拟您的API以进行快速、可靠和全面的测试。WireMock是一个基于 HTTP 的 API 的模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。 Mockito 已经被广泛应用，所以这里重点介绍 Mockito，其他的Mock框架也各自有自己的特点，大家下来自己学习或者分享，参考的Mockito中文文档在这里。 下面的例子大多都会模拟一个 List，因为大多数人都熟悉它（比如add()，get()，clear()等方法）。实际上，请不要模拟List类，改用真实的实例。 (1). 验证行为一旦创建，mock会记录所有交互，你可以验证所有你想要验证的东西。 12345678910111213// 静态导入会使代码更简洁import static org.mockito.Mockito.*;// 创建mock对象List mockedList = mock(List.class);// 使用mock对象mockedList.add("one");mockedList.clear();// 验证行为verify(mockedList).add("one");verify(mockedList).clear(); Mock一旦创建，模拟对象将记住你的所有的交互。然后，您可以选择性地验证您感兴趣的任何行为。 (2). 如何做一些测试打桩(stubbing)123456789101112131415161718// 你可以mock具体的类型,不仅只是接口LinkedList mockedList = mock(LinkedList.class);// 测试桩when(mockedList.get(0)).thenReturn("first");when(mockedList.get(1)).thenThrow(new RuntimeException());// 输出“first”System.out.println(mockedList.get(0));// 抛出异常System.out.println(mockedList.get(1));// 因为get(999) 没有打桩，因此输出nullSystem.out.println(mockedList.get(999));// 验证get(0)被调用的次数verify(mockedList).get(0); 默认情况下，所有的函数都有返回值。mock函数默认返回的是null，一个空的集合或者一个被对象类型包装的内置类型，例如0、false对应的对象类型为Integer、Boolean； 测试桩函数可以被覆写: 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法； 一旦测试桩函数被调用，该函数将会一致返回固定的值； 上一次调用测试桩函数有时候极为重要，当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。 (3). 参数匹配器(matchers)Mockito以自然的java风格来验证参数值: 使用equals()函数。有时，当需要额外的灵活性时你可能需要使用参数匹配器，也就是argument matchers: 1234567891011// 使用内置的anyInt()参数匹配器when(mockedList.get(anyInt())).thenReturn("element");// 使用自定义的参数匹配器( 在isValid()函数中返回你自己的匹配器实现 )when(mockedList.contains(argThat(isValid()))).thenReturn("element");// 输出elementSystem.out.println(mockedList.get(999));// 你也可以验证参数匹配器verify(mockedList).get(anyInt()); 参数匹配器使验证和测试桩变得更灵活。点击这里可以查看更多内置的匹配器以及自定义参数匹配器或者hamcrest 匹配器的示例。 (4). 验证函数的确切、最少、从未调用次数12345678910111213141516171819202122232425// 使用模拟对象mockedList.add("once");mockedList.add("twice");mockedList.add("twice");mockedList.add("three times");mockedList.add("three times");mockedList.add("three times");// 下面的两个验证函数效果一样,因为verify默认验证的就是times(1)verify(mockedList).add("once");verify(mockedList, times(1)).add("once");// 验证具体的执行次数verify(mockedList, times(2)).add("twice");verify(mockedList, times(3)).add("three times");// 使用never()进行验证,never相当于times(0)verify(mockedList, never()).add("never happened");// 使用atLeast()/atMost()verify(mockedList, atLeastOnce()).add("three times");verify(mockedList, atLeast(2)).add("five times");verify(mockedList, atMost(5)).add("three times"); verify函数默认验证的是执行了times(1)，也就是某个测试函数是否执行了1次.因此，times(1)通常被省略了。 (5). 为返回值为void的函数通过Stub抛出异常1234doThrow(new RuntimeException()).when(mockedList).clear();// 调用这句代码会抛出异常mockedList.clear(); 当你调用doThrow(), doAnswer(), doNothing(), doReturn() and doCallRealMethod() 这些函数时可以在适当的位置调用when()函数. 当你需要下面这些功能时这是必须的: 测试void函数 在受监控的对象上测试函数 不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。 但是在调用when()函数时你可以选择是否调用这些上述这些函数。 (6). 验证执行执行顺序1234567891011121314151617181920212223242526272829// A. 验证mock一个对象的函数执行顺序// 创建Mock对象List singleMock = mock(List.class);// 使用mock对象singleMock.add("was added first");singleMock.add("was added second");// 为该mock对象创建一个inOrder对象InOrder inOrder = inOrder(singleMock);// 确保add函数首先执行的是add("was added first"),然后才是add("was added second")inOrder.verify(singleMock).add("was added first");inOrder.verify(singleMock).add("was added second");// B .验证多个mock对象的函数执行顺序List firstMock = mock(List.class);List secondMock = mock(List.class);// 使用mock对象firstMock.add("was called first");secondMock.add("was called second");// 为这两个Mock对象创建inOrder对象InOrder inOrder = inOrder(firstMock, secondMock);// 验证它们的执行顺序inOrder.verify(firstMock).add("was called first");inOrder.verify(secondMock).add("was called second"); 验证执行顺序是非常灵活的。你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可。另外，你可以仅通过那些需要验证顺序的mock对象来创建InOrder对象。 (7). 确保交互(interaction)操作不会执行在mock对象上1234567891011// 使用Mock对象mockOne.add("one");// 普通验证verify(mockOne).add("one");// 验证某个交互是否从未被执行verify(mockOne, never()).add("two");// 验证mock对象没有交互过verifyZeroInteractions(mockTwo, mockThree); (8). 查找冗余的调用12345678// 使用mock对象mockedList.add("one");mockedList.add("two");verify(mockedList).add("one");// 下面的验证将会失败verifyNoMoreInteractions(mockedList); 一些用户可能会在频繁地使用verifyNoMoreInteractions()，甚至在每个测试函数中都用。但是verifyNoMoreInteractions()并不建议在每个测试函数中都使用。verifyNoMoreInteractions()在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。你可以阅读这篇文档来了解更多相关信息。 (9). 简化mock对象的创建 最小化重复的创建代码; 使测试类的代码可读性更高; 使验证错误更易于阅读，因为字段名可用于标识mock对象; 1234567public class ArticleManagerTest &#123; @Mock private ArticleCalculator calculator; @Mock private ArticleDatabase database; @Mock private UserProvider userProvider; private ArticleManager manager; 注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中: 1MockitoAnnotations.initMocks(testClass); 关于mock注解的更多信息可以阅读MockitoAnnotations文档。 (10). 为连续的调用做测试打桩 (stub)有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。 123456789101112when(mock.someMethod("some arg")) .thenThrow(new RuntimeException()) .thenReturn("foo");// 第一次调用 : 抛出运行时异常mock.someMethod("some arg");// 第二次调用 : 输出"foo"System.out.println(mock.someMethod("some arg"));// 后续调用 : 也是输出"foo"System.out.println(mock.someMethod("some arg")); 另外，连续调用的另一种更简短的版本 : 123// 第一次调用时返回"one",第二次返回"two",第三次返回"three"when(mock.someMethod("some arg")) .thenReturn("one", "two", "three"); (11). 为回调做测试桩12345678910when(mock.someMethod(anyString())).thenAnswer(new Answer() &#123; Object answer(InvocationOnMock invocation) &#123; Object[] args = invocation.getArguments(); Object mock = invocation.getMock(); return "called with arguments: " + args; &#125;&#125;);// 输出 : "called with arguments: foo"System.out.println(mock.someMethod("foo")); (12). 监控真实对象你可以为真实对象创建一个监控(spy)对象。当你使用这个spy对象时真实的对象也会也调用，除非它的函数被stub了。尽量少使用spy对象，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。 12345678910111213141516171819List list = new LinkedList();List spy = spy(list);// 你可以为某些函数打桩when(spy.size()).thenReturn(100);// 通过spy对象调用真实对象的函数spy.add("one");spy.add("two");// 输出第一个元素System.out.println(spy.get(0));// 因为size()函数被打桩了,因此这里返回的是100System.out.println(spy.size());// 交互验证verify(spy).add("one");verify(spy).add("two"); Mockito 并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。 因此结论就是: 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。 (13). 重置mocks对象聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。 如果你真的想通过reset()方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的reset()方法。这可能意味着你已经过度测试了。 添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。 123456List mock = mock(List.class);when(mock.size()).thenReturn(10);mock.add(1);reset(mock);//at this point the mock forgot any interactions &amp; stubbing (14). 更多的注解 @Captor: 创建ArgumentCaptor。 @Spy: 可以代替spy(Object)。 @InjectMocks: 如果此注解声明的变量需要用到mock对象，mockito会自动注入mock或spy成员。 1234567891011//可以这样写@SpyBeerDrinker drinker = new BeerDrinker();//也可以这样写，mockito会自动实例化drinker.@SpyBeerDrinker drinker;//会自动实例化LocalPub@InjectMocksLocalPub pub; (15). BDD 风格的验证(Since 1.10.0)开启Behavior Driven Development(BDD，即行为驱动开发)风格的验证可以通过BBD的关键词then开始验证。 123456given(dog.bark()).willReturn(2);// when...then(person).should(times(2)).ride(bike); 以上就是 Mockito 的主要使用方式，关于更详细的介绍可参考Mockito官方文档和Mockito中文文档。 4. Spring Test目前几乎大多数 Java web 项目都是有基于 Spring 来开发的。通过 Spring 进行 bean 管理后，仅仅通过 JUnit 来做测试会有各种麻烦，比如：Spring容器初始化问题、使用硬编码方式手工获取Bean、不方便对数据操作的正确性做检查等。这时我们就可以通过 Spring 全家桶中的另一位成员spring-test来帮助我们在 Spring 工程中做单元测试了。以下通过简单的示例来演示其使用。 (1). 加入依赖包通过Maven加入JUnit、spring-test的Jar包(最好其他Spring包版本一致)。 123456789101112&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;xxxx&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; (2). 创建测试类1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("/application-context-test.xml")public class UserDaoTest &#123; /** 自动注入baseDao,默认按名称. */ @Resource private IBaseDao baseDao; @Test @Transactional @Rollback public void insert() &#123; String sql = "INSERT INTO t_user(c_name, c_password) values(?, ?)"; Object[] objs = new Object[]&#123;"zhangsan", "123456"&#125;; baseDao.insert(sql , objs); String sql2 = "SELECT * FROM t_user WHERE c_name = ? and c_password = ?"; List&lt;Map&lt;String,Object&gt;&gt; list = baseDao.queryForList(sql1, objs); assertTrue(list.size() &gt; 0); System.out.println(list); &#125;&#125; 使用Spring Test 可以使用@Autowired自动注入相关的bean信息，而不需要自己手动通过getBean去获取相应的bean信息。 使用Spring Test 测试，可以@Transaction注解，表示该方法使用spring的事务，在单元测试中，执行完毕后默认会回滚。 使用@Rollback注解，标明使用完此方法后事务回滚，可以@Rollback(false)这个注解来使对数据库操作的测试结果不回滚。 (3). 对 Spring MVC 的测试为了测试 web 项目，需要一些 Servlet 相关的模拟对象，比如：MockMVC/MockHttpServletRequest/MockHttpServletResponse/MockHttpSession。使用示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.mock.web.MockHttpSession;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("/application-context-test.xml")@WebAppConfiguration("src/main/resources") // 此注解指定web资源的位置，默认为src/main/webapppublic class TestControllerIntegrationTests &#123; private MockMvc mockMvc; // 模拟MVC对象 @Autowired private DemoService demoService;// 在测试用例注入spring的bean @Autowired WebApplicationContext wac; // 注入WebApplicationContext @Autowired MockHttpSession session; // 注入模拟的http session @Autowired MockHttpServletRequest request; // 模拟request @Before // 测试开始前的初始化工作 public void setup() &#123; this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); //2 &#125; @Test public void testNormalController() throws Exception&#123; String exp_str = demoService.saySomething(); // expect str mockMvc.perform(get("/normal")) // 模拟GET /normal .andExpect(status().isOk())// 预期返回状态为200 .andExpect(view().name("page"))// 预期view的名称 .andExpect(forwardedUrl("/WEB-INF/classes/views/page.jsp"))// 预期页面转向的真正路径 .andExpect(model().attribute("msg", exp_str));// 预期model里的值 &#125; @Test public void testRestController() throws Exception&#123; mockMvc.perform(get("/testRest")) // HTTP GET 方法 .andExpect(status().isOk()) .andExpect(content().contentType("text/plain;charset=UTF-8"))//14 .andExpect(content().string(demoService.saySomething()));//15 &#125;&#125; 注: demoService及相关方法的调用，也可以通过Mockito工具Mock出来，更符合单元测试对单元性的要求，否则这些测试又额外附带了一定集成测试的性质了。 4. spring-boot-starter-test(1). 简单介绍现在越来越多的应用都采用SpringBoot的方式来构建，在SpringBoot应用中单元测试变得更加容易了，只需要加入spring-boot-starter-test的 Starter 即可，其中默认导入了 Spring Boot 测试模块以及JUnit，AssertJ，Hamcrest和其他一些有用的库。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-boot-starter-test的 Starter (Scope为test)，包括了以下提供的类库： JUnit：单元测试Java应用程序的事实标准。 Spring Test 和 Spring Boot Test：Spring Boot应用程序的实用程序和集成测试支持。 AssertJ：流畅的断言库。 Hamcrest：匹配器对象库。 Mockito：Java Mock 框架。 JSONassert：JSON的断言库。 JsonPath：JSON的XPath。 我们通常在编写测试时发现这些通用库都是比较有用的。如果这些库还不适合您的需求，您还可以添加您自己的附加测试依赖库。 Spring Boot 提供了一个@SpringBootTest注释，当您需要 Spring Boot 功能时，它可以用作标准 spring-test @ContextConfiguration注释的替代方法。注解的工作原理是通过SpringApplication创建用于测试的ApplicationContext。除了@SpringBootTest之外，还提供了许多其他注释来测试应用程序的更具体的切片。 提示：不要忘记在测试中添加@RunWith(SpringRunner.class)，否则注释将被忽略。 (2). 一个简单示例1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Value("$&#123;msg&#125;") private String msg; @Autowired private UserService userService; @Test public void getUser() &#123; User user = userService.selectByKey(20180302325L); Assert.assertThat(user.getName(), is("Blinkfox")); System.out.println("获取的配置信息为:" + msg); &#125;&#125; 上面就是最简单的单元测试写法，测试类上只需要@RunWith(SpringRunner.class)和@SpringBootTest两个注解即可测试任何类和方法。 (3). web模块的单元测试要测试 Spring MVC 控制器是否按预期工作，请使用@WebMvcTest注释。@WebMvcTest自动配置Spring MVC基础结构，并将扫描的bean限制为@Controller，@ControllerAdvice，@JsonComponent，Converter，GenericConverter，Filter，WebMvcConfigurer和HandlerMethodArgumentResolver。 使用此注释时，不会扫描常规的@Component bean。 您还可以使用@AutoConfigureMockMvc对其进行注释，从而在非@WebMvcTest（如@SpringBootTest）中自动配置MockMvc。 以下示例使用MockMvc： 12345678910111213141516171819@RunWith(SpringRunner.class)@WebMvcTest(UserVehicleController.class)public class MyControllerTests &#123; @Autowired private MockMvc mvc; @MockBean private UserVehicleService userVehicleService; @Test public void testExample() throws Exception &#123; given(this.userVehicleService.getVehicleDetails("sboot")) .willReturn(new VehicleDetails("Honda", "Civic")); this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)) .andExpect(status().isOk()).andExpect(content().string("Honda Civic")); &#125;&#125; SpringBoot对各种单元测试的场景支持的比较全，更多的示例可直接在Spiring Boot Test 官方指南中去查看，这里就不再一一列举了。 5. JaCoCo在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80％或 90％。目前Java常用覆盖率工具clover、Jacoco和Cobertura等。关于这些代码覆盖率工具的对比可参看这里。这里我们就选取 Jacoco 来作为代码覆盖率工具来做介绍。 Jacoco 是一个开源的覆盖率工具。Jacoco 可以嵌入到Ant 、Maven中，并提供了 Eclipse、IDEA 插件,也可以使用Java Agent技术监控Java程序。很多第三方的工具提供了对 Jacoco 的集成，如sonar、Jenkins。 Jacoco与Maven的集成很简单，只需要在plugins中添加如下插件即可。 123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.7.201606060606&lt;/version&gt; &lt;configuration&gt; &lt;destFile&gt;target/coverage-reports/jacoco-unit.exec&lt;/destFile&gt; &lt;dataFile&gt;target/coverage-reports/jacoco-unit.exec&lt;/dataFile&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;jacoco-initialize&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;jacoco-site&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 做单元测试时，测试覆盖率是不是越高代表代码质量越好呢？Martin Fowler（重构那本书的作者）曾经写过一篇博客来讨论这个问题，他指出：把测试覆盖作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段。 所以，代码覆盖率统计是用来发现没有被测试覆盖的代码；代码覆盖率统计不能完全用来衡量代码质量。 参考资料 单元测试大揭密 JUnit教程 JUnit5用户指南中文版 Mockito中文文档 单元测试准则]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性及使用(二)]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[扩展注解的支持Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子： 1234567891011121314151617181920212223242526import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.ArrayList;import java.util.Collection;public class Annotations &#123; @Retention(RetentionPolicy.RUNTIME) @Target(&#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125;) public @interface NonEmpty &#123; &#125; public static class Holder&lt;@NonEmpty T&gt; extends @NonEmpty Object &#123; public void method() throws @NonEmpty Exception &#123; &#125; &#125; @SuppressWarnings("unused") public static void main(String[] args) &#123; final Holder&lt;String&gt; holder = new @NonEmpty Holder&lt;String&gt;(); @NonEmpty Collection&lt;@NonEmpty String&gt; strings = new ArrayList&lt;&gt;(); &#125;&#125; Base64在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子： 12345678910111213141516import java.nio.charset.StandardCharsets;import java.util.Base64;public class Base64s &#123; public static void main(String[] args) &#123; final String text = "Base64 finally in Java 8!"; final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println(encoded); final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println(decoded); &#125;&#125; 程序在控制台上输出了编码后的字符与解码后的字符： 12QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==Base64 finally in Java 8! Base64类同时还提供了对URL、MIME友好的编码器与解码器（Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()）。 JavaFXJavaFX是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考JavaFX中文文档。 其它1. JDBC4.2规范JDBC4.2主要有以下几点改动： 增加了对REF Cursor的支持 修改返回值大小范围（update count） 增加了java.sql.DriverAction接口 增加了java.sql.SQLType接口 增加了java.sql.JDBCtype枚举 对java.time包时间类型的支持 2. 更好的类型推测机制Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子： 1234567891011public class Value&lt;T&gt; &#123; public static&lt;T&gt; T defaultValue() &#123; return null; &#125; public T getOrDefault(T value, T defaultValue) &#123; return (value != null) ? value : defaultValue; &#125;&#125; 这里是Value&lt;String&gt;类型的用法。 12345678public class TypeInference &#123; public static void main(String[] args) &#123; final Value&lt;String&gt; value = new Value&lt;&gt;(); value.getOrDefault("22", Value.defaultValue()); &#125;&#125; Value.defaultValue()的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是Value.&lt;String&gt;defaultValue()。 3. HashMap性能提升Java8中，HashMap内部实现又引入了红黑树，使得HashMap的总体性能相较于Java7有比较明显的提升。以下是对Hash均匀和不均匀的情况下的性能对比 (1). Hash较均匀的情况 (2). Hash极不均匀的情况 4. IO/NIO 的改进Java8 对IO/NIO也做了一些改进。主要包括：改进了java.nio.charset.Charset的实现，使编码和解码的效率得以提升，也精简了jre/lib/charsets.jar包；优化了String(byte[], *)构造方法和String.getBytes()方法的性能；还增加了一些新的IO/NIO方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。 新增的 API 如下： BufferedReader.line(): 返回文本行的流Stream&lt;String&gt; File.lines(Path, Charset): 返回文本行的流Stream&lt;String&gt; File.list(Path): 遍历当前目录下的文件和目录 File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录 File.find(Path, int, BiPredicate, FileVisitOption...): 查找相应的文件 下面就是用流式操作列出当前目录下的所有文件和目录： 1Files.list(new File(".").toPath()).forEach(System.out::println); 5. JavaScript引擎NashornJava 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是javax.script.ScriptEngine另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子： 12345ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName("JavaScript");System.out.println(engine.getClass().getName());System.out.println("Result:" + engine.eval("function f()&#123;return 1;&#125;; f() + 1;")); 输出如下： 12jdk.nashorn.api.scripting.NashornScriptEngineResult: 2 6. 并发（Concurrency）在新增Stream机制与Lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）（请查看我们关于Java 并发的免费课程）。 新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。 在java.util.concurrent.atomic包中还增加了下面这些类： DoubleAccumulator DoubleAdder LongAccumulator LongAdder 7. 类依赖分析器jdepsJdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。 作为例子，让我们看看现在很流行的Spring框架的库的依赖关系报告。为了让报告短一些，我们只分析一个jar: org.springframework.core-3.0.5.RELEASE.jar. jdeps org.springframework.core-3.0.5.RELEASE.jar这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示not found. 1234567891011121314151617C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar) -&gt; java.io -&gt; java.lang -&gt; java.lang.annotation -&gt; java.lang.ref -&gt; java.lang.reflect -&gt; java.util -&gt; java.util.concurrent -&gt; org.apache.commons.logging not found -&gt; org.springframework.asm not found -&gt; org.springframework.asm.commons not found org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar) -&gt; java.lang -&gt; java.lang.annotation -&gt; java.lang.reflect -&gt; java.util 8. JVM的PermGen空间被移除PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。 参考文档： What’s New in JDK 8 Java 8新特性终极指南]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性及使用(一)]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[新特性列表以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考这里。 接口默认方法和静态方法 Lambda 表达式 函数式接口 方法引用 Stream Optional Date/Time API 重复注解 扩展注解的支持 Base64 JavaFX 其它 JDBC4.2规范 更好的类型推测机制 HashMap性能提升 IO/NIO 的改进 JavaScript引擎Nashorn 并发（Concurrency） 类依赖分析器jdeps JVM的PermGen空间被移除 一、接口默认方法和静态方法Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。 1. 接口默认方法默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子： 1234567891011121314151617private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return "Default implementation"; &#125;&#125;private static class DefaultableImpl implements Defaulable &#123;&#125;private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return "Overridden implementation"; &#125;&#125; Defaulable接口用关键字default声明了一个默认方法notRequired()，Defaulable接口的实现者之一DefaultableImpl实现了这个接口，并且让默认方法保持原样。Defaulable接口的另一个实现者OverridableImpl用自己的方法覆盖了默认方法。 (1). 多重继承的冲突说明由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下： 一个声明在类里面的方法优先于任何默认方法 优先选取最具体的实现 1234567public interface A &#123; default void hello() &#123; System.out.println("Hello A"); &#125;&#125; 1234567public interface B extends A &#123; default void hello() &#123; System.out.println("Hello B"); &#125;&#125; 1234567public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); // 输出 Hello B &#125;&#125; (2). 优缺点 优点: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。 缺点: 使得接口作为协议，类作为具体实现的界限开始变得有点模糊。 (3). 接口默认方法不能重载Object类的任何方法接口不能提供对Object类的任何方法的默认实现。简单地讲，每一个java类都是Object的子类，也都继承了它类中的equals()/hashCode()/toString()方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。 在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。 2. 接口静态方法Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用static关键字，例如： 1234567public interface StaticInterface &#123; static void method() &#123; System.out.println("这是Java8接口中的静态方法!"); &#125;&#125; 下面的一小段代码是上面静态方法的使用。 1234567public class Main &#123; public static void main(String[] args) &#123; StaticInterface.method(); // 输出 这是Java8接口中的静态方法! &#125;&#125; Java支持一个实现类可以实现多个接口，如果多个接口中存在同样的static方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。 二、Lambda 表达式 Lambda表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：行为参数化，函数作为参数传递进方法中）。 一个Lambda可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。 首先看看在老版本的Java中是如何排列字符串的： 123456789List&lt;String&gt; names = Arrays.asList("peter", "anna", "mike", "xenia");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： 1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。 三、函数式接口Lambda表达式是如何在Java的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 示例如下： 12345678@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert("123");System.out.println(converted); // 123 注：如果@FunctionalInterface如果没有指定，上面的代码也是对的。 Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在Lambda上。 Java8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 1. Comparator (比较器接口)Comparator是老Java中的经典接口， Java 8在此之上添加了多种默认方法。源代码及使用示例如下: 123456@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; 12345Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person("John", "Doe");Person p2 = new Person("Alice", "Wonderland");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 2. Consumer (消费型接口)Consumer接口表示执行在单个参数上的操作。源代码及使用示例如下: 123456@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello, " + p.firstName);greeter.accept(new Person("Luke", "Skywalker")); 更多的Consumer接口 BiConsumer：void accept(T t, U u);: 接受两个参数的二元函数 DoubleConsumer：void accept(double value);: 接受一个double参数的一元函数 IntConsumer：void accept(int value);: 接受一个int参数的一元函数 LongConsumer：void accept(long value);: 接受一个long参数的一元函数 ObjDoubleConsumer：void accept(T t, double value);: 接受一个泛型参数一个double参数的二元函数 ObjIntConsumer：void accept(T t, int value);: 接受一个泛型参数一个int参数的二元函数 ObjLongConsumer：void accept(T t, long value);: 接受一个泛型参数一个long参数的二元函数 3. Supplier (供应型接口)Supplier接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同Consumer相反，是一个只声明了返回值，不需要参数的函数。也就是说Supplier其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了new这个动作。而Supplier就表达了这种能力。源代码及使用示例如下: 12345@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125; 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person 更多Supplier接口 BooleanSupplier：boolean getAsBoolean();: 返回boolean的无参函数 DoubleSupplier：double getAsDouble();: 返回double的无参函数 IntSupplier：int getAsInt();: 返回int的无参函数 LongSupplier：long getAsLong();: 返回long的无参函数 4. Predicate (断言型接口)Predicate接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。Stream的filter方法就是接受Predicate作为入参的。这个具体在后面使用Stream的时候再分析深入。源代码及使用示例如下: 123456@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 1234567Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test("foo"); // truepredicate.negate().test("foo"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); 更多的Predicate接口 BiPredicate：boolean test(T t, U u);: 接受两个参数的二元断言函数 DoublePredicate：boolean test(double value);: 入参为double的断言函数 IntPredicate：boolean test(int value);: 入参为int的断言函数 LongPredicate：boolean test(long value);: 入参为long的断言函数 5. Function (功能型接口)Function接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）。源代码及使用示例如下: 123456@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; 123Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply("123"); // "123" 更多的Function接口 BiFunction ：R apply(T t, U u);: 接受两个参数，返回一个值，代表一个二元函数； DoubleFunction ：R apply(double value);: 只处理double类型的一元函数； IntFunction ：R apply(int value);: 只处理int参数的一元函数； LongFunction ：R apply(long value);: 只处理long参数的一元函数； ToDoubleFunction：double applyAsDouble(T value);: 返回double的一元函数； ToDoubleBiFunction：double applyAsDouble(T t, U u);: 返回double的二元函数； ToIntFunction：int applyAsInt(T value);: 返回int的一元函数； ToIntBiFunction：int applyAsInt(T t, U u);: 返回int的二元函数； ToLongFunction：long applyAsLong(T value);: 返回long的一元函数； ToLongBiFunction：long applyAsLong(T t, U u);: 返回long的二元函数； DoubleToIntFunction：int applyAsInt(double value);: 接受double返回int的一元函数； DoubleToLongFunction：long applyAsLong(double value);: 接受double返回long的一元函数； IntToDoubleFunction：double applyAsDouble(int value);: 接受int返回double的一元函数； IntToLongFunction：long applyAsLong(int value);: 接受int返回long的一元函数； LongToDoubleFunction：double applyAsDouble(long value);: 接受long返回double的一元函数； LongToIntFunction：int applyAsInt(long value);: 接受long返回int的一元函数； 6. OperatorOperator其实就是Function，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子Operator包括：UnaryOperator和BinaryOperator。分别对应单（一）元算子和二元算子。 算子的接口声明如下： 1234567@FunctionalInterfacepublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123; static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 12345678910111213@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123; public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) &#123; Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b; &#125; public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) &#123; Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b; &#125;&#125; Operator只需声明一个泛型参数T即可。对应的使用示例如下： 12345678UnaryOperator&lt;Integer&gt; increment = x -&gt; x + 1;System.out.println("递增:" + increment.apply(2)); // 输出 递增:3BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;System.out.println("相加:" + add.apply(2, 3)); // 输出 相加:5BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy((o1, o2) -&gt; o1 - o2);System.out.println("最小值:" + min.apply(2, 3)); // 输出 最小值:2 更多的Operator接口 LongUnaryOperator：long applyAsLong(long operand);: 对long类型做操作的一元算子 IntUnaryOperator：int applyAsInt(int operand);: 对int类型做操作的一元算子 DoubleUnaryOperator：double applyAsDouble(double operand);: 对double类型做操作的一元算子 DoubleBinaryOperator：double applyAsDouble(double left, double right);: 对double类型做操作的二元算子 IntBinaryOperator：int applyAsInt(int left, int right);: 对int类型做操作的二元算子 LongBinaryOperator：long applyAsLong(long left, long right);: 对long类型做操作的二元算子 6. 其它函数式接口 java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener 四、方法引用1. 概述在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下： 1Arrays.sort(strArray, (s1, s2) -&gt; s1.compareToIgnoreCase(s2)); 在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。 1Arrays.sort(strArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。 注意: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。 2. 分类方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号） 有以下四种形式的方法引用： 引用静态方法: ContainingClass::staticMethodName 引用某个对象的实例方法: containingObject::instanceMethodName 引用某个类型的任意对象的实例方法:ContainingType::methodName 引用构造方法: ClassName::new 3. 示例使用示例如下： 123456789101112131415161718192021222324public class Person &#123; String name; LocalDate birthday; public Person(String name, LocalDate birthday) &#123; this.name = name; this.birthday = birthday; &#125; public LocalDate getBirthday() &#123; return birthday; &#125; public static int compareByAge(Person a, Person b) &#123; return a.birthday.compareTo(b.birthday); &#125; @Override public String toString() &#123; return this.name; &#125;&#125; 1234567891011121314151617181920212223242526272829public class MethodReferenceTest &#123; @Test public static void main() &#123; Person[] pArr = new Person[] &#123; new Person("003", LocalDate.of(2016,9,1)), new Person("001", LocalDate.of(2016,2,1)), new Person("002", LocalDate.of(2016,3,1)), new Person("004", LocalDate.of(2016,12,1)) &#125;; // 使用匿名类 Arrays.sort(pArr, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person a, Person b) &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125; &#125;); //使用lambda表达式 Arrays.sort(pArr, (Person a, Person b) -&gt; &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;); //使用方法引用，引用的是类的静态方法 Arrays.sort(pArr, Person::compareByAge); &#125;&#125; 五、StreamJava8添加的Stream API(java.util.stream)把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括filter、map、flatMap、peel、distinct、sorted、limit和substream。终止操作包括forEach、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst和findAny。 java.util.stream.Collectors是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。 1. 一些重要方法说明 stream: 返回数据流，集合作为其源 parallelStream: 返回并行数据流， 集合作为其源 filter: 方法用于过滤出满足条件的元素 map: 方法用于映射每个元素对应的结果 forEach: 方法遍历该流中的每个元素 limit: 方法用于减少流的大小 sorted: 方法用来对流中的元素进行排序 anyMatch: 是否存在任意一个元素满足条件（返回布尔值） allMatch: 是否所有元素都满足条件（返回布尔值） noneMatch: 是否所有元素都不满足条件（返回布尔值） collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束 2. 一些使用示例(1). Filter 过滤1234stringCollection .stream() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println); (2). Sort 排序12345stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println); (3). Map 映射12345stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println); (4). Match 匹配1234567891011121314boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith("a"));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith("a"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith("z"));System.out.println(noneStartsWithZ); // true (5). Count 计数12345long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith("b")) .count();System.out.println(startsWithB); // 3 (6). Reduce 规约这是一个最终操作，允许通过指定的函数来将stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的。代码如下: 12345Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + "#" + s2);reduced.ifPresent(System.out::println); 六、Optional到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。 Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。 1234Optional&lt;String&gt; fullName = Optional.ofNullable(null);System.out.println("Full Name is set? " + fullName.isPresent());System.out.println("Full Name: " + fullName.orElseGet(() -&gt; "[none]"));System.out.println(fullName.map(s -&gt; "Hey " + s + "!").orElse("Hey Stranger!")); 如果Optional类的实例为非空值的话，isPresent()返回true，否从返回false。为了防止Optional为空值，orElseGet()方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出： 123Full Name is set? falseFull Name: [none]Hey Stranger! 让我们来看看另一个例子： 12345Optional&lt;String&gt; firstName = Optional.of("Tom");System.out.println("First Name is set? " + firstName.isPresent());System.out.println("First Name: " + firstName.orElseGet(() -&gt; "[none]"));System.out.println(firstName.map(s -&gt; "Hey " + s + "!").orElse("Hey Stranger!"));System.out.println(); 下面是程序的输出： 123First Name is set? trueFirst Name: TomHey Tom! 七、Date/Time APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： 1. Clock 时钟Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis()来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。代码如下: 1234Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date 2. Timezones 时区在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下: 12345678System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of("Europe/Berlin");ZoneId zone2 = ZoneId.of("Brazil/East");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] 3. LocalTime 本地时间LocalTime定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下: 1234567LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下: 1234567LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);System.out.println(leetTime); // 13:37 4. LocalDate 本地日期LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下: 1234567LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下: 12345DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);System.out.println(xmas); // 2014-12-24 5. LocalDateTime 本地日期时间LocalDateTime同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。代码如下: 1234567LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。代码如下: 12345Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下: 123456DateTimeFormatter formatter = DateTimeFormatter .ofPattern("MMM dd, yyyy - HH:mm");LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 关于Java8中日期API更多的使用示例可以参考Java 8中关于日期和时间API的20个使用示例。 八、重复注解自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。 重复注解机制本身必须用@Repeatable注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子： 123456789101112131415161718192021222324252627282930313233import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;public class RepeatingAnnotations &#123; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Filters &#123; Filter[] value(); &#125; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) public @interface Filter &#123; String value(); &#125;; @Filter("filter1") @Filter("filter2") public interface Filterable &#123; &#125; public static void main(String[] args) &#123; for(Filter filter: Filterable.class.getAnnotationsByType(Filter.class)) &#123; System.out.println(filter.value()); &#125; &#125;&#125; 正如我们看到的，这里有个使用@Repeatable(Filters.class)注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。 同时，反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation(Filters.class)`经编译器处理后将会返回Filters的实例）。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java7新特性及使用]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava7%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新特性列表以下是Java7中的引入的部分新特性。关于Java7更详细的介绍可参考这里。 switch支持String try-with-resources catch多个异常 实例创建类型推断 数字字面量下划线分割 二进制字面量 增强的文件系统 Fork/Join框架 其它 JDBC4.1规范 支持动态类型语言 JSR341-Expression Language Specification JSR203-More New I/O APIs for the Java Platform 桌面客户端增强 一、switch支持Stringswitch现在可以接受String类型的参数。示例代码如下： 12345678910111213141516String s = ...switch(s) &#123;case "quux": processQuux(s);// fall-throughcase "foo":case "bar": processFooOrBar(s); break;case "baz": processBaz(s); // fall-throughdefault: processDefault(s); break;&#125; 二、try-with-resourcesJava中某些资源是需要手动关闭的，如InputStream，Writer，Sockets，Connection等。这个新的语言特性允许try语句本身申请更多的资源，这些资源作用于try代码块，并自动关闭。 Java7之前的写法： 123456789101112131415BufferedReader br = null;try &#123; br = new BufferedReader(new FileReader(path)); return br.readLine();&#125; catch (Exception e) &#123; log.error("BufferedReader Exception", e);&#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (Exception e) &#123; log.error("BufferedReader close Exception", e); &#125; &#125;&#125; Java7及之后的写法： 12345try (BufferedReader br = new BufferedReader(new FileReader(path)) &#123; return br.readLine();&#125; catch (Exception e) &#123; log.error("BufferedReader Exception", e);&#125; 三、catch多个异常自Java7开始，catch中可以一次性捕捉多个异常做统一处理。示例如下： Java7之前的写法： 123456789101112public void handle() &#123; ExceptionThrower thrower = new ExceptionThrower(); try &#123; thrower.manyExceptions(); &#125; catch (ExceptionA a) &#123; System.out.println(a.getClass()); &#125; catch (ExceptionB b) &#123; System.out.println(b.getClass()); &#125; catch (ExceptionC c) &#123; System.out.println(c.getClass()); &#125;&#125; Java7及之后的写法： 12345678910public void handle() &#123; ExceptionThrower thrower = new ExceptionThrower(); try &#123; thrower.manyExceptions(); &#125; catch (ExceptionA | ExceptionB ab) &#123; System.out.println(ab.getClass()); &#125; catch (ExceptionC c) &#123; System.out.println(c.getClass()); &#125;&#125; 四、实例创建类型推断从Java7开始，泛型类的实例化也不用繁琐的将泛型声明再写一遍。示例如下： Java7之前的写法： 1Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Java7及之后的写法： 1Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 五、数字字面量下划线分割很长的数字可读性不好，在Java 7中可以使用下划线分隔长int以及long型整数了。如： 123long creditCardNumber = 1234_5678_9012_3456L;public static final int ONE_MILLION = 1_000_000;public static final float PI = 3.14_15F; 六、二进制字面量现在可以使用0b前缀创建二进制字面量： 1int binary = 0b1001_1001; 使用二进制字面量这种表示方式，使用非常简短的代码就可将二进制字符转换为数据类型，如在byte或short。 12byte aByte = (byte) 0b001;short aShort = (short) 0b010; 七、增强的文件系统Java7 推出了全新的NIO2.0 API以此改变针对文件管理的不便，使得在java.nio.file包下使用Path、Paths、Files、WatchService、FileSystem等常用类型可以很好的简化开发人员对文件管理的编码工作。 1. Path接口和Paths类Path接口的某些功能其实可以和java.io包下的File类等价，当然这些功能仅限于只读操作。在实际开发过程中，开发人员可以联用Path接口和Paths类，从而获取文件的一系列上下文信息。 int getNameCount(): 获取当前文件节点数 Path getFileName(): 获取当前文件名称 Path getRoot(): 获取当前文件根目录 Path getParent(): 获取当前文件上级关联目录 联用Path接口和Paths类型获取文件信息： 12345Path path = Paths.get("G:/test/test.xml");System.out.println("文件节点数:" + path.getNameCount());System.out.println("文件名称:" + path.getFileName());System.out.println("文件根目录:" + path.getRoot());System.out.println("文件上级关联目录:" + path.getParent()); 2. Files类联用Path接口和Paths类可以很方便的访问到目标文件的上下文信息。当然这些操作全都是只读的，如果开发人员想对文件进行其它非只读操作，比如文件的创建、修改、删除等操作，则可以使用Files类型进行操作。 Files类型常用方法如下： Path createFile(): 在指定的目标目录创建新文件 void delete(): 删除指定目标路径的文件或文件夹 Path copy(): 将指定目标路径的文件拷贝到另一个文件中 Path move(): 将指定目标路径的文件转移到其他路径下，并删除源文件 使用Files类型复制、粘贴文件示例： 1Files.copy(Paths.get("/test/src.xml"), Paths.get("/test/target.xml")); 使用Files类型来管理文件，相对于传统的I/O方式来说更加方便和简单。因为具体的操作实现将全部移交给NIO2.0 API，开发人员则无需关注。 3. WatchServiceJava7 还为开发人员提供了一套全新的文件系统功能，那就是文件监测。在此或许有很多朋友并不知晓文件监测有何意义及目，那么请大家回想下调试成热发布功能后的Web容器。当项目迭代后并重新部署时，开发人员无需对其进行手动重启，因为Web容器一旦监测到文件发生改变后，便会自动去适应这些“变化”并重新进行内部装载。Web容器的热发布功能同样也是基于文件监测功能，所以不得不承认，文件监测功能的出现对于Java文件系统来说是具有重大意义的。 文件监测是基于事件驱动的，事件触发是作为监测的先决条件。开发人员可以使用java.nio.file包下的StandardWatchEventKinds类型提供的3种字面常量来定义监测事件类型，值得注意的是监测事件需要和WatchService实例一起进行注册。 StandardWatchEventKinds类型提供的监测事件： ENTRY_CREATE：文件或文件夹新建事件； ENTRY_DELETE：文件或文件夹删除事件； ENTRY_MODIFY：文件或文件夹粘贴事件； 使用WatchService类实现文件监控完整示例： 12345678910111213141516171819202122232425262728public static void testWatch() &#123; /* 监控目标路径 */ Path path = Paths.get("G:/"); try &#123; /* 创建文件监控对象. */ WatchService watchService = FileSystems.getDefault().newWatchService(); /* 注册文件监控的所有事件类型. */ path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); /* 循环监测文件. */ while (true) &#123; WatchKey watchKey = watchService.take(); /* 迭代触发事件的所有文件 */ for (WatchEvent&lt;?&gt; event : watchKey.pollEvents()) &#123; System.out.println(event.context().toString() + " 事件类型：" + event.kind()); &#125; if (!watchKey.reset()) &#123; return; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 通过上述程序示例我们可以看出，使用WatchService接口进行文件监控非常简单和方便。首先我们需要定义好目标监控路径，然后调用FileSystems类型的newWatchService()方法创建WatchService对象。接下来我们还需使用Path接口的register()方法注册WatchService实例及监控事件。当这些基础作业层全部准备好后，我们再编写外围实时监测循环。最后迭代WatchKey来获取所有触发监控事件的文件即可。 八、Fork/Join框架1. 什么是Fork/Join框架Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 Fork/Join的运行流程图如下： 2. 工作窃取算法工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下： 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。 3. Fork/Join框架的介绍设计一个Fork/Join框架，主要有以下两步骤： 第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。 第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。 Fork/Join使用两个类来完成以上两件事情： ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：RecursiveAction：用于没有返回结果的任务。RecursiveTask ：用于有返回结果的任务。ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 4. Fork/Join框架使用示例让我们通过一个简单的需求来使用下Fork／Join框架，需求是：计算1 + 2 + 3 + 4的结果。 使用Fork/Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1 + 2，子任务二负责计算3 + 4，然后再join两个子任务的结果。 因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.blinkfox.test.other;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;/** * CountTask. * * @author blinkfox on 2018-01-03. */public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; /** 阈值. */ public static final int THRESHOLD = 2; /** 计算的开始值. */ private int start; /** 计算的结束值. */ private int end; /** * 构造方法. * * @param start 计算的开始值 * @param end 计算的结束值 */ public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; /** * 执行计算的方法. * * @return int型结果 */ @Override protected Integer compute() &#123; int sum = 0; // 如果任务足够小就计算任务. if ((end - start) &lt;= THRESHOLD) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务来计算. int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 等待子任务执行完，并得到结果，再合并执行结果. leftTask.fork(); rightTask.fork(); sum = leftTask.join() + rightTask.join(); &#125; return sum; &#125; /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinPool fkPool = new ForkJoinPool(); CountTask task = new CountTask(1, 4); Future&lt;Integer&gt; result = fkPool.submit(task); System.out.println("result:" + result.get()); &#125;&#125; 九、其它1. JDBC4.1规范JDBC4.1主要更新了两个新特性，分别是： (1). Connection，ResultSet 和 Statement 都实现了Closeable 接口Connection，ResultSet和Statement都实现了Closeable接口，所有在try-with-resources语句中调用，就可以自动关闭相关资源了。 (2). RowSet 1.1引入RowSetFactory接口和RowSetProvider类，可以创建JDBC driver支持的各种`Rowsets。 1234567891011121314151617RowSetFactory myRowSetFactory = null;JdbcRowSet jdbcRs = null;ResultSet rs = null;Statement stmt = null;try &#123; myRowSetFactory = RowSetProvider.newFactory();//用缺省的RowSetFactory 实现 jdbcRs = myRowSetFactory.createJdbcRowSet(); //创建一个 JdbcRowSet 对象，配置数据库连接属性 jdbcRs.setUrl("jdbc:myDriver:myAttribute"); jdbcRs.setUsername(username); jdbcRs.setPassword(password); jdbcRs.setCommand("select ID from TEST"); jdbcRs.execute();&#125; RowSetFactory接口包括了创建不同类型的RowSet的方法： createCachedRowSet createFilteredRowSet createJdbcRowSet createJoinRowSet createWebRowSet 2. 略 参考文档： JavaSE7 Features and Enhancements Java7的新特性 Fork/Join框架介绍]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java6新特性及使用]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava6%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新特性列表以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考这里。 Web Services Metadata Scripting Compiler API Light-weight HTTP server Common annotations(JSR 250) StAX JAXB2 Console Java DB(Derby) JDBC 4.0 值得关注的 集合框架增强 其它 GUI增强 一、Web Services MetadataWebService是一种独立于特定语言、特定平台，基于网络的、分布式的模块化组件。是一个能够使用xml消息通过网络来访问的接口，这个接口描述了一组可访问的操作。在Java6中，在想要发布为WebService的类上加上@WebService的注解，这个类的方法就变为WebService方法了，再通过Endpoint.publish()方法发布这个服务。到此，一个最简单的WebService搞定。运行main方法，在浏览器里输入http://localhost:8080/com.blinkfox.test.Hello?wsdl，即可查看你WebService的WSDL信息。 123456789101112131415161718192021222324252627282930313233import javax.jws.WebService;import javax.xml.ws.Endpoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Hello. * @author blinkfox on 2017-11-28. */@WebServicepublic class Hello &#123; private static final Logger log = LoggerFactory.getLogger(Hello.class); /** * sayHello. * @param name 名称 * @return 结果 */ public String sayHello(String name) &#123; return "Hello ".concat(name); &#125; /** * @param args */ public static void main(String[] args) &#123; Endpoint.publish("http://localhost:8080/com.blinkfox.test.Hello", new Hello()); log.info("调用成功!"); &#125;&#125; Java 自从JDK5中添加了元数据功能(注解)之后,SUN几乎重构了整个J2EE体系，由于变化很大，干脆将名字也重构为Java EE，Java EE(当前版本为5.0)将元数据纳入很多规范当中，这其中就包括Web Services的相关规范，这显然比以前的JAX-RPC编程模型简单(当然, Axis的编程模型也很简单)。这里要谈的Web服务元数据(JSR 181)只是Java Web 服务规范中的一个,它跟Common Annotations, JAXB2, StAX, SAAJ和JAX-WS等共同构成Java EE 5的Web Services技术堆栈。 下面介绍JSR-181里面各个元数据的相关参数及用途。 Annotation Retention Target Description WebService Runtime Type 标注要暴露为Web Services的类或接口 WebParam Runtime Parameter 自定义服务方法参数到WSDL的映射 WebResult Runtime Method 自定义服务方法返回值到WSDL的映射 WebMethod Runtime Method 自定义单个服务方法到WSDL的映射 Oneway Runtime Method 必须与@WebMethod连用,表明被标注方法只有输入没有输出,这就要求被标注方法不能有返回值,也不能声明checked exception HandlerChain Runtime Type,Method,Field 将Web服务与外部Handler chain关联起来 SOAPBinding Runtime Type,Method 自定义SOAPBinding 二、ScriptingJava6增加了对动态语言的支持，原理上是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。另外由于现在是编译成字节码后再执行，所以比原来边解释边执行效率要高很多。可以很好的利用脚本语言的动态特性，主要支持的有JavaSrcipt、Ruby、Python等。 以下使用JavaScript的脚本，代码示例如下： 123456789101112131415161718192021222324252627282930313233343536import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * JsTest. * @author blinkfox * @version 1.0 * */public class JsTest &#123; private static final Logger log = LoggerFactory.getLogger(Hello.class); /** * main方法. * @param args 数组参数 * @throws ScriptException 脚本异常 * @throws NoSuchMethodException 无方法异常 */ public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123; ScriptEngineManager enjineManager = new ScriptEngineManager(); ScriptEngine engine = enjineManager.getEngineByName("JavaScript"); String script="function hello(name)&#123;return 'Hello ' + name&#125;"; engine.eval(script); Invocable inv=(Invocable) engine; String result = (String) inv.invokeFunction("hello", "blinkfox"); log.info("脚本执行结果:&#123;&#125;", result); &#125;&#125; 三、Compiler API在Java6中提供了一套Compiler API，定义在JSR199中, 提供在运行期动态编译java代码为字节码的功能。一套API就好比是在java程序中模拟javac程序，将Java源文件编译为class文件；其提供的默认实现也正是在文件系统上进行查找、编译工作的。Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 基本使用示例如下： 12345678910111213public class JavaCompilerAPICompiler &#123; public void compile(Path src, Path output) throws IOException &#123; JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); try (StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null)) &#123; Iterable&lt;? extends JavaFileObject&gt; compilationUnits = fileManager.getJavaFileObjects(src.toFile()); Iterable&lt;String&gt; options = Arrays.asList("-d", output.toString()); JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, options, null, compilationUnits); boolean result = task.call(); &#125; &#125;&#125; 四、轻量级HTTP serverJDK6提供了一个轻量级的Http Server API，据此我们可以构建自己的嵌入式Http Server，它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现HttpHandler接口，HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。 以下是通过JDK6新特性能够实现的HttpServer的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import com.sun.net.httpserver.spi.HttpServerProvider;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.InetSocketAddress;/** * 自定义的http服务器. * * @author blinkfox on 2017-12-04. */public class MyHttpServer &#123; /** * 启动服务，监听来自客户端的请求. * * @throws IOException IO异常 */ private static void httpserverService() throws IOException &#123; HttpServerProvider provider = HttpServerProvider.provider(); HttpServer httpserver = provider.createHttpServer(new InetSocketAddress(8888), 200); // 监听端口8888,能同时接受100个请求 httpserver.createContext("/mytest", new MyHttpHandler()); httpserver.setExecutor(null); httpserver.start(); System.out.println("server started"); &#125; /** * Http请求处理类. */ private static class MyHttpHandler implements HttpHandler &#123; public void handle(HttpExchange httpExchange) throws IOException &#123; String responseMsg = "ok"; //响应信息 InputStream in = httpExchange.getRequestBody(); //获得输入流 BufferedReader reader = new BufferedReader(new InputStreamReader(in)); String temp = null; while((temp = reader.readLine()) != null) &#123; System.out.println("client request:" + temp); &#125; httpExchange.sendResponseHeaders(200, responseMsg.length()); //设置响应头属性及响应信息的长度 OutputStream out = httpExchange.getResponseBody(); //获得输出流 out.write(responseMsg.getBytes()); out.flush(); httpExchange.close(); &#125; &#125; public static void main(String[] args) throws IOException &#123; httpserverService(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Http服务器测试类. * * @author blinkfox on 2017-12-04. */public class HttpTest &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); // 测试并发对MyHttpServer的影响 for (int i = 0; i &lt; 20; i++) &#123; Runnable run = new Runnable() &#123; public void run() &#123; try &#123; startWork(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; exec.execute(run); &#125; exec.shutdown();// 关闭线程池 &#125; public static void startWork() throws IOException &#123; URL url = new URL("http://127.0.0.1:8888/mytest"); HttpURLConnection urlConn = (HttpURLConnection) url.openConnection(); urlConn.setDoOutput(true); urlConn.setDoInput(true); urlConn.setRequestMethod("POST"); // 测试内容包 String teststr = "this is a test message"; OutputStream out = urlConn.getOutputStream(); out.write(teststr.getBytes()); out.flush(); while (urlConn.getContentLength() != -1) &#123; if (urlConn.getResponseCode() == 200) &#123; InputStream in = urlConn.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); String temp = ""; while ((temp = reader.readLine()) != null) &#123; System.err.println("server response:" + temp);// 打印收到的信息 &#125; reader.close(); in.close(); urlConn.disconnect(); &#125; &#125; &#125;&#125; 五、Common annotationsCommon annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。 下面列举出Common Annotations 1.0里面的10个Annotations： Annotation Retention Target Description Generated Source ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE 用于标注生成的源代码 Resource Runtime TYPE, METHOD, FIELD 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入 PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的 RolesAllowed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的 PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法 DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行 DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色 六、StAXStAX(JSR 173)是JDK6中新增的除了DOM和SAX之外的又一种处理XML文档的API。 StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 下面是这几种XML解析API的特性比较： Feature StAX SAX DOM TrAX API Type Pull, streaming Push, streaming In memory tree XSLT Rule Ease of Use High Medium High Medium XPath Capability No No Yes Yes CPU and Memory Efficiency Good Good Varies Varies Forward Only Yes Yes No No Read XML Yes Yes Yes Yes Write XML Yes No Yes Yes Create, Read, Update, Delete No No Yes No 下面代码演示了如何通过StAX读取xml文档和生成xml文档： 需要读取的xml文件： 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;catalogs&gt; &lt;catalog id="001"&gt;Book&lt;/catalog&gt; &lt;catalog id="002"&gt;Video&lt;/catalog&gt;&lt;/catalogs&gt; 读和写XML文件的Java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import javax.xml.namespace.QName;import javax.xml.stream.*;import javax.xml.stream.events.StartElement;import javax.xml.stream.events.XMLEvent;/** * Stax测试类. * * @author blinkfox on 2017-12-04. */public class StaxTester &#123; /** * 根据StAX读取XML文件. * * @throws XMLStreamException XML流异常 * @throws FileNotFoundException 文件未找到异常 */ private static void readXxmlByStax() throws XMLStreamException, FileNotFoundException &#123; XMLInputFactory xmlif = XMLInputFactory.newInstance(); XMLEventReader xmler = xmlif.createXMLEventReader(new FileInputStream("G:\\test\\test.xml")); XMLEvent event; StringBuilder sb = new StringBuilder(); while (xmler.hasNext()) &#123; event = xmler.nextEvent(); if (event.isStartElement()) &#123; //如果解析的是起始标记 StartElement element = event.asStartElement(); sb.append("&lt;"); sb.append(element.getName()); if(element.getName().getLocalPart().equals("catalog")) &#123; sb.append(" id=/"); sb.append(element.getAttributeByName(new QName("id")).getValue()); sb.append("/"); &#125; sb.append("&gt;"); &#125; else if (event.isCharacters()) &#123; //如果解析的是文本内容 sb.append(event.asCharacters().getData()); &#125; else if(event.isEndElement()) &#123; //如果解析的是结束标记 sb.append("&lt;/"); sb.append(event.asEndElement().getName()); sb.append("&gt;"); &#125; &#125; System.out.println(sb); &#125; /** * 根据StAX写入XML文件. * * @throws XMLStreamException XML流异常 * @throws FileNotFoundException 文件未找到异常 */ private static void writeXmlByStax() throws XMLStreamException, FileNotFoundException &#123; XMLOutputFactory xmlof = XMLOutputFactory.newInstance(); XMLStreamWriter xmlw = xmlof.createXMLStreamWriter(new FileOutputStream("G:\\test\\output.xml")); // 写入默认的 XML 声明到xml文档 xmlw.writeStartDocument(); xmlw.writeCharacters("\n"); // 写入注释到xml文档 xmlw.writeComment("testing comment"); xmlw.writeCharacters("\n"); // 写入一个catalogs根元素 xmlw.writeStartElement("catalogs"); xmlw.writeNamespace("myNS", "http://blinkfox.com"); xmlw.writeAttribute("owner","Chinajash"); xmlw.writeCharacters("\n"); // 写入子元素catalog xmlw.writeCharacters(" "); xmlw.writeStartElement("http://blinkfox.com", "catalog"); xmlw.writeAttribute("id","007"); xmlw.writeCharacters("Apparel"); // 写入catalog元素的结束标签 xmlw.writeEndElement(); // 写入catalogs元素的结束标签 xmlw.writeCharacters("\n"); xmlw.writeEndElement(); // 结束 XML 文档 xmlw.writeEndDocument(); xmlw.close(); System.out.println("生成xml文件成功!"); &#125; /** * main方法. * * @param args 数组参数 * @throws XMLStreamException XML流异常 * @throws FileNotFoundException 文件未找到异常 */ public static void main(String[] args) throws XMLStreamException, FileNotFoundException &#123; readXxmlByStax(); writeXmlByStax(); &#125;&#125; 运行上面程序后，控制台输出如下: 12345&lt;catalogs&gt; &lt;catalog id=/001/&gt;Book&lt;/catalog&gt; &lt;catalog id=/002/&gt;Video&lt;/catalog&gt;&lt;/catalogs&gt;生成xml文件成功! 产生的output.xml文件如下: 12345&lt;?xml version="1.0" ?&gt;&lt;!--testing comment--&gt;&lt;catalogs xmlns:myNS="http://blinkfox.com" owner="Chinajash"&gt; &lt;myNS:catalog id="007"&gt;Apparel&lt;/myNS:catalog&gt;&lt;/catalogs&gt; 七、JAXB2JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。 下面用代码演示在JDK6中如何来用JAXB2： 12345678910111213141516171819202122/** * Gender性别枚举类. * * @author blinkfox on 2017-12-04. */public enum Gender &#123; MALE(true), FEMALE (false); private boolean code; /** * 构造方法. * @param code 性别值 */ Gender(boolean code) &#123; this.code = code; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import javax.xml.bind.annotation.XmlAttribute;import javax.xml.bind.annotation.XmlElement;/** * Address地址类. * * @author blinkfox on 2017-12-04. */public class Address &#123; @XmlAttribute String country; @XmlElement String state; @XmlElement String city; @XmlElement String street; /** 由于没有添加@XmlElement,所以该元素不会出现在输出的xml中. */ String zipcode; /** * 默认的空构造方法. */ public Address() &#123; super(); &#125; public Address(String country, String state, String city, String street, String zipcode) &#123; this.country = country; this.state = state; this.city = city; this.street = street; this.zipcode = zipcode; &#125; /** * country的getter方法. * * @return country */ public String getCountry() &#123; return country; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Calendar;import javax.xml.bind.annotation.XmlAttribute;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;/** * Person类. * * @author blinkfox on 2017-12-04. */@XmlRootElementpublic class Person &#123; /** birthday将作为person的子元素. */ @XmlElement Calendar birthDay; /** name将作为person的的一个属性. */ @XmlAttribute String name; /** address将作为person的子元素. */ @XmlElement Address address; /** gender将作为person的子元素. */ @XmlElement Gender gender; /** job将作为person的子元素. */ @XmlElement String job; /** * 默认的空构造方法. */ public Person() &#123; super(); &#125; public Person(Calendar birthDay, String name, Address address, Gender gender, String job) &#123; this.birthDay = birthDay; this.name = name; this.address = address; this.gender = gender; this.job = job; &#125; /** * address的getter方法. * @return address */ public Address getAddress() &#123; return address; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileReader;import java.io.FileWriter;import java.util.Calendar;import javax.xml.bind.JAXBContext;import javax.xml.bind.Marshaller;import javax.xml.bind.Unmarshaller;import org.apache.commons.io.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * JAXB2测试类. * * @author blinkfox on 2017-12-04. */public class JAXB2Test &#123; private static final Logger log = LoggerFactory.getLogger(JAXB2Test.class); public static void main(String[] args) &#123; Address address = new Address("中国", "北京", "北京", "上地", "100080"); Person p = new Person(Calendar.getInstance(),"JAXB2", address, Gender.MALE, "软件工程师"); FileReader reader = null; FileWriter writer = null; try &#123; // 生成xml文件. JAXBContext context = JAXBContext.newInstance(Person.class); writer = new FileWriter("G:/test/person.xml"); Marshaller m = context.createMarshaller(); m.marshal(p, writer); log.info("生成person.xml文件成功!"); // 读取xml文件. reader = new FileReader("G:/test/person.xml"); Unmarshaller um = context.createUnmarshaller(); Person p2 = (Person) um.unmarshal(reader); log.info("Country:&#123;&#125;", p2.getAddress().getCountry()); &#125; catch (Exception e) &#123; log.error("生成和读取XML文件出错！", e); &#125; finally &#123; IOUtils.closeQuietly(writer); IOUtils.closeQuietly(reader); &#125; &#125;&#125; 运行该程序，我们会得到一个person.xml的文件，内容如下： 1234567891011&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;person name="JAXB2"&gt; &lt;birthDay&gt;2017-12-04T17:16:19.226+08:00&lt;/birthDay&gt; &lt;address country="中国"&gt; &lt;state&gt;北京&lt;/state&gt; &lt;city&gt;北京&lt;/city&gt; &lt;street&gt;上地&lt;/street&gt; &lt;/address&gt; &lt;gender&gt;MALE&lt;/gender&gt; &lt;job&gt;软件工程师&lt;/job&gt;&lt;/person&gt; 八、ConsoleJDK6中提供了java.io.Console类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。下面代码演示了Console类的用法: 123456789101112131415161718192021222324import java.io.Console;/** * Jdk6之Console测试类. * * @author blinkfox on 2017-12-04. */public class ConsoleTest &#123; public static void main(String[] args) &#123; // 获得Console实例，并判断console是否可用 Console console = System.console(); if (console != null) &#123; // 读取整行字符和密码，密码输入时不会显示 String user = new String(console.readLine("请输入用户名:")); String pwd = new String(console.readPassword("再输入密码:")); console.printf("用户名是:" + user + "\n"); console.printf("密码是:" + pwd + "\n"); &#125; else &#123; System.out.println("Console不可用!"); &#125; &#125;&#125; 编译该代码，并在命令行中输入：java ConsoleTest，然后即可运行，运行示例如下： 1234请输入用户名:张三再输入密码:打印出的用户名是:张三打印出的密码是:123456 注: 在这里可以看到输入密码时,控制台时不显示这些密码字符的,但是程序可以得到输入的密码字符串,这与Linux下面输入密码的情况是一样的。 九、Java DB(Derby)从JDK6开始，JDK目录中新增了一个名为db的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目Derby。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性JDBC 4.0规范(JSR 221)。 下面分两种情况演示一下如何用代码操作Derby数据库，一种是嵌入式数据库，一种是网络数据库。 1. 嵌入式数据库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.blinkfox.learn.jdbc.JdbcDaoHelper;import java.sql.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Derby内嵌数据库测试示例. * * @author blinkfox on 2017-12-04. */public class EmbeddedDerbyTest &#123; private static final Logger log = LoggerFactory.getLogger(EmbeddedDerbyTest.class); /** Derby驱动,在derby.jar里面. */ private static final String DRIVER = "org.apache.derby.jdbc.EmbeddedDriver"; /** 连接Derby的url，create=true表示当数据库不存在时就创建它. */ private static final String URL = "jdbc:derby:EmbeddedDB;create=true"; /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; Class.forName(DRIVER); conn = DriverManager.getConnection(URL);//启动嵌入式数据库 st = conn.createStatement(); st.execute("create table foo (FOOID INT NOT NULL, FOONAME VARCHAR(30) NOT NULL)"); //创建foo表 st.executeUpdate("insert into foo(FOOID,FOONAME) values (1, 'blinkfox')"); //插入一条数据 rs = st.executeQuery("select * from foo");//读取刚插入的数据 while (rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString(2); log.info("查询结果：id = &#123;&#125;; name = &#123;&#125;", id, name); &#125; &#125; catch (Exception e) &#123; log.error("使用Derby数据库出错!", e); &#125; finally &#123; JdbcDaoHelper.close(rs); JdbcDaoHelper.close(st); JdbcDaoHelper.close(conn); &#125; &#125;&#125; 运行上面程序后，会在当前目录生成名为EmbeddedDB的文件夹，既是EmbeddedDB数据库的数据文件存放的地方，控制台将输出： 1查询结果：id = 1; name = blinkfox 2. 网络数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.PrintWriter;import java.sql.DriverManager;import org.apache.derby.drda.NetworkServerControl;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Derby网络数据库测试示例. * * @author blinkfox on 2017-12-04. */public class NetworkServerDerbyTest &#123; private static final Logger log = LoggerFactory.getLogger(NetworkServerDerbyTest.class); /** Derby驱动,在derbyclient.jar里面. */ private static final String DRIVER = "org.apache.derby.jdbc.ClientDriver"; /** 连接Derby的url. */ private static final String URL = "jdbc:derby://localhost:1527/NetworkDB;create=true"; /** * main方法. * &lt;p&gt;创建Derby网络服务器,默认端口是1527,也可以通过运行&lt;Derby_Home&gt;/frameworks/NetworkServer/bin/startNetworkServer.bat 来创建并启动Derby网络服务器,如果是Unix,用startNetworkServer.ksh&lt;/p&gt; * * @param args 数组参数 */ public static void main(String[] args) &#123; NetworkServerControl derbyServer = null; try &#123; //NetworkServerControl类在derbynet.jar里面 derbyServer = new NetworkServerControl(); PrintWriter pw = new PrintWriter(System.out); //用系统输出作为Derby数据库的输出 derbyServer.start(pw); //启动Derby服务器 Class.forName(DRIVER); DriverManager.getConnection(URL); &#125; catch (Exception e) &#123; log.error("操作Derby网络数据库异常!", e); &#125; finally &#123; if (derbyServer != null) &#123; try &#123; derbyServer.shutdown(); &#125; catch (Exception e) &#123; log.error("关闭Derby网络数据库异常!", e); &#125; &#125; &#125; &#125;&#125; 运行上面程序后,会在当前目录生成名为NetworkDB的文件夹。关于Derby的详细情况,请参考http://db.apache.org/derby。 十、JDBC 4.0在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。 自动加载java.sql.Driver，而不需要再调用class.forName； 添加了java.sql.RowId数据类型用来可以访问sql rowid； 添加了National Character Set的支持； 增强了BLOB和CLOB的支持功能； SQL/XML和XML支持； Wrapper Pattern； SQLException增强； Connection和Statement接口增强； New Scalar Funtions； JDBC API changes。 十一、值得关注的1. 集合框架增强Jdk6中的集合框架的API更改数量要少于JDK5，更多地关注了规范的准确性和清晰度。即使在编写旧版本的程序时，我们也建议使用Java SE 6规范。API更改的主要主题是更好的双向收集访问。 新增了以下几个接口： Deque: 双端队列接口，继承了Queue接口，队列两头都可以实现入队和出队。 BlockingDeque: 双端阻塞队列接口，继承了BlockingQueue、Deque接口。 NavigableSet: 可导航Set接口，继承自SortedSet接口。 NavigableMap: 可导航Map接口，继承自SortedMap接口。 ConcurrentNavigableMap: 支持并发的可导航Map，继承自ConcurrentMap接口和NavigableMap接口。 新增了以下几个实现类： ArrayDeque: 底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque来实现栈的功能，非线程安全。 ConcurrentSkipListSet: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。 ConcurrentSkipListMap: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。 LinkedBlockingDeque: 底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。 AbstractMap.SimpleEntry: Map.Entry的简单可变实现。 AbstractMap.SimpleImmutableEntry: Map.Entry的简单不可变实现。 以下的类已经被改进来用来实现新的接口： LinkedList: 改进以实现Deque接口。 TreeSet: 改进以实现NavigableSet接口。 TreeMap: 改进以实现NavigableMap接口。 新增了两个新的方法到Collections的工具类中： newSetFromMap(Map): 从通用的Map实现中创建一个通用的Set实现。Java集合中有IdentityHashMap，但是没有IdentityHashSet类，我们可以通过这样的方式来实现： 1Set&lt;Object&gt; identityHashSet = Collections.newSetFromMap(new IdentityHashMap&lt;Object, Boolean&gt;()); asLifoQueue(Deque): 通过传入Deque得到一个后进先出(LIFO)的队列。 现在Arrays工具类，具有copyOf和copyOfRange方法，可以有效地调整，截断或复制所有类型的数组的子数组。 以前是这样实现的： 12int[] newArray = new int[newLength];System.arraycopy(oldArray, 0, newArray, 0, oldArray.length); 现在可以这样实现： 1int[] newArray = Arrays.copyOf(a, newLength); 参考文档： -JavaSE6 Features and Enhancements-Java6的新特性-chinajash]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java5新特性及使用]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava5%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新特性列表以下是Java5中的引入的部分新特性，关于更详细的新特性了解，可参考这里。 泛型(Generics) 增强for循环(Enhanced for Loop) 自动装箱拆箱(Autoboxing/Unboxing) 枚举(Enums) 可变参数(Varargs) 静态导入(Static Import) 注解(Annotations) 值得关注 进程构建器(ProcessBuilder) 格式化(Formatter) 扫描器(Scanner) 反射(Reflection) 集合框架(Collections Framework) 并发工具类(Concurrency Utilities) StringBuilder 其它(others) 一、泛型(Generics)1. 概述Java语言引入泛型的好处是安全简单。可以将运行时错误提前到编译时错误。在Java5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的任意化，任意化带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法中，分别称为泛型类、泛型接口、泛型方法。 2. 泛型类、泛型接口泛型类中的类型参数几乎可以用于任何可以使用接口名、类名的地方。以下是Jdk中Map接口的定义： 1234567public interface Map&lt;K,V&gt; &#123; V get(Object key); V put(K key, V value);&#125; 当声明或者实例化一个泛型的对象时，必须指定类型参数的值： 1Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); 对于常见的泛型模式，推荐的名称是： K: 键 V: 值 E: 异常类 T: 泛型 3. 泛型方法(1). 定义泛型方法泛型方法使得该方法能独立于类而产生变化。以下是一个基本的指导原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。要定义泛型方法，只需将泛型参数列表置于返回值之前，就像下面这样： 1234567891011121314public class GenericMethods &#123; //当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上 public &lt;T&gt; void f(T x)&#123; System.out.println(x.getClass().getName()); &#125; public static void main(String[] args) &#123; GenericMethods gm = new GenericMethods(); gm.f(99); gm.f("abc"); &#125;&#125; (2). 可变参数泛型方法泛型方法与可变参数列表能很好地共存。 1234567891011121314151617181920public class GenericVarargs &#123; public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(T item:args) &#123; result.add(item); &#125; return result; &#125; public static void main(String[] args) &#123; List ls = makeList("A"); System.out.println(ls); ls = makeList("A","B","C"); System.out.println(ls); ls = makeList("ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("")); System.out.println(ls); &#125;&#125; 注：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 4. 泛型擦除看以下一段代码： 123456789public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); // 输出true. &#125;&#125; 从以上代码的执行结果可以知道，ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是相同的类型。Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 要想在表达式中使用类型，需要显式地传递类型的class对象。 123class Building &#123;&#125; 123class House extends Building &#123;&#125; 123456789101112131415161718192021public class ClassTypeCapture&lt;T&gt; &#123; Class&lt;T&gt; kind; public ClassTypeCapture(Class&lt;T&gt; kind) &#123; this.kind = kind; &#125; public boolean f(Object arg) &#123; return kind.isInstance(arg); &#125; public static void main(String[] args) &#123; ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;Building&gt;(Building.class); System.out.println(ctt1.f(new Building())); // true System.out.println(ctt1.f(new House())); // true ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;House&gt;(House.class); System.out.println(ctt2.f(new Building())); // false System.out.println(ctt2.f(new House())); // true &#125;&#125; 5. 通配符及泛型边界 通配符(?): 当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用?通配符来表未知类型。例如：Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);。 上界(? extends T): 可以接收T类型或者其子类型的对象。 下界(? super E): 可以接收T类型或者其父类型的对象。 6. 泛型总结 泛型的类型参数只能是类类型，不能是基本数据类型。 泛型的类型参数可以有多个。 所有泛型类的类型参数在编译时都会被擦除。 创建泛型对象时请指明类型，让编译器尽早的做参数检查。 不能创建泛型数组。如果想要创建泛型数组，建议使用ArrayList。 使用带泛型的类创建对象时，等式两边指定的泛型必须一致。 泛型的好处： 类型安全。 消除强制类型转换。 提高性能。 二、增强for循环(Enhanced for Loop)在Java5中，引入了另一种形式的for循环来对集合、数组、Map等进行遍历。如以下示例： 12345int[] integers = &#123;1, 2, 3, 4&#125;;/* 开始遍历 */for (int i : integers) &#123; System.out.println(i);/* 依次输出“1”、“2”、“3”、“4” */&#125; 借助增强for循环，可以用一种更简单地方式来完成遍历。能用这种方法遍历的对象的类型，可以是数组、Collection、Map或者任何其它实现了java.lang.Iterable接口的类。通过跟同样是在Java5中引入的泛型机制配合使用，可以精确的控制能采用的循环变量的类型。而且，因为这么编写的代码，会在编译期间被自动当成是和传统写法相同的形式，所以不必担心要额外付出性能方面的代价。 注：Java采用for（而不是意义更明确的foreach）来引导这种一般被叫做for-each循环的循环，并使用:（而不是意义更明确的in）来分割循环变量名称和要被遍历的对象。这样做的主要原因，是为了避免因为引入新的关键字，造成兼容性方面的问题——在Java语言中，不允许把关键字当作变量名来使用，虽然使用foreach这名字的情况并不是非常多，但是in却是一个经常用来表示输入流的名字（例如java.lang.System类里，就有一个名字叫做in的static属性，表示标准输入流）。 三、自动装箱拆箱(Autoboxing/Unboxing)1. 概述自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double和boolean对应的封装类分别为Byte, Short, Character, Integer, Long, Float, Double, Boolean。 自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(), doubleValue()这类的方法将对象转换成原始类型值。自动装箱和拆箱在Java中很常见，比如我们有一个方法，接受一个对象类型的参数，如果我们传递一个原始类型值，那么Java会自动将这个原始类型值转换成与之对应的对象。最经典的一个场景就是当我们向ArrayList这样的容器中增加原始类型数据时，就会发生自动装箱。代码示例如下： 12345ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();intList.add(1); //自动装箱intList.add(2); // 自动装箱int number = intList.get(0); // 自动拆箱 2. 对象相等的比较这是一个比较容易出错的地方，==可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中没有自动装箱发生。进行对象值比较不应该使用==，而应该使用对象对应的equals方法。看一个能说明问题的例子。 123456789101112131415161718192021222324252627282930public class AutoboxingTest &#123; public static void main(String args[]) &#123; // 示例 1: 使用'=='号进行原始类型的比较(没有自动装箱) int i1 = 1; int i2 = 1; System.out.println("i1==i2 : " + (i1 == i2)); // true // 示例 2: 使用'=='号进行原始类型和对象类型混合的比较(自动装箱) Integer num1 = 1; int num2 = 1; System.out.println("num1 == num2 : " + (num1 == num2)); // true // 示例 3: 使用'=='号进行Integer对象类型的比较(会有缓存的特殊情况) Integer obj1 = 127; // 自动装箱将调用`Integer.valueOf()`且缓存该对象，以便重用 Integer obj2 = 127; // 获取已经缓存过的对象 System.out.println("obj1 == obj2 : " + (obj1 == obj2)); // true // 示例 4: 使用'=='号进行Integer对象类型的比较(不会缓存) Integer obj3 = 128; // 自动装箱将调用`Integer.valueOf()`不缓存该对象 Integer obj4 = 128; // 同样是自动装箱将调用`Integer.valueOf()` System.out.println("obj3 == obj4 : " + (obj3 == obj4)); // false // 示例 5: 使用'=='号进行`new`出来的新`Integer`对象类型的比较 Integer one = new Integer(1); // no autoboxing Integer anotherOne = new Integer(1); System.out.println("one == anotherOne : " + (one == anotherOne)); // false &#125;&#125; 3. 缓存部分对象输出结果： 12345i1==i2 : truenum1 == num2 : trueobj1 == obj2 : trueobj3 == obj4 : falseone == anotherOne : false 在 Java5 中，为Integer的操作引入了一个新的特性，会对-128到127的Integer对象进行缓存，当创建新的Integer对象时，如果符合这个这个范围，并且已有存在的相同值的对象，则返回这个对象，否则创建新的Integer对象。这种Integer缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的Integer对象不能被缓存。 Integer类中有一个专门的私有静态内部类IntegerCache来负责Integer的缓存。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; Javadoc详细的说明这个类是用来实现缓存支持，并支持-128到127之间的自动装箱过程。最大值127可以通过JVM的启动参数-XX:AutoBoxCacheMax=size修改。 缓存通过一个for循环实现。从小到大的创建尽可能多的整数并存储在一个名为cache的整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。 这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。 ByteCache用于缓存Byte对象 ShortCache用于缓存Short对象 LongCache用于缓存Long对象 CharacterCache用于缓存Character对象 Byte，Short，Long有固定范围:-128到127。对于Character, 范围是0到127。除了Integer可以通过参数改变范围外，其它的都不行。 注：在Java中另一个节省内存的例子就是字符串常量池。 4. 自动装箱拆箱的隐患另一个需要避免的问题就是混乱使用对象和原始数据值，一个具体的例子就是当我们在一个原始数据值与一个对象进行比较时，如果这个对象没有进行初始化或者为null，在自动拆箱过程中obj.xxxValue，会抛出NullPointerException，如下面的代码: 123456private static Integer count;//NullPointerException on unboxingif (count &lt;= 0) &#123; System.out.println("Count is not started yet");&#125; 因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。 四、枚举(Enums)枚举（enum全称为enumeration）类型是 Java5 新增的类型，存放在java.lang包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。 关于枚举的介绍，这里就不再细讲了，请参考我以前所整理的Java 枚举知识整理一文。 五、可变参数(Varargs)1. 基本使用在 Java5 中提供了可变参数（Varargs），也就是在方法定义中可以使用个数不确定的参数，对于同一方法可以使用不同个数的参数调用，例如print(&quot;hello&quot;);、print(&quot;hello&quot;,&quot;lisi&quot;);等。下面介绍如何定义可变长参数以及如何使用可变长参数。 使用...表示可变长参数，例如： 123print(String... args) &#123; // 方法代码&#125; 在具有可变长参数的方法中可以把参数当成数组使用，例如可以循环输出所有的参数值。 12345print(String... args) &#123; for(String temp:args) &#123; System.out.println(temp); &#125;&#125; 调用的时候可以给出任意多个参数也可不给参数，例如： 123print();print("hello");print("hello","lisi"); 2. 可变参数的使用规则 拥有可变参数的方法可以被重载，在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变参数的方法匹配，则执行时会选择固定参数的方法。 如果要调用的方法可以和两个可变参数匹配，则编译不会通过。 一个方法只能有一个可变参数，并且这个可变参数必须是该方法的最后一个参数。 可变参数可以兼容数组参数，但数组参数无法兼容可变参数。即在方法中定义可变参数后，我们可以像操作数组一样操作该参数； 3. 可变参数的使用规范 避免带有可变参数的方法重载，容易让人陷入调用的陷阱及误区。 别让null值和空值威胁到可变参数的方法。 覆写可变参数方法也要满足以下的条件: 重写方法不能缩小访问权限。 参数列表必须与被重写方法相同（包括显示形式）。 返回类型必须与被重写方法的相同或是其子类。 重写方法不能抛出新的异常，或者超过了父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。 六、静态导入(Static Import)import static，即静态导入是JDK5中的新特性。一般我们导入一个类都用import com.xxx.ClassName;，而静态导入是这样的：import static com.xxx.ClassName.*;。这里多了个static，还有就是类名ClassName后面多了个.*，意思是导入这个类里的所有静态方法。当然，也可以只导入某个静态方法，只要把.*换成具体的静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名的方式来调用。 静态导入之前的代码： 1double r = Math.cos(Math.PI * theta); 使用静态导入之后的代码： 123import static java.lang.Math.*;double r = cos(PI * theta); 当你需要频繁访问一个或两个类的静态成员、静态方法时才使用静态导入。如果您过度的使用了静态导入功能，则可能导致您的程序无法读取且无法维护，从而导致您导入的所有静态成员和方法污染其名称空间。你的代码读者（包括你，在你写了几个月后）不会知道静态成员来自哪个类。从类中导入所有静态成员对可读性尤其有害，如果您只需要一个或两个成员，请单独导入它们。使用适当的，静态导入可以使您的程序更具可读性，通过删除重复的类名称，来减少样板代码。 七、注解(Annotations)关于注解的介绍，这里就不再细讲了，请参考我前段时间所写的Java注解的理解和应用一文。 八、值得关注1. 新增ProcessBuilder类ProcessBuilder类是Java5在java.lang包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由Process类处来实现进程的控制管理。每个ProcessBuilder实例管理一个进程属性集。它的start()方法利用这些属性创建一个新的Process实例。start()方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。 ProcessBuilder是一个final类，有两个带参数的构造方法，你可以通过构造方法来直接创建ProcessBuilder的对象。而Process是一个抽象类，一般都通过Runtime.exec()和ProcessBuilder.start()来间接创建其实例。ProcessBuilder为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而Process类的功能相对来说简单的多。ProcessBuilder类不是同步的。如果多个线程同时访问一个ProcessBuilder，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。 若要使用ProcessBuilder创建一个进程，只需要创建ProcessBuilder的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的start()即可。下面是一个执行打开Windows记事本的例子。注意它将要编辑的文件名指定为一个参数。 123456789101112class PBDemo &#123; public static void main(String args[]) &#123; try &#123; ProcessBuilder proc = new ProcessBuilder("notepad.exe", "testfile"); proc.start(); &#125; catch (Exception e) &#123; System.out.println("Error executing notepad."); &#125; &#125;&#125; 2. 新增Formatter格式化器(Formatter)Formatter类是Java5中新增的printf-style格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的Java类型，如byte，java.math.BigDecimal和java.util.Calendar都支持。 通过java.util.Formattable接口提供了针对任意用户类型的有限格式定制。 更详细的介绍见这里。主要使用方法的代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.io.BufferedReader;import java.io.FileReader;import java.text.MessageFormat;import java.text.SimpleDateFormat;import java.util.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 格式化测试使用的示例类. * * @author blinkfox on 2017-11-28. */public class FormatTester &#123; private static final Logger log = LoggerFactory.getLogger(FormatTester.class); /** * 格式化. */ private static void formatter() &#123; StringBuilder sb = new StringBuilder(); Formatter formatter = new Formatter(sb, Locale.US); // 可重新排序输出. formatter.format("%n%4$2s %3$2s %2$2s %1$2s %n", "a", "b", "c", "d"); // -&gt; " d c b a" formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E); // -&gt; "e = +2,7183" formatter.format("%nAmount gained or lost since last statement: $ %(,.2f", 6217.58); // -&gt; "Amount gained or lost since last statement: $ 6,217.58" log.info("打印出格式化后的字符串:&#123;&#125;", formatter); formatter.close(); &#125; /** * printf打印. */ private static void printf() &#123; String filename = "testfile"; try (FileReader fileReader = new FileReader(filename)) &#123; BufferedReader reader = new BufferedReader(fileReader); String line; int i = 1; while ((line = reader.readLine()) != null) &#123; System.out.printf("Line %d: %s%n", i++, line); &#125; &#125; catch (Exception e) &#123; System.err.printf("Unable to open file named '%s': %s", filename, e.getMessage()); &#125; &#125; /** * stringFormat使用. */ private static void stringFormat() &#123; // 格式化日期. Calendar c = new GregorianCalendar(1995, Calendar.MAY, 23); String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c); // -&gt; s == "Duke's Birthday: May 23, 1995" log.info(s); &#125; /** * 格式化消息. */ private static void messageFormat() &#123; String msg = "欢迎光临，当前（&#123;0&#125;）等待的业务受理的顾客有&#123;1&#125;位，请排号办理业务！"; MessageFormat mf = new MessageFormat(msg); String fmsg = mf.format(new Object[]&#123;new Date(), 35&#125;); log.info(fmsg); &#125; /** * 格式化日期. */ private static void dateFormat() &#123; String str = "2010-1-10 17:39:21"; SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss"); try &#123; log.info("格式化后的日期:&#123;&#125;", format.format(format.parse(str))); &#125; catch (Exception e) &#123; log.error("日期格式化出错！", e); &#125; &#125; public static void main(String[] args) &#123; formatter(); stringFormat(); messageFormat(); dateFormat(); printf(); &#125;&#125; 3. 新增Scanner类(Scanner)java.util.Scanner是Java5的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。 (1). Scanner概述可以从字符串(Readable)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。 Scanner默认使用空格作为分割符来分隔文本，但允许你使用useDelimiter(Pattern pattern)或useDelimiter(String pattern)方法来指定新的分隔符。 主要API如下： delimiter(): 返回此Scanner当前正在用于匹配分隔符的Pattern。 hasNext(): 判断扫描器中当前扫描位置后是否还存在下一段。 hasNextLine(): 如果在此扫描器的输入中存在另一行，则返回true。 next(): 查找并返回来自此扫描器的下一个完整标记。 nextLine(): 此扫描器执行当前行，并返回跳过的输入信息。 (2). 扫描控制台输入当通过new Scanner(System.in)创建了一个Scanner实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。 123456789101112131415161718/*** 扫描控制台输入.** @author blinkfox 2017-11-28*/public class ScannerTest &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.println("请输入字符串："); while (true) &#123; String line = s.nextLine(); if (line.equals("exit")) break; System.out.println("&gt;&gt;&gt;" + line); &#125; &#125;&#125; (3).其它示例该示例中会从myNumbers文件中读取长整型long的数据。 1234Scanner sc = new Scanner(new File("myNumbers"));while (sc.hasNextLong()) &#123; long aLong = sc.nextLong();&#125; 以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目： 1234567String input = "1 fish 2 fish red fish blue fish";Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*");System.out.println(s.nextInt());System.out.println(s.nextInt());System.out.println(s.next());System.out.println(s.next());s.close(); 将输出： 123412redblue 4. 增强反射功能(Reflection)Java5反射功能方面的增强主要在java.lang.Class和java.lang.reflect类中。 主要有以下内容增强： 支持泛型: 可以检查类型、方法、构造方法或字段的声明并获取泛型所对应的类型信息。 支持注解: 通过使用getAnnotation()方法获取已经在运行时标记为可用的方法和构造方法的类型，方法，字段，构造方法和形式参数的注释。人们还可以确定一个接口是否是一个注解类型。 支持枚举: 可以确定一个类是否是一个枚举，以及一个字段是否代表一个枚举常量。 支持可变参数: 可以确定一个方法或构造方法是否是可变参数方法。 便利的方法: 用于确定一个类是否是本地的、匿名的还是成员类，以及一个类型的简单名称是什么。 java.lang.Class类型标记: 允许使用java.lang.Class的实例作为类型标记。 5. 增强集合框架(Collections Framework)在Java5中集合框架的增强主要在以下几个方面： 三种新语言特性都有针对集合，包括泛型，增强for循环和自动装箱。 三个新的接口已被添加到集合框架中，分别是：Queue，BlockingQueue和ConcurrentMap（后两个位于java.util.concurrent包中）。 提供了两个新的具体队列实现(PriorityQueue、ConcurrentLinkedQueue)，一个现有的列表实现已经被改造来实现队列(LinkedList)，并且提供了一个抽象队列实现(AbstractQueue)。 已经添加了五个阻塞队列实现，以及一个ConcurrentMap实现，分别是：ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, DelayQueue, SynchronousQueue、ConcurrentHashMap。 为类型安全的枚举提供了特殊用途的Map和Set实现。(EnumMap和EnumSet) 添加了特殊用途的copy-on-writeList和Set实现，分别是：CopyOnWriteArrayList和CopyOnWriteArraySet。 提供了包装器的实现来对大多数Collection接口添加动态类型安全性的检查(Collections.checkedInterface)。检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。 提供了几个新的算法来处理集合。 frequency(Collection&lt;?&gt; c, Object o) - 计算指定集合中指定元素出现的次数。 disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) - 判断两个集合是否不相交，换句话说，是否它们不包含任何共同的元素。 addAll(Collection&lt;? super T&gt; c, T... a) - 将指定数组中的所有元素添加到指定的集合中。 Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) - 返回一个比较器，表示指定比较器的反向排序。 提供了计算哈希代码和字符串表示的方法。Arrays工具类已经为所有类型的数组提供了基于内容的hashCode和toString方法。 这些方法补充了现有的equals方法。现在可以打印任何数组的内容。 6. 并发工具类(Concurrency Utilities)java.util.concurrent，java.util.concurrent.atomic和java.util.concurrent.locks包为开发并发类应用程序提供了一个强大的，可扩展的高性能，可伸缩，线程安全构建框架，包括 线程池，线程安全集合，信号量，任务调度框架，任务同步实用程序，原子变量和锁。将这些软件包添加到核心类库可以使程序员免去手工制作这些工具的需要，这与集合框架用于数据结构的方式大致相同。关于并发相关的的介绍会在以后更详细的来讲解。 7. StringBuilderStringBuilder也是Java5中新增的类，主要用来代替+号和StringBuffer来更加高效的拼接字符串。StringBuffer与StringBuilder都是继承于AbstractStringBuilder，主要的区别就是StringBuffer的函数上都有synchronized关键字，保证线程安全。 关于StringBuilder的使用这里就不再详细介绍了，网上文章也有很多。总之，对于动态字符串的拼接推荐使用StringBuilder。静态字符串的拼接直接使用+号或者字符串的concat(String str)方法，甚至也使用StringBuilder亦可。 九、其它(others) Instrumentation: 使用java.lang.instrument，开发者可以构建一个代理，用来监测运行在JVM上的程序。它类似一种更低级，更松耦合的AOP，可以从底层来改变一个类的行为。 Networking: 网络编程功能增强。 Internationalization: 国际化是设计一个应用程序的过程，以便它可以适应各种语言和地区而无需改变工程。国际化这个术语缩写为i18n，因为在第一个i和最后一个n之间有18个字母。 改善了环境变量的支持: System.getenv(String)方法不再被弃用。新的System.getenv()方法允许作为Map &lt;String，String&gt;访问进程环境。 JAXP: 用于XML处理的Java API(JAXP)包括通过标准化的Java平台API来处理XML文档的基本设施。 Serialization: 已经添加了支持来处理5.0版本中新增的枚举类型。序列化枚举实例的规则与序列化普通可序列化对象的规则不同：枚举实例的序列化形式仅由其枚举常量名以及标识其基本枚举类型的信息组成。 反序列化行为也不相同 - 类信息用于查找适当的枚举类，并且Enum.valueOf方法与该类和所接收的常量名称一起被调用，以便获取返回的枚举常量。 监控和管理: Java5为Java平台的监视和管理提供了显着的增强。 … 参考文档: Java5的新特性 Oracle Java文档]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解的理解和应用]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概述1. 什么是注解注解(Annotation)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从Java5开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。 比如，下面这段代码： 1234@Overridepublic String toString() &#123; return "This is String.";&#125; 上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我们不使用@Override注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。 2. 为什么要引入注解使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。 假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。 另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。 目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。 Java基本注解在java.lang包下，JAVA提供了5个基本注解。 1. @Override@Override用于标注重写了父类的方法。对于子类中被@Override修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。@Override只能作用于方法，不能作用于其他程序元素。 2. @Deprecated@Deprecated用于表示某个程序元素（类、方法等）已过时。如果使用了被@Deprecated修饰的类或方法等，编译器会发出警告。 3. @SuppressWarnings@SuppressWarnings用于抑制编译器的警告。指示被@SuppressWarnings修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法）取消显示指定的编译器警告。例如，常见的@SuppressWarnings（value=&quot;unchecked&quot;）。 SuppressWarnings注解的常见参数值主要有以下几种： deprecation：使用了不赞成使用的类或方法时的警告(使用@Deprecated使得编译器产生的警告)； unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告 fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告; path：在类路径、源文件路径等中有不存在的路径时的警告; serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; finally：任何 finally 子句不能正常完成时的警告; all：关于以上所有情况的警告。 4. @SafeVarargs@SafeVarargs是JDK 7 专门为抑制堆污染警告提供的。 5. @FunctionalInterface@FunctionalInterface是Java8中新增的函数式接口。Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口称为函数式接口。如以下代码： 1234567891011121314@FunctionalInterfacepublic interface Fun &#123; static void foo() &#123; System.out.println("foo类方法")； &#125; default void bar() &#123; System.out.println("bar默认方法")； &#125; void test(); //只定义了一个抽象方法&#125; 注：如在上面的接口中再加一个抽象方法abc()，则会编译出错。 元注解元注解(meta-annotation)是指注解的注解。Java5定义了5个标准的元注解类型，它们被用来提供对其它注解的类型作说明。接下来介绍这五个元注解。 1. @Retention@Retention指明了该注解被保留的时间长短。包含一个名为value的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。value成员变量的值只能是如下3个： SOURCE：只保留在源代码中，编译器编译时，直接丢弃这种注解，不记录在.class文件中。 CLASS：编译器把注解记录在class文件中。当运行Java程序时，JVM中不可获取该注解信息，这是默认值。 RUNTIME：编译器把注解记录在class文件中。当运行Java程序时，JVM可获取该注解信息，程序可以通过反射获取该注解的信息。 2. @Target@Target指定注解用于修饰哪些程序元素。@Target也包含一个名为value的成员变量，该value成员变量类型为ElementType[]，ElementType也为枚举类型，值有如下几个： TYPE：修饰类、接口或枚举类型 FIELD：修饰成员变量（包括枚举常量） METHOD：修饰方法 PARAMETER：修饰参数 CONSTRUCTOR：修饰构造器 LOCAL_VARIABLE：修饰局部变量 ANNOTATION_TYPE：修饰注解 PACKAGE：修饰包 TYPE_PARAMETER：Java8新增，修饰类型参数。 TYPE_USE：Java8新增，可以在任何类型上使用 类型注解（Java8新增）在 Java8 之前的版本中，只能允许在声明式前使用注解。而在 Java8 版本中，注解可以被用在任何使用 Type 的地方，例如：初始化对象时 (new)，对象类型转化时，使用 implements 表达式时，或者使用 throws 表达式时。 1234567891011121314//初始化对象时String myString = new @NotNull String();//对象类型转化时myString = (@NonNull String) str;//使用 implements 表达式时class MyList&lt;T&gt; implements @ReadOnly List&lt;@ReadOnly T&gt;&#123; ...&#125; //使用 throws 表达式时public void validateValues() throws @Critical ValidationFailedException&#123; ... &#125; 定义一个类型的方法与普通的注解类似，只需要指定Target为ElementType.TYPE_PARAMETER或者ElementType.TYPE_USE，或者同时指定这两个Target。 1234@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)public @interface MyAnnotation &#123; ...&#125; ElementType.TYPE_PARAMETER表示这个注解可以用在 Type 的声明式前，而ElementType.TYPE_USE表示这个注解可以用在所有使用 Type 的地方（如：泛型，类型转换等） 与 Java 8 之前的注解类似的是，类型也可以通过设置 Retention 在编译后保留在 class 文件中（RetentionPolicy.CLASS）或者运行时可访问（RetentionPolicy.RUNTIME）。但是与之前不同的是，类型注解有两个新的特性：在本地变量上的注解可以保留在class文件中，以及泛型类型可以被保留甚至在运行时被访问。 虽然类型可以保留在 class 文件中，但是它并不会改变程序代码本身的行为。例如在一个方法前加上注解，调用此方法返回的结果和不加注解的时候一致。 Java8 通过引入类型，使得开发者可以在更多的地方使用注解，从而能够更全面地对代码进行分析以及进行更强的类型检查。 3. @Inherited@Inherited指定注解具有继承性。如果某个类使用了@xxx注解（定义该注解时使用了@Inherited修饰）修饰，则其子类将自动被@xxx修饰。 4. @Documented如果定义注解A时，使用了@Documented修饰定义，则在用Javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。 5. @Repeatable（Java8新增）@Repeatable表示可重复注解。在实际应用中，可能会出现需要对同一个声明式或者类型加上相同的注解（包含不同的属性值）的情况。例如系统中除了管理员之外，还添加了超级管理员这一权限，对于某些只能由这两种角色调用的特定方法，可以使用可重复注解。 12345@Access(role="SuperAdministrator")@Access(role="Administrator")public void doCheck() &#123; ...&#125; Java8之前版本的 JDK 并不允许开发者在同一个声明式前加注同样的注解，（即使属性值不同）这样的代码在编译过程中会提示错误。而 Java8 解除了这一限制，开发者可以根据各自系统中的实际需求在所有可以使用注解的地方使用可重复注解。 由于兼容性的缘故，可重复注解并不是所有新定义的注解的默认特性，需要开发者根据自己的需求决定新定义的注解是否可以重复注解。Java 编译器会自动把可重复注解储存到指定的注解容器中。而为了触发编译器进行这一操作，开发者需要进行以下的定义： 首先，在需要重复标注特性的注解前加上@Repeatable标签，示例如下： 123456@Repeatable(AccessContainer.class)public @interface Access &#123; String role();&#125; @Repeatable标签后括号中的值即为指定的注解容器的类型。在这个例子中，注解容器的类型是AccessContainer，Java 编译器会把重复的 Access 对象保存在 AccessContainer 中。 AccessContainer 中必须定义返回数组类型的 value 方法。数组中元素的类型必须为对应的可重复注解类型。具体示例如下： 123public @interface AccessContainer &#123; Access[] value();&#125; 可以通过 Java 的反射机制获取注解的 Annotation。一种方式是通过 AnnotatedElement 接口的getAnnotationByType(Class&lt;T&gt;)。首先获得 Container Annotation，然后再通过 Container Annotation 的 value 方法获得可重复注解。另一种方式是用过 AnnotatedElement 接口的getAnnotations(Class&lt;T&gt;)方法一次性返回可重复注解。 可重复注解使得开发者可以根据具体的需求对同一个声明式或者类型加上同一类型的注解，从而增加代码的灵活性和可读性。 自定义注解及解析1. 自定义注解创建Java的自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。我们可以为注解声明方法。我们先来看看一个自定义注解的示例： 12345678910111213141516171819202122import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inherited@Documentedpublic @interface MethodInfo &#123; String author() default 'blinkfox'; String date(); int revision() default 1; String comments();&#125; 自定义注解就需要用到上面所介绍到的几种元注解，可以看出元注解就是用来注解其它注解。自定义注解和接口类似，只能定义方法，注解中的方法需要遵循以下几种规则： 注解方法不能带有参数； 注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组； 注解方法可以有默认值。 2. 注解的解析要解析Java中的注解需要使用Java反射技术。那么注解的RetentionPolicy应该设置为RUNTIME，否则Java类的注解信息在执行过程中将不可用，我们也就不能从中得到任何和注解有关的数据。以下是解析注解常用的几种方法的示例代码： 123456789101112131415161718192021222324252627282930313233import java.lang.annotation.Annotation;import java.lang.reflect.Method;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class AnnotationParsing &#123; private static final Logger log = LoggerFactory.getLogger(AnnotationParsing.class); public static void main(String[] args) &#123; try &#123; for (Method method : AnnotationParsing.class.getClassLoader() .loadClass(('com.journaldev.annotations.AnnotationExample')).getMethods()) &#123; // checks if MethodInfo annotation is present for the method if (method.isAnnotationPresent(com.journaldev.annotations.MethodInfo.class)) &#123; // iterates all the annotations available in the method for (Annotation anno : method.getDeclaredAnnotations()) &#123; System.out.println('Annotation in Method ''+ method + '' : ' + anno); &#125; MethodInfo methodAnno = method.getAnnotation(MethodInfo.class); if (methodAnno.revision() == 1) &#123; System.out.println('Method with revision no 1 = '+ method); &#125; &#125; &#125; &#125; catch (Exception e) &#123; log.error("解析Java注解出错!", e); &#125; &#125;&#125; 注解的应用之监控方法执行耗时通过前面对元注解的介绍，我们就可以自定义我们需要的注解了。假如，我们需要监控某些方法的执行，最原始的办法就是在方法执行的开头和结尾分别记录时间，最后计算前后的时间差即可，但是这些代码与核心业务无关，且大量重复、分散在各处，维护起来也困难。这时我们可以使用Spring AOP来统计方法的执行耗时，同时我们也可以使用注解的方式来实现，更自由灵活。 首先，定义我们的执行耗时的方法上的注解： 123456789101112131415161718192021222324import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义'统计方法耗时'并打印日志的注解. * * @author blinkfox on 2017-01-04. */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)@Documentedpublic @interface CostTime &#123; /** * 执行超过某毫秒数时数则打印'warn'级别的日志，默认 0ms，即默认都打印. * * @return 毫秒数 */ long value() default 0;&#125; 然后，书写监控所标注有@CostTime注解的方法代理类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 被标注为'@CostTime'注解的方法执行耗时的代理方法. * &lt;p&gt;实现了cglib中的`MethodInterceptor`的方法拦截接口.&lt;/p&gt; * * @author blinkfox on 2017-01-04. */public class CostTimeProxy implements MethodInterceptor &#123; private static final Logger log = LoggerFactory.getLogger(CostTimeProxy.class); private Enhancer enhancer = new Enhancer(); /** * 获取代理类. * * @param cls 代理类的class * @return 代理类实例 */ public Object getProxy(Class cls) &#123; enhancer.setSuperclass(cls); enhancer.setCallback(this); return enhancer.create(); &#125; /** * 拦截方法,判断是否有'@CostTime'的注解，如果有则拦截执行. * * @param o 对象 * @param method 方法 * @param args 参数 * @param methodProxy 代理方法 * @return 对象 * @throws Throwable 问题 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; // 判断该方法上是否有 CostTime 注解 if (!method.isAnnotationPresent(CostTime.class)) &#123; return methodProxy.invokeSuper(o, args); &#125; // 获取注解信息 CostTime costTime = method.getAnnotation(CostTime.class); long limitTime = costTime.value(); // 记录方法执行前后的耗时时间，并做差，判断是否需要打印方法执行耗时 long startTime = System.currentTimeMillis(); Object result = methodProxy.invokeSuper(o, args); long diffTime = System.currentTimeMillis() - startTime; if (limitTime &lt;= 0 || (diffTime &gt;= limitTime)) &#123; String methodName = method.getName(); // 打印耗时的信息 log.warn("【CostTime监控】通过注解监控方法'&#123;&#125;'的执行耗时为:&#123;&#125;", methodName, diffTime); &#125; return result; &#125;&#125; 接着，可以写一些业务类及方法，这里就以A类为例： 1234567891011121314151617181920212223242526272829import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * A类. * * @author blinkfox on 2017/1/1. */public class A &#123; private static final Logger log = LoggerFactory.getLogger(A.class); /** * 始终打印方法执行耗时的方法. */ @CostTime public void doSomeThing() &#123; log.info("执行A类中doSomeThing()方法！"); &#125; /** * 当方法执行耗时大于等于'50ms'时打印出方法执行耗时. */ @CostTime(50) public void doSomeThing2() &#123; log.info("执行A类中doSomeThing2()方法！"); &#125;&#125; 最后，是用来测试A类某些业务方法执行耗时的测试类： 123456789101112131415161718192021222324252627package com.blinkfox.test.reflect;/** * 耗时注解使用测试示例 * Created by blinkfox on 2017-01-04. */public class CostTimeTest &#123; /** A类的全局实例. */ private static A a; static &#123; CostTimeProxy aproxy = new CostTimeProxy(); a = (A) aproxy.getProxy(A.class); &#125; /** * main 方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; a.doSomeThing(); a.doSomeThing2(); &#125;&#125; 这就完成了对A类被标注了@CostTime注解的方法执行耗时的监控。当然你可以配置需要扫描的包(package)下的所有类中被标注为@CostTime注解的方法的执行耗时，这里就不介绍了。 参考文档： Java注解教程及自定义注解 Java 8 Annotation 新特性在软件质量和开发效率方面的提升 Java内置系统注解和元注解]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射基础]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、概述1. 简介Java反射(Reflection)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过java.lang.Class类来实现的，在Java中，Object 类是所有类的根类，而Class类就是描述Java类的类。 注：因为Class类也是类，所以Object也包括Class类。 2. 主要功能Java反射框架主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法； 修改构造函数、方法、属性的可见性。 3. 主要用途反射最重要的用途就是开发各种通用框架。很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。 二、反射的使用1. 获取Class对象反射的各种功能都需要通过Class对象来实现，因此，需要知道如何获取Class对象，主要有以下几种方式。 使用 Class.forName() 的静态方法Class.forName(String className)方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。 1Class&lt;?&gt; cls = Class.forName("com.blinkfox.Zealot"); 直接获取某个类的class(最安全/性能最好)1Class&lt;String&gt; cls = String.class; 调用某个对象的 getClass() 方法1Class&lt;String&gt; cls = str.getClass(); 2. 判断是否为某个类的实例一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法： 1public native boolean isInstance(Object obj); 3. 创建实例通过反射来生成对象主要有两种方式。 使用Class对象的newInstance()方法12Class&lt;?&gt; c = String.class;Object str = c.newInstance(); 通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法1234567// 获取String所对应的Class对象Class&lt;?&gt; c = String.class;// 获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);// 根据构造器创建实例Object obj = constructor.newInstance("23333");System.out.println(obj); 注：这种方法可以用指定的构造器构造类的实例。 4. 获取方法获取某个Class对象的方法集合，主要有以下几个方法： getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 1public Method[] getDeclaredMethods() throws SecurityException getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 1public Method[] getMethods() throws SecurityException getMethod()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。 1public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test &#123; public static void test() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; c = MethodClass.class; Object object = c.newInstance(); Method[] methods = c.getMethods(); Method[] declaredMethods = c.getDeclaredMethods(); //获取MethodClass类的add方法 Method method = c.getMethod("add", int.class, int.class); //getMethods()方法获取的所有方法 System.out.println("getMethods获取的方法："); for(Method m: methods) &#123; System.out.println(m); &#125; //getDeclaredMethods()方法获取的所有方法 System.out.println("getDeclaredMethods获取的方法："); for(Method m: declaredMethods) &#123; System.out.println(m); &#125; &#125;&#125;class MethodClass &#123; public final int fuck = 3; public int add(int a, int b) &#123; return a + b; &#125; public int sub(int a, int b) &#123; return a - b; &#125;&#125; 注：通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。 5. 获取构造方法获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例: 1public T newInstance(Object ... initargs) 注：此方法可以根据传入的参数来调用对应的Constructor创建对象实例。 6. 获取类的成员变量信息获取的方法同Method相似，主要是这几个方法，在此不再赘述： Field getField(String name): 访问公有的成员变量。 Field[] getDeclaredFields()：所有已声明的成员变量。但不能得到其父类的成员变量。 Field[] getFields()和Field[] getDeclaredFields()用法同上。 7. 调用方法当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为: 12public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 代码示例： 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; klass = MethodClass.class; //创建 MethodClass 的实例 Object obj = klass.newInstance(); //获取 MethodClass 类的add方法 Method method = klass.getMethod("add", int.class, int.class); //调用 method 对应的方法 =&gt; add(1,4) Object result = method.invoke(obj, 1, 4); System.out.println(result); &#125;&#125;class MethodClass &#123; public final int fuck = 3; public int add(int a, int b) &#123; return a + b; &#125; public int sub(int a, int b) &#123; return a - b; &#125;&#125; 8. 利用反射创建数组数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子： 12345678910111213public static void testArray() throws ClassNotFoundException &#123; // 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组. Class&lt;?&gt; cls = Class.forName("java.lang.String"); Object array = Array.newInstance(cls, 25); // 往数组里添加内容 Array.set(array,0, "hello"); Array.set(array,1, "Java"); Array.set(array,2, "Go"); Array.set(array,3, "Scala"); Array.set(array,4, "Clojure"); // 获取某一项的内容 System.out.println(Array.get(array, 3));&#125; 三、使用反射获取信息Class类提供了大量的实例方法来获取该Class对象所对应的详细信息，Class类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考JDK文档。 1. 获取类内信息 构造器: Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 包含的方法: Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 包含的属性: Field getField(String name) 包含的Annotation: &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) 内部类: Class&lt;?&gt;[] getDeclaredClasses() 外部类: Class&lt;?&gt; getDeclaringClass() 所实现的接口: Class&lt;?&gt;[] getInterfaces() 修饰符: int getModifiers() 所在包: Package getPackage() 类名: String getName() 简称: String getSimpleName() 2. 判断类本身信息的方法 是否注解类型: boolean isAnnotation() 是否使用了该Annotation修饰: boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 是否匿名类: boolean isAnonymousClass() 是否数组: boolean isArray() 是否枚举: boolean isEnum() 是否原始类型: boolean isPrimitive() 是否接口: boolean isInterface() obj是否是该Class的实例: boolean isInstance(Object obj) 3. 使用反射获取泛型信息为了通过反射操作泛型以迎合实际开发的需要, Java新增了java.lang.reflect.ParameterizedType、java.lang.reflect.GenericArrayType、java.lang.reflect.TypeVariable、java.lang.reflect.WildcardType几种类型来代表不能归一到Class类型但是又和原始类型同样重要的类型。 ParameterizedType: 一种参数化类型, 比如Collection GenericArrayType: 一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable: 各种类型变量的公共接口 WildcardType: 一种通配符类型表达式, 如?、? extends Number、? super Integer 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Client &#123; private Map&lt;String, Object&gt; objectMap; public void test(Map&lt;String, User&gt; map, String string) &#123; &#125; public Map&lt;User, Bean&gt; test() &#123; return null; &#125; /** * 测试属性类型 * * @throws NoSuchFieldException */ @Test public void testFieldType() throws NoSuchFieldException &#123; Field field = Client.class.getDeclaredField("objectMap"); Type gType = field.getGenericType(); // 打印type与generic type的区别 System.out.println(field.getType()); System.out.println(gType); System.out.println("**************"); if (gType instanceof ParameterizedType) &#123; ParameterizedType pType = (ParameterizedType) gType; Type[] types = pType.getActualTypeArguments(); for (Type type : types) &#123; System.out.println(type.toString()); &#125; &#125; &#125; /** * 测试参数类型 * * @throws NoSuchMethodException */ @Test public void testParamType() throws NoSuchMethodException &#123; Method testMethod = Client.class.getMethod("test", Map.class, String.class); Type[] parameterTypes = testMethod.getGenericParameterTypes(); for (Type type : parameterTypes) &#123; System.out.println("type -&gt; " + type); if (type instanceof ParameterizedType) &#123; Type[] actualTypes = ((ParameterizedType) type).getActualTypeArguments(); for (Type actualType : actualTypes) &#123; System.out.println("\tactual type -&gt; " + actualType); &#125; &#125; &#125; &#125; /** * 测试返回值类型 * * @throws NoSuchMethodException */ @Test public void testReturnType() throws NoSuchMethodException &#123; Method testMethod = Client.class.getMethod("test"); Type returnType = testMethod.getGenericReturnType(); System.out.println("return type -&gt; " + returnType); if (returnType instanceof ParameterizedType) &#123; Type[] actualTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for (Type actualType : actualTypes) &#123; System.out.println("\tactual type -&gt; " + actualType); &#125; &#125; &#125;&#125; 参考文档：Java反射基础]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO 知识整理]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%20IO%20%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[各IO类关系梳理 InputStream: Java IO中的顶级的字节输入流的抽象类，定义了最基础的输入、读取的相关方法。实现了Closeable接口。 FileInputStream: 继承自InputStream的文件输入流类，用于从本地文件中读取字节数据。 ByteArrayInputStream: 继承自InputStream的字节数组输入流类，它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而 ByteArrayInputStream 本质就是通过字节数组来实现的。InputStream通过read()向外提供接口，供它们来读取字节数据；而 ByteArrayInputStream 的内部额外的定义了一个计数器，它被用来跟踪read()方法要读取的下一个字节。 StringBufferInputStream: 继承自InputStream的字节输入流类，其中读取的字节由字符串的内容提供的输入流。该类已过时，不推荐使用，由 StringReader 代替。 PipedInputStream: 继承自InputStream的管道输入流类，在使用管道通信时，必须与 PipedOutputStream 配合使用。让多线程可以通过管道进行线程间的通讯。 ObjectInputStream: 继承自InputStream的对象输入流类，实现了 ObjectInput 和 ObjectStreamConstants 接口。作用是从输入流中读取Java对象和基本数据。只有支持 Serializable 或 Externalizable 接口的对象才能被ObjectInputStream/ObjectOutputStream所操作！ SequenceInputStream: 继承自InputStream的输入合并流类。SequenceInputStream 会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。合并流的作用是将多个源合并合一个源。 AudioInputStream: 继承自InputStream的音频输入流类。音频输入流是具有指定音频格式和长度的输入流。长度用示例帧表示，不用字节表示。提供几种方法，用于从流读取一定数量的字节，或未指定数量的字节。音频输入流跟踪所读取的最后一个字节。可以跳过任意数量的字节以到达稍后的读取位置。音频输入流可支持标记。设置标记时，会记住当前位置，以便可以稍后返回到该位置。 FilterInputStream: 继承自InputStream的过滤输入流类（装饰器超类），是用来“封装其它的输入流，并为它们提供额外的功能”。 BufferedInputStream: 继承自FilterInputStream的带缓冲区功能的输入流类（装饰器子类），默认缓冲区大小是8K，能够减少访问磁盘的次数，提高文件读取性能。 DataInputStream: 继承自FilterInputStream的数据输入流类，实现了 DataInput 接口。它允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。 PushbackInputStream: 继承自FilterInputStream的回退输入流类。允许试探性的读取数据流，如果不是我们想要的则返还回去。 LineNumberInputStream: 继承自FilterInputStream的行号输入流类。可以获取当前的行号或设置当前行号，已过时，已经被 LineNumberReader 替代。 CheckedInputStream: 继承自FilterInputStream的校验输入流类。 CipherInputStream: 继承自FilterInputStream的密钥输入流类。 DigestInputStream: 继承自FilterInputStream的摘要处理输入流类。 InflaterInputStream: 继承自FilterInputStream的解压缩处理输入流类。 GZIPInputStream: 继承自InflaterInputStream的gzip文件处理输入流类。 ZipInputStream: 继承自InflaterInputStream的解压缩处理输入流类。 JarInputStream: 继承自ZipInputStream的解压缩处理输入流类。 DeflaterInputStream: 继承自FilterInputStream的压缩数据输入流类。 ProgressMonitorInputStream: 继承自FilterInputStream的进度监控输入流类。 OutputStream: JavaIO中的顶级的字节输出流的抽象类，定义了最基础的输出、写入的相关方法。实现了Closeable和Flushable接口。 FileOutputStream: 继承自OutputStream的文件输出流类，用于向本地文件中写入字节数据。 ByteArrayOutputStream: 继承自OutputStream的字节数组输出流类，ByteArrayOutputStream 中的数据会被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。 PipedOutputStream: 继承自OutputStream的管道输出流类，在使用管道通信时，必须与 PipedInputStream 配合使用。让多线程可以通过管道进行线程间的通讯。 ObjectOutputStream: 继承自OutputStream的对象输出流类，实现了 ObjectOutput 和 ObjectStreamConstants 接口。作用是把Java对象和基本数据写入到对象输出流中。只有支持 Serializable 或 Externalizable 接口的对象才能被ObjectInputStream/ObjectOutputStream所操作！ FilterOutputStream: 继承自OutputStream的过滤输出流类，是用来“封装其它的输出流，并为它们提供额外的功能”。 BufferedOutputStream: 继承自FilterOutputStream的带缓冲区功能的输出流类，默认缓冲区大小是8K，能够提高文件的写入效率。 DataOutputStream: 继承自FilterOutputStream的数据输出流类，实现了 DataOutput 接口。它允许应用程序以与机器无关方式向底层输入流中写入基本 Java 数据类型。 PrintStream: 继承自FilterOutputStream的打印输出流类，实现了 Appendable 和 Closeable 接口。使它们能够方便地打印各种数据值表示形式。PrintStream 永远不会抛出 IOException。PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。 CheckedOutputStream: 继承自FilterOutputStream的校验输出流类。 CipherOutputStream: 继承自FilterOutputStream的密钥输出流类。 DigestOutputStream: 继承自FilterOutputStream的摘要处理输出流类。 InflaterOutputStream: 继承自FilterOutputStream的解压缩处理输出流类。 DeflaterOutputStream: 继承自FilterOutputStream的解压缩数据输出流类。 GZIPOutputStream: 继承自DeflaterOutputStream的gzip文件解压缩输出流类。 ZipOutputStream: 继承自DeflaterOutputStream的zip文件解压缩输出流类。 JarOutputStream: 继承自ZipOutputStream的zip文件解压缩输出流类。 Reader: JavaIO中的顶级的字符读取的抽象类，定义了最基础的读取方法。实现了 Readable 和 Closeable 接口。 BufferedReader: 继承自Reader的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。创建 BufferReader 时，我们会通过它的构造函数指定某个 Reader 为参数。BufferReader 会将该 Reader 中的数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从 Reader 中读取下一部分的数据。 LineNumberReader: 继承自BufferedReader，可以获取当前的行号或设置当前行号。 InputStreamReader: 继承自Reader，用于将从字节流转换成字符流的 Reader。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。 FileReader: 继承自InputStreamReader，用来读取字符文件的便捷类。 StringReader: 继承自Reader，用于字符串读取的字符流。 CharArrayReader: 继承自Reader的字符数组输入流类。 FilterReader: 继承自Reader的字符过滤输入流抽象类。 PushbackReader: 继承自FilterReader的字符回退输入流类。 PipedReader: 继承自Reader的字符管道输入流类。作用是可以通过管道进行线程间的通讯。必须和 PipedWriter 配合使用。 Writer: JavaIO中的顶级的字符写入的抽象类，定义了最基础的写入方法。实现了 Appendable 、 Closeable 和 Flushable 接口。 BufferedWriter: 继承自Writer的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输出流中写入字符到文本中，缓冲各个字符，从而实现字符、数组和行的高效写入。 OutputStreamWriter: 继承自Reader，用于将从字节流转换成字符流的 Writer。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。 FileWriter: 继承自OutputStreamWriter，用来向文件中写入字符的便捷类。 FilterWriter: 继承自Writer的字符过滤输出流抽象类。与 FilterOutputStream 功能一样、只是简单重写了父类的方法、目的是为所有装饰类提供标准和基本的方法、要求子类必须实现核心方法、和拥有自己的特色。这里 FilterWriter 没有子类、可能其意义只是提供一个接口、留着以后的扩展，本身是一个抽象类。 StringWriter: 继承自Writer，用于字符串写入的字符流。 PipedWriter: 继承自Writer的字符管道输出流类。作用是可以通过管道进行线程间的通讯。必须和 PipedReader 配合使用。 CharArrayWriter: 继承自Writer的字符数组输出流类。 PrintWriter: 继承自Writer的打印写入类，提供了PrintStream的所有打印方法，其方法也从不抛出IOException。与PrintStream的区别：作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream类型的字节流，还能够封装Writer类型的字符输出流并增强其功能。 IO UML类图 流的分类 字节流和字符流： 字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。 字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 输出流和输入流： 输入流：从文件读入到内存。只能进行读操作。 输出流：从内存读出到文件。只能进行写操作。 节点流和处理流： 节点流：直接与数据源相连，读入或读出。 处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。 注：输入输出流中的入和出，都是相对于系统内存而言的。为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。 流中主要方法梳理InputStream中的主要方法 abstract int read(): 从流中读取数据，读取一个字节，返回值为所读得字节 int read(byte b[]): 从流中读取数据，读取多个字节，放置到字节数组 b 中，通常读取的字节数量为 b 的长度，返回值为实际独取的字节的数量。 int read(byte b[], int off, int len): 从流中读取数据，读取 len 个字节，放置到以下标 off 开始字节数组 b 中，返回值为实际读取的字节的数量。 long skip(long n): 读指针跳过n个字节不读，返回值为实际跳过的字节数量。 int available(): 返回值为流中尚未读取的字节的数量。 void close(): 关闭输入流。 synchronized void mark(int readlimit): 记录当前指针的所在位置，readlimit表示读指针读出的readlimit个字节后，所标记的指针位置才实效。 synchronized void reset(): 把读指针重新指向用 mark 方法所记录的位置。 boolean markSupported(): 当前的流是否支持读指针的记录功能。 注：其中read()返回的是读入的一个字节所对应的 int 值(0-255),而read(byte[] b)和read(byte[] b, int off, int len)返回的是读入的字节数。 OutputStream中的主要方法 abstract void write(int b): 输出数据，往流中写一个字节 b。 void write(byte b[]): 输出数据，往流中写一个字节数组 b。 void write(byte b[], int off, int len): 输出数据，把字节数组 b 中从下标 off 开始，长度为 len 的字节写入到流中。 void flush(): 刷空输出流，并输出所有被缓存的字节。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。 void close(): 关闭输出流。 Reader中的主要方法 int read(java.nio.CharBuffer target): 试图读取字符入指定的字符缓冲区。 int read(): 读取单个字符。 int read(char cbuf[]): 读取字符到一个数组中。 int read(char cbuf[], int off, int len): 读取字符到一个数组中的一部分。 long skip(long n): 跳过n个字符。 boolean ready(): 通知此流是否已准备好被读取。 boolean markSupported(): 告诉此流是否支持mark()操作。 void mark(int readAheadLimit): 标记流中的当前位置。 void reset(): 重置流。 void close(): 关闭该流并释放与之关联的所有系统资源。 Writer中的主要方法 void write(int c): 写入单个字符。 void write(char cbuf[]): 写入字符数组。 abstract void write(char cbuf[], int off, int len): 写入字符数组的一部分。 void write(String str): 写入一个字符串。 void write(String str, int off, int len): 写入一个字符串的一部分。 Writer append(CharSequence csq): 将指定的字符序列追加写到writer中。 Writer append(CharSequence csq, int start, int end): 将指定的字符序列的子序列追加写入此writer。 Writer append(char c): 将指定字符追加到这个writer。 abstract void flush(): 刷新流。 abstract void close(): 关闭流，但要先刷新它。 使用示例FileInputStream 和 FileOutputStream1234567891011121314151617/** * 测试复制文件a.txt中的内容到b.txt文件中. */private static void testCopyByFileStream() &#123; try ( InputStream in = new FileInputStream("G:/test/a.txt"); OutputStream out = new FileOutputStream("G:/test/b.txt", true) ) &#123; int len; byte[] b = new byte[1024]; while ((len = in.read(b)) != -1) &#123; out.write(b, 0, len); &#125; &#125; catch (IOException e) &#123; log.error("文件读取写入失败!", e); &#125;&#125; BufferedInputStream 和 BufferedOutputStream1234567891011121314151617/** * 测试通过 BufferedInputStream 和 BufferedOutputStream 来复制文件a.txt中的内容到b.txt文件中. */private static void testCopyByBufferedStream() &#123; try ( InputStream in = new BufferedInputStream(new FileInputStream("G:/test/a.txt")); OutputStream out = new BufferedOutputStream(new FileOutputStream("G:/test/b.txt")) ) &#123; int len; byte[] b = new byte[1024]; while ((len = in.read(b)) != -1) &#123; out.write(b, 0, len); &#125; &#125; catch (IOException e) &#123; log.error("通过缓冲区的方式来做文件读取写入失败!", e); &#125;&#125; ByteArrayOutputStream1234567891011121314151617/** * 测试将内容写入到ByteArrayOutputStream中并打印出来，不需要关闭流. */private static void testByByteArrayStream() &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(8); String str = "Hello World!"; try &#123; byteOut.write(str.getBytes()); &#125; catch (IOException e) &#123; log.error("写入字节数据出错!", e); &#125; byte[] buf = byteOut.toByteArray(); for (byte b : buf) &#123; log.info("&#123;&#125;", (char) b); &#125;&#125; PipedInputStream 和 PipedOutputStream1234567891011121314151617181920212223242526272829303132/** * 发送消息的线程. * * @author blinkfox on 2017/10/19. */public class Sender extends Thread &#123; private static final Logger log = LoggerFactory.getLogger(Sender.class); /** 管道输出流对象,它和管道输入流(PipedInputStream)对象绑定.从而可以将数据发送给“管道输入流”. */ private PipedOutputStream pipedOut; public Sender(PipedOutputStream pipedOut) &#123; this.pipedOut = pipedOut; &#125; public PipedOutputStream getPipedOut() &#123; return pipedOut; &#125; @Override public void run() &#123; String strInfo = "Hello World!" ; try &#123; pipedOut.write(strInfo.getBytes()); pipedOut.close(); &#125; catch (IOException e) &#123; log.error("向管道中写入数据出错!", e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * 接收消息的线程. * * @author blinkfox on 2017/10/19. */public class Receiver extends Thread &#123; private static final Logger log = LoggerFactory.getLogger(Receiver.class); /** 管道输入流对象,它和管道输出流(PipedOutputStream)对象绑定.从而可以接收“管道输出流”的数据. */ private PipedInputStream pipedIn; public Receiver(PipedInputStream pipedIn) &#123; this.pipedIn = pipedIn; &#125; public PipedInputStream getPipedIn() &#123; return pipedIn; &#125; @Override public void run() &#123; byte[] buf = new byte[2048]; try &#123; int len = pipedIn.read(buf); log.info("&#123;&#125;", new String(buf, 0, len)); pipedIn.close(); &#125; catch (IOException e) &#123; log.error("从管道中读取数据出错!", e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930/** * PipedInputStream 和 PipedOutputStream 的测试类. * * @author blinkfox on 2017/10/19. */public class PipedStreamTest &#123; private static final Logger log = LoggerFactory.getLogger(PipedStreamTest.class); /** * 主入口方法. * @param args 字符串数组参数 */ public static void main(String[] args) &#123; Sender sender = new Sender(new PipedOutputStream()); Receiver receiver = new Receiver(new PipedInputStream()); try &#123; // 将管道输入流和管道的输出流进行连接. receiver.getPipedIn().connect(sender.getPipedOut()); // 启动线程 sender.start(); receiver.start(); &#125; catch (IOException e) &#123; log.info("发送接收消息出错!", e); &#125; &#125;&#125; SequenceInputStream123456789101112131415161718/** * 测试使用 testBySequenceStream 合并输入流来统一读取写入. */private static void testBySequenceStream() &#123; try ( InputStream in1 = new FileInputStream("G:/test/a.txt"); InputStream in2 = new FileInputStream("G:/test/b.txt"); OutputStream out = new FileOutputStream("G:/test/c.txt"); SequenceInputStream seqIn = new SequenceInputStream(in1, in2) ) &#123; int len = 0; while ((len = seqIn.read()) != -1) &#123; out.write(len); &#125; &#125; catch (IOException e) &#123; log.error("合并输入流写入失败!", e); &#125;&#125; PrintStream12345678910111213/** * 测试使用 PrintStream 将数据输出到指定的文件. */private static void testOutputByPrintStream() &#123; System.out.println("Hello World!"); File file = new File("G:/test/d.txt"); try &#123; System.setOut(new PrintStream(new FileOutputStream(file))); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println("这些内容在文件中才能看到哦！");&#125; 遵循的设计原则 单一职责原则：每一个IO类的都具有单独的功能和职责，需要对某种类型的流做修改时，只需要修改具体对应的IO流类即可。 里氏替换原则：子类完全实现了父类的方法，且有自己的个性，子类覆盖或实现父类的方法时输入参数和返回结果的范围没有变化。 接口隔离原则：输入输出流所实现的接口有所不同，而且接口比较细化，接口中的方法少。 依赖倒置原则：Java IO中的各个具体的功能类，都继承或聚合了InputStream/OutputStream的抽象类，都共同依赖了抽象，而不是依赖了某个具体的功能的IO类。 开闭原则：当用户需要新增一种新特征、新方式的IO流时，可以直接新增一种类的流，让其继承或聚合InputStream/OutputStream/FilterInputStream/FilterOutputStream等类，从而来书写其特有的功能，减少。 聚合/组合复用原则：就比如FileInputStream中对FileDescriptor和FileChannel的使用，都是采用了聚合的方式，而非继承的方式，从而使类之间的耦合度降低，提高了灵活性。 使用到的设计模式装饰器模式由于java I/O库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是java I/O库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用java IO库时，必须理解java IO库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。 以字节输入流为例。InputStream是需要被装饰的抽象构件，而其下的FileInputStream、ByteArrayInputStream等是被装饰的具体构件；FilterInputStream是装饰器的父类，BufferedInputStream、DataInputStream则是具体的装饰器类。 适配器模式适配器模式是java IO库中第二个重要的设计模式。如：StringBufferInputStream就是一个适配器类。它继承了InputStream类型，同时持有一个对String类型的引用。这是将String对象适配成InputStream类型的对象形式的适配器模式。PipedOutputStream也是一个适配器类。PipedOutputStream总是和PipedInputStream一起使用，它接收一个类型为PipedInputStream的输入类型，并将之转换成OutputStream类型的输出流，这是一个对象形式的适配器模式应用。 设计的优缺点优点 功能全面、强大和灵活，同时还防止了过多的类膨胀 符合开闭原则，开发可以通过各种装配能实现各种功能 缺点 复杂难记，API使用繁琐。如：Jdk1.6中，从文本文件中读取数据转换为字符串，就得至少10行代码。 IO流中的绝大多数方法都有IOException的检查异常，导致开发人员不得不在各个使用到的地方捕捉或再抛出异常，代码繁琐，不符合当前的主流设计思路。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之责任链模式]]></title>
    <url>%2F2018%2F11%2F04%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式动机很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。 模式定义 定义：责任链模式(Chain of Responsibility Pattern)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。 实质：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。 模式结构参与角色 Handler（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(nextHandler)作为其对下家的引用，以便将处理者链成一条链； ConcreteHandler（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。 在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 UML类图 代码示例首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为抽象类，其典型实现代码如下所示： 123456789101112131415161718192021222324252627/** * 责任连模式的抽象处理者角色. * * Created by blinkfox on 16/7/11. */public abstract class Handler &#123; /** 后继处理者角色. */ protected Handler nextHandler; /** * 处理请求的抽象方法. * * @param condition 条件 */ public abstract void handle(String condition); /** * nextHandler的Setter方法. * * @param nextHandler 后继处理器 */ public void setNextHandler(Handler nextHandler) &#123; this.nextHandler = nextHandler; &#125;&#125; 其次，是若干个具体的处理角色类。 123456789101112131415161718192021222324/** * 具体处理角色1. * * Created by blinkfox on 16/7/11. */public class ConcreteHandler1 extends Handler &#123; /** * 具体处理角色1的处理方法. * * @param condition 条件 */ @Override public void handle(String condition) &#123; // 如果是自己的责任，就自己处理，负责传给下家处理 if ("ConcreteHandler1".equals(condition)) &#123; System.out.println( "具体处理角色1的处理方法handled1..."); &#125; else &#123; System.out.println( "具体处理角色1 通过..."); nextHandler.handle(condition); &#125; &#125;&#125; 123456789101112131415161718192021222324/** * 具体处理角色2. * * Created by blinkfox on 16/7/11. */public class ConcreteHandler2 extends Handler &#123; /** * 具体处理角色2的处理方法. * * @param condition 条件 */ @Override public void handle(String condition) &#123; // 如果是自己的责任，就自己处理，负责传给下家处理 if ("ConcreteHandler2".equals(condition)) &#123; System.out.println( "具体处理角色2的处理方法handled1..."); &#125; else &#123; System.out.println( "具体处理角色2 通过..."); nextHandler.handle(condition); &#125; &#125;&#125; 12345678910111213141516171819/** * 具体处理角色n. * * Created by blinkfox on 16/7/11. */public class ConcreteHandlerN extends Handler &#123; /** * 这里假设n是链的最后一个节点必须处理掉. * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点. * * @param condition 参数条件 */ @Override public void handle(String condition) &#123; System.out.println( "具体处理角色n的处理方法 结束..."); &#125;&#125; 最后，是客户端场景类，代码调用示例如下： 12345678910111213141516171819202122232425/** * 责任连模式的客户端场景类. * * Created by blinkfox on 16/7/11. */public class ChainClient &#123; /** * 主入口方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handlern = new ConcreteHandlerN(); handler1.setNextHandler(handler2); handler2.setNextHandler(handlern); //假设这个请求是ConcreteHandler2的责任 handler1.handle("ConcreteHandler2"); &#125;&#125; 注：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。 模式分析使用场景在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。 纯与不纯的责任链模式 纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况； 在纯责任链模式里面，一个请求必须被某一个处理者对象所接收； 在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。 纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。 优点 降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程； 简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性； 可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者； 职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用； 增加新的请求处理类很方便。 缺点 不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理； 该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理； 系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。 总结 在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之再学习]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJavaScript%E4%B9%8B%E5%86%8D%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概览JavaScript 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。需要注意的一个主要区别是 JavaScript 不支持类，类这一概念在 JavaScript 通过对象原型（object prototype）得到延续。另一个主要区别是 JavaScript 中的函数也是对象，JavaScript 允许函数在包含可执行代码的同时，能像其他对象一样被传递。 数据类型和结构1. 动态类型JavaScript是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据： 123var foo = 42; // foo is a Number nowvar foo = "bar"; // foo is a String nowvar foo = true; // foo is a Boolean now 2. 数据类型最新的ECMAScript标准定义了 7 种数据类型: 6 种原始类型 Null (空, 只有一个值null) Undefined (未定义, 一个没有被赋值的变量的默认值是undefined): Boolean (布尔, 可以有两个值：true 和 false) Number (数字) String (字符串) Symbol (符号, ECMAScript 6 新定义的类型，表示独一无二的值) 和 Object (对象) Function (函数) Array (数组) Date (日期) JSON (JS对象标识,来序列化对象、数组、数值、字符串、布尔值和 null) Math (数学方面的计算) RegExp (正则表达式) Error (错误) Map Set 内置对象这里的内置对象指的是在全局作用域(global scope)中的对象，由于很多，不再一一列出说明，更全面的解释在这里。 全局对象本身可通过this操作符在全局作用域中获得。实际上，全局作用域就是由全局对象的各个属性组成的（包括继承来的属性）。 严格模式除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 严格模式可以应用到整个script标签或个别函数中。设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 为某个script标签开启严格模式进入严格模式的标志，是下面这行语句： 1'use strict' 为某个函数开启严格模式123456789function strict()&#123; // 函数级别严格模式语法 'use strict'; return "I'm a strict mode function! " + nested();&#125;function notStrict() &#123; return "I'm not strict.";&#125; 相等性判断JavaScript提供三种不同的值比较操作： 严格相等 (“triple equals” 或 “identity”)，使用=== 宽松相等 (“double equals”) ，使用== 以及Object.is (ECMAScript 2015/ ES6 新特性) 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ); 而Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而Object.is(NaN，NaN)将为 true。 作用域作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域。一般来说以下几种情形： 最外层函数和在最外层函数外面定义的变量拥有全局作用域。 所有未定义而直接赋值的变量自动声明为拥有全局作用域。 所有window对象的属性拥有全局作用域。如：window.name、window.location等。 注：全局变量存在于程序的整个生命周期。没有块级作用域。 局部作用域局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。 作用域链JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是Scope，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 因为全局变量总是存在于运行时上下文作用域链的最末端。所以，在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。 with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。 1234person = &#123;name: "yhb", age: 22, height:175, wife: &#123;name: "lwy", age: 21&#125;&#125;;with (person.wife) &#123; console.log(name);&#125; with语句将person.wife添加到当前作用域链的头部，所以输出的就是：lwy；with语句结束后，作用域链恢复正常。 当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。注：在程序中应避免使用with语句。 闭包(Closures)一个示例如何从外部读取局部变量？ 123456function f1() &#123; var n=999; function f2() &#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1() &#123; var n=999; function f2() &#123; alert(n); // 999 &#125; return f2;&#125;var result=f1();result(); // 999 闭包解释 闭包定义：闭包是一个函数和函数所声明的词法环境的结合。 在上面的代码中，f2函数就是闭包。闭包（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收。 立即执行函数表达式有时你想模拟一个模拟块级作用域，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做IIFE(立即执行函数表达式(Immediately Invoked Function Expression))： 123(function () &#123; // 块开始 var tmp = ...; // 非全局变量&#125;()); // 块结束 用闭包模拟私有方法JavaScript 并不提供原生的支持私有方法，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 1234567891011121314151617181920212223242526var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 上面创建了一个环境，为三个函数所共享：Counter.increment, Counter.decrement和Counter.value。该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为privateCounter的变量和名为changeBy的函数。这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。 注意： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 内存机制首先JavaScript中的变量分为基本类型和引用类型。 基本类型就是保存在栈内存中的简单数据段。基本类型有Undefined、Null、Boolean、Number和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。 引用类型指的是那些保存在堆内存中的对象。引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。 为什么会有栈内存和堆内存之分？与垃圾回收机制有关，为了使程序运行时占用的内存最小。 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的； 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。 垃圾回收机制Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 清除方式 标记清除：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 原型(prototype)原型是一个对象，其他对象可以通过它实现属性继承。JavaScript的对象中都包含了一个Prototype内部属性，这个属性所对应的就是该对象的原型。Prototype作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了__proto__这个非标准的访问器。 所有的对象都有__proto__属性，该属性对应着该对象的原型。 所有的函数对象都有prototype属性，该属性的值会被赋值给该函数创建的对象的__proto__属性 所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数 函数对象和原型对象通过prototype和constructor属性进行相互关联 Object实例对象的原型obj.__proto__就是Object.prototype hasOwnProperty是Object.prototype的一个方法，该方法能判断一个对象是否包含自定义属性而不是原型链上的属性，因为”hasOwnProperty” 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数 原型链因为每个对象和原型都有原型，对象的原型指向对象的父，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。 当通过原型链查找一个属性的时候，首先查找的是对象本身的属性，如果找不到才会继续按照原型链进行查找。这样一来，如果想要覆盖原型链上的一些属性，我们就可以直接在对象中引入这些属性，达到属性隐藏的效果。 对象创建方式1. Object构造函数方式123var Person = new Object();Person.name = 'Nike';Person.age = 29; 这行代码创建了Object引用类型的一个新实例，然后把实例保存在变量Person中。 2. 对象字面量方式1234var Person = &#123; name: 'Nike'; age: 29;&#125;; 对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性对象的过程。 注：前两种方法的缺点在于：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。 3. 工厂模式123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson('Nike', 29, 'teacher'); 在使用工厂模式创建对象的时候，我们都可以注意到，在createPerson函数中，返回的是一个对象。但我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。 4. 构造函数方式1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person('Nike', 29, 'teacher');alert(person1 instanceof Object); //ture 对比工厂模式，我们可以发现以下区别： 没有显示地创建对象 直接将属性和方法赋给了this对象 没有return语句 终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测： 那么构造函数确实挺好用的，但是它也有它的缺点：就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法。 5. 原型创建对象模式12345678910111213function Person()&#123;&#125;Person.prototype.name = 'Nike';Person.prototype.age = 20;Person.prototype.jbo = 'teacher';Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'Greg';alert(person1.name); //'Greg' --来自实例alert(person2.name); //'Nike' --来自原型 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。 这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 6. 组合使用构造函数模式和原型模式123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person('Nike', 20, 'teacher'); 7. 动态原型模式1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != 'function') &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125;var person1 = new Person('Nike', 20, 'teacher');person1.sayName(); 动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。 8. 寄生构造函数方式123456789101112function Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = new Person('Nike', 29, 'teacher'); 寄生模式和工厂模式几乎一样，寄生模式和工厂模式的区别： 寄生模式创建对象时使用了new关键字 寄生模式的外部包装函数是一个构造函数 作用:寄生模式可以在特殊的情况下为对象来创建构造函数,原因在于我们可以通过构造函数重写对象的值，并通过return返回。重写调用构造函数(创建的对象的实例)之后的对象实例的新的值。 9. 稳妥构造函数方式12345678910function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person = new Person('Nike', 29, 'teacher');person.sayName(); // 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值 道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，是指没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同： 一是新创建对象的实例方法不引用this； 二是不使用new操作符调用构造函数。 注：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。 并发模型和事件循环(event loop)JavaScript 的并发模型基于事件循环。 1. 运行时概念栈函数调用形成了一个栈帧。 1234567891011function foo(b) &#123; var a = 10; return a + b + 11;&#125;function bar(x) &#123; var y = 3; return foo(x * y);&#125;console.log(bar(7)); 当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。 堆对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。 队列一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈拥有足够内存时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）。当栈再次为空的时候，也就意味着消息处理结束。 2. 事件循环之所以称为事件循环，是因为它经常被用于类似如下的方式来实现： 123while (queue.waitForMessage()) &#123; queue.processNextMessage();&#125; 如果当前没有任何消息，queue.waitForMessage 会等待着同步将要到来的消息。 每一个消息完整的执行后，其它消息才会被执行。这个模型的一个缺点在于当一个消息的完成耗时过长，网络应用无法处理用户的交互如点击或者滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个比较好的解决方案是使消息处理变短且如果可能的话，将一个消息拆分成几个消息。 在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。 3. 绝不阻塞事件循环(event loop)模型特性在于它永不阻塞。通常由事件或者回调函数进行 I/O (input/output)处理 。 参考文档： MDN]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之单例模式]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式动机对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 模式定义 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 单例模式的要点有三个： 一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 模式结构参与角色 Singleton: 单例 UML类图 时序图 代码实现方式1. 饿汉式（推荐使用）1234567891011121314151617/** * 饿汉式单例模式. * * @author blinkfox on 2017-10-23. */public class Singleton &#123; /** 全局唯一实例. */ private static final Singleton singleton = new Singleton(); private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 注：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。 2. 非线程安全懒汉式（不推荐使用）1234567891011121314151617181920212223/** * 非线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过懒加载的方式获取实例，但是非线程安全. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 注：是懒加载的方式，但非线程安全。不推荐使用。 3. 低效的线程安全懒汉式（不推荐使用）1234567891011121314151617181920212223/** * 低效的线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static synchronized Singleton getSingleton() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 注：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。 4. 双重校验锁线程安全懒汉式（不推荐使用）123456789101112131415161718192021222324252627/** * 双重校验锁线程安全懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; /** * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 注：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。 5. 枚举式（强烈推荐使用）12345678910/** * 枚举方式的单例. * * @author blinkfox on 2017-10-23. */public enum Singleton &#123; INSTANCE;&#125; 注：在《Effective Java》一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。 6. 静态内部类（推荐使用）1234567891011121314151617181920212223242526272829/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author blinkfox on 2017-10-23. */public class Singleton &#123; private Singleton() &#123;&#125; /** * 静态内部类. */ private static final class SingletonHolder &#123; private SingletonHolder() &#123;&#125; private static Singleton4 instance = new Singleton(); &#125; /** * 通过懒加载的方式获取Singleton唯一实例的方法. * @return Singleton实例 */ public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 注：这种方式利用了ClassLoader的机制保证初始化instance时只有一个线程，其只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 模式分析单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。 优点 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 适用环境在以下情况下可以使用单例模式： 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。 总结 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。 单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。 实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。 单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。 单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常知识汇总]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言为什么要使用异常在我们的程序中，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷： 容易混淆。如果约定返回值为 -1 时表示出现异常，那么当程序最后的计算结果真的为 -1 呢？ 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。 由调用函数来分析异常，这要求程序员对库函数有很深的了解。 在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。 基本定义 异常情形是指阻止当前方法或者作用域继续执行的问题。——《Think in java》 总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。 异常体系在Java中，所有的事件都能由类描述，Java中的异常就是由java.lang包下的异常类来描述的。Java定义了一个异常类的层次结构，其以Throwable（万物即可抛）开始，派生出了Error和Exception，而Exception又派生出了CheckedException和RuntimeException。如下图所示： ThrowableThrowable（可抛出）是异常类的最终父类，它有两个子类，Error与Exception。 Throwable 中常用方法有： synchronized Throwable getCause()：此方法返回异常产生的原因，如果不知道原因的话返回null。 String getMessage()：方法返回Throwable的String型信息，当异常通过构造器创建后可用。 String getLocalizedMessage()：此方法通过被重写来得到用本地语言表示的异常信息返回给调用程序。Throwable类通常只是用getMessage()方法来实现返回异常信息。 void printStackTrace()：该方法打印栈轨迹信息到标准错误流。该方法能接受PrintStream和PrintWriter作为参数实现重载，这样就能实现打印栈轨迹到文件或流中。 String toString()：方法返回String格式的Throwable信息，此信息包括Throwable的名字和本地化信息。 ErrorError（错误）：表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以 Error 不是try-catch的处理对象，而 JVM 一般的处理方式是终止发生错误的线程。Error 类常见子类有VirtualMachineError、StackOverFlowError、OutOfMemoryError等。 在Java运行时内存中，除程序计数器外的虚拟机栈、堆、方法区在请求的内存无法被满足时都会抛出OutOfMemoryError；而如果线程请求的栈深度超出虚拟机允许的深度时，就会抛出StackOverFlowError。 ExceptionException（异常）：出现原因取决于程序，所以程序也理应通过try-catch处理。Exception 异常分为两类：CheckedException和RuntimeException，即检查异常与运行时异常。 检查异常：编译器要求必须处理，否则不能通过编译，使用try-catch捕获或者throws抛出。常见的检查异常有IOException及其子类、EOFExcption(文件已结束异常)、FileNotFoundException（文件未找到异常）。 运行时异常（也叫非检查异常）：编译期不会检查，所以在程序中可不处理，但如果发生，会在运行时抛出。 异常处理处理机制在 Java 应用程序中，异常处理机制为：抛出异常、捕捉异常。 抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。 捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。 对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。 对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。 对于所有的检查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常。 对于所有运行时异常，Java规定：运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。 能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。 任何Java代码都可以通过 Java 的throw语句抛出异常。 从方法中抛出的任何异常都必须使用throws子句。 捕捉异常通过try-catch语句或者try-catch-finally语句实现。 总体来说，Java规定：对于检查异常必须捕捉、或者声明抛出。允许忽略非检查的RuntimeException和Error。 处理方式try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。try-catch-finally语句的一般语法形式为： 123456789try &#123; // 可能会发生异常的程序代码&#125; catch (Exception1 e1) &#123; // 捕获并处理try抛出的异常类型Type1&#125; catch (Exception2 e2) &#123; // 捕获并处理try抛出的异常类型Type2&#125; finally &#123; // 无论是否发生异常，都将执行的语句块&#125; Java7及之后的版本可这样使用： 12345try (MyResource mr = new MyResource()) &#123; System.out.println("MyResource created in try-with-resources");&#125; catch (Exception1 | Exception2 e) &#123; // 捕获并统一处理 try 抛出的多种异常类型，不需要finally块&#125; try块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch块：用于处理try捕获到的异常。 finally块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下 4 种特殊情况下，finally块不会被执行： 在finally语句块中发生了异常 在前面的代码中用了System.exit()退出程序 程序所在的线程死亡 关闭CPU 异常处理语句的语法规则 必须在try之后添加catch或finally块。try块后可同时接catch和finally块，但至少有一个块。 必须遵循块顺序：若代码同时使用catch和finally块，则必须将catch块放在try块之后。 catch块与相应的异常类的类型相关。 一个try块可能有多个catch块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的catch代码块。 可嵌套try-catch-finally结构。 在try-catch-finally结构中，可重新抛出异常。 除了下列情况，总将执行finally做为结束： JVM 过早终止（调用 System.exit(int)）； 在finally块中抛出一个未处理的异常； 计算机断电、失火、或遭遇病毒攻击。 异常抛出任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。 throws抛出异常如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为： 123methodname throws Exception1, Exception2, ... , ExceptionN &#123;&#125; 方法名后的throws Exception1, Exception2, ... , ExceptionN为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。 throws抛出异常的规则： 如果是非检查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。 必须声明方法可抛出的任何检查异常（checked exception）。即如果一个方法可能出现受检查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误。 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。 调用方法必须遵循任何检查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。 使用throw抛出异常throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。该语句的语法格式为： 1throw new ExceptionName(); 注：如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。 异常链在设计模式中有一个设计模式叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。 我们知道每遇到一个异常信息，我们都需要进行try-catch-finally,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。 我们有两种方式处理异常，一是throws抛出交给上级处理，二是try-catch做具体处理。但是这个与上面有什么关联呢？try-catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。 通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。 同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。 在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。使用方式如下： 12345678910111213141516171819202122232425262728293031public class Test &#123; public void f() throws MyException&#123; try &#123; FileReader reader = new FileReader("test.txt"); Scanner in = new Scanner(reader); System.out.println(in.next()); &#125; catch (FileNotFoundException e) &#123; //e 保存异常信息 throw new MyException("文件没有找到--01", e); &#125; &#125; public void g() throws MyException&#123; try &#123; f(); &#125; catch (MyException e) &#123; //e 保存异常信息 throw new MyException("文件没有找到--02", e); &#125; &#125; public static void main(String[] args) &#123; Test t = new Test(); try &#123; t.g(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 如果在程序中,去掉e，也就是：throw new MyException(“文件没有找到–02″);那么异常信息就保存不了。 自定义异常Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误。所以，Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。 Java自定义异常的使用要经历如下四个步骤： 定义一个类继承Throwable或其子类。 添加构造方法(当然也可以不用添加，使用默认构造方法)。 在某个方法类抛出该异常。 捕捉该异常。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738/** *自定义异常 继承Exception类. */public class MyException extends Exception &#123; public MyException()&#123; &#125; public MyException(String message)&#123; super(message); &#125;&#125;/** * 测试抛出和捕捉异常的类. */public class Test &#123; public void display(int i) throws MyException&#123; if (i == 0) &#123; throw new MyException("该值不能为0......."); &#125; else&#123; System.out.println( i / 2); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); try &#123; test.display(0); System.out.println("---------------------"); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最佳实践 尽可能的减小try块。 不要在构造函数中抛出异常。 如果使用Java7及以后的版本，一个catch子句中可以捕获多个异常。 充分使用finally块，保证所有资源都被正确释放；如果使用Java7及以后的版本，那么更推荐使用try-with-resource语法。 catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。 不要忽略异常。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。 减轻finally的任务，finally块仅仅用来释放资源是最合适的。不要在finally中使用return、抛出异常等。 为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。对异常进行Javadoc文档说明，并且描述抛出异常的场景。 不要捕获Throwable。Throwable是所有异常和错误的父类。如果catch了throwable，那么不仅仅会捕获所有Exception，还会捕获Error。而Error是表明无法恢复的JVM错误。因此除非绝对肯定能够处理或者被要求处理Error，不要捕获Throwable。 包装异常时要包含原始的异常。包装异常时，一定要把原始的异常设置为cause(Exception有构造方法可以传入cause)。否则，丢失了原始的异常信息会让错误的分析变得困难。 常见异常及解释以下是常见Java异常的非技术角度的理解。阅读有风险，理解需谨慎。 java.lang ArithmeticException：你正在试图使用电脑解决一个自己解决不了的数学问题，请重新阅读你的算术表达式并再次尝试。 ArrayIndexOutOfBoundsException：请查看IndexOutOfBoundsException。不同之处在于这个异常越界的元素不止一个。 ArrayStoreException：你已用光了所有数组，需要从数组商店中购买更多的数组。 ClassCastException：你需要呆在自己出生的种姓或阶级。Java 不会允许达利特人表现得像刹帝利或者高贵种族的人假装成为工人阶级。为了保持向前兼容，Java 1.0中把Caste误写为Cast保留到了现在。 ClassNotFoundException：你似乎创造了自己的类。这也是目前 Java 还未实现的种姓制度，但是 Java 明显使用了巴厘岛的种姓制度。也就是说，如果你是一个武士，也就相当于印度种姓制度中的第三层——吠舍。 CloneNotSupportedException：你是一名克隆人。找到你的原型，告诉他你想做什么，然后自杀。 IllegalAccessException：你是一个正在运行 Java 程序入室盗窃的小偷，请结束对电脑的盗窃行为，离开房子，然后再试一次。 IllegalArgumentException：你试图反对之前的异常。 IllegalMonitorStateException：请打开你的电脑屏幕背面。 IllegalStateException：你来自一个尚未被联合国承认的国家，也许是库尔德斯坦或者巴勒斯坦。拿到真正的国籍后重新编译你的 Java 代码，然后再试一次。 IllegalThreadStateException：你电脑的一颗螺丝上到了错误的螺纹孔里，请联系你的硬盘供应商。 IndexOutOfBoundsException：你把食指放在了无法接收的地方，重新放置，再试一次。 InstantiationException：不是每件事都会立即发生，请更耐心一点。 InterruptedException：告诉你的同事、室友等，当你工作的时候，请勿打扰。 NegativeArraySizeException：你创建了一个负数长度的数组。这会丢失信息，长期发展将会毁灭宇宙。不过放宽心，Java 发现了你正在做的事，不要再这么干了。 NoSuchFieldException：你正试图去一个不存在的区域游览。如果你试图去参观一个事实上不存在，其实已经是最高机密的飞机场时，也会得到这个异常。我可以给你示例，然后不得不杀了你。 NoSuchMethodException：不要使用那个方法！拜托了，就像我们一直做的那样去解决事情吧。 NullPointerException：你没有狗。请你先找一只狗，比如一只布烈塔尼獵犬，然后再试一次。 NumberFormatException：你正在使用过时的测量单位，比如英寸或者品脱。请转换成国际基本单位。有一个已知的 bug 会导致 Java 抛出这个异常，那就是你太矮了或者太高了。 RuntimeException：你不能跑得足够快，可能因为你太胖了。关掉你的电脑，出门锻炼吧。 SecurityException：你已被认为是国家安全的一个威胁。请你呆在原地别动，然后等着警察来并带你走。 StringIndexOutOfBoundsException：你的内裤和这个地方格格不入。换掉它们，再试一次。另外如果你根本不穿任何内裤，也会得到这个异常。 UnsupportedOperationException：因为一些原因，你正试图做一个在道德上不被 Java 支持的手术。包括不必要的截肢，例如割包皮。请停止滥用你的身体，不要移除你的孩子，该死的！ java.util ConcurrentModificationException：有人修改了你的 Java 代码。你应该更改密码。 EmptyStackException：为了让 Java 工作，你必须在桌子上放一叠 Java 书籍。当然，如果书很厚的话，一本就够了。 MissingResourceException：你太穷了，不配使用 Java。换一个更便宜的语言吧（比如 Whitespace、Shakesperre、Cow、Spaghetti 或者 C#）。 NoSuchElementException：这里只存在四种元素（地球、水、空气、火）。《第五元素》只是部电影而已。 TooManyListenersException：你被太多秘密机构窃听了，SecurityException 马上就到。 java.awt AWTException：你正在使用AWT，也就是说你的图形界面会很丑。这个异常只是一个警告可以被忽略。 FontFormatException：你的布局很丑陋，或者你选择了一个糟糕的字体，或者太多的字体。请咨询一名专业的设计师。 HeadlessException：Java 认为身为一名程序员，你实在是太蠢了。 IllegalComponentStateException：你的一个硬件（例如硬盘、CPU、内存）坏掉了。请联系你的硬件供应商。 java.awt.color CMMException：你的 CMM 坏掉了，真是见鬼了。我经常烧毁自己的房子，然后去一个新的城市重新开始。 ProfileDataException：你的个人档案包含可疑信息。如果你不是一名共产主义者、恐怖分子或者无神论者，请联系 CIA 修正错误。 java.awt.datatransfer MimeTypeParseException：你的哑剧（Mime）糟透了，没人能够理解你到底想表达什么。尝试一些更简单的事情吧，比如迎风散步，或者被困在一个看不见的盒子里。 UnsupportedFlavorException：你正试图使用一种 Java 不知道的香料。大部分人似乎只知道使用香草和樱桃。 java.beans IntrospectionException：你太内向了，你应该变得外向一些。 别再当一个呆子，出门去见见人吧！ PropertyVetoException：你的一部分财产被冻结了。这条信息应该已经告诉你谁干的和原因。如果没看见，你可能也不该询问。 java.io CharConversionException：你一直试图焚烧一些不燃物。也可能是因为你试着把自己变成一条鱼，但这不可能发生。 EOFException：你得到这条异常是因为你不知道EOF是什么意思。但是，我并不打算告诉你，因为你是一个不学无术的人。 FileNotFoundException：一名木匠应该总是知道他的工具放在哪里。 InterruptedIOException：你不顾之前的 IOException，一直在使用 IO，然后你的活动就被中断了。 InvalidClassException：查看 ClassNotFoundException。 InvalidObjectException：反对无效，就像他们在法庭上说的一样。 IOException：IO 代表输入、输出，并且不得不做收发数据的事。IO 是一个安全问题，不应使用。 NotActiveException：这个异常意味着两件事。要么是未激活，需要激活；要么是已激活，需要停止。到开始工作为止，激活与未激活都是随机的。 NotSerializableException：你正试图把一部电影改成电视剧。 ObjectStreamException：你提出了一连串的反对（Object）意见。提出新的意见前，请限制自己一下，等待法官作出判决。查看 InvalidObjectException。 OptionalDataException：你似乎认为一些可选数据是必须的。不要让事情变得复杂。 StreamCorruptedException：你的数据流被损坏了，这意味着它已经被截包，并在黑市上贩卖。 SyncFailedException：你试图与其他人同步你的失败，然后被证明比他人更加失败。去找一些跟你同等水平的人吧。 UnsupportedEncodingException：如果你想在网上发送自己的代码，必须与美国国家安全局核对你的加密密匙。如果不这么做，将把你视为恐怖分子，并以适当方式处理。如果你得到这个异常，能跑多快跑多快。 UTFDataFormatException：UTF 代表通用传输格式，是一种无论你使用哪种格式都会用到的数据传输方式。你试图通过 UTF 传输错误格式的数据。 WriteAbortedException：你需要在程序中的某处写上“aborted”。这通常没什么意义，但你就得这样做。 java.net BindException：Java编程和束缚不能混为一谈。 ConnectException：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。 MalformedURLException：你正在制作一个形状错误的壶（例如一个“L”状），或者你有拼写错误的单词“urn”（例如“url”）。 NoRouteToHostException：没有通往主机的“道路”，请联系公路管理员。 PortUnreachableException：港口必须正确地放置在水边。如果在内陆，它们将会无法接触。 ProtocolException：这是一个严重违反规定的结果（例如在你主机上的“puk韓g”）。解决方法很简单：不要那样做！ SocketException：你把电脑连接到了错误的电源插座。大部分情况下你不得不寻找其它插座，但一些电脑背部有一个开关，可以设置电源插座类型。 SocketTimeoutException：你的电脑连接了一个带计时器的电源插座，并且时间已经走完。只有烙铁和相似的东西才会使用这种插座。 UnknownHostException：你的父母没有教过你不要和陌生人说话么？ UnknownServiceException：你正试图进入接近一个未知服务。众所周知，未知服务或许是特工组织。 URISyntaxException：“You are I”是一个语法错误的句子。将其改为“You are me”，别管那到底啥意思。 java.rmi AccessException：你正在使用“Microsoft Access”。请不要这样做。 AlreadyBoundException：不管在 java.net.BindException 的描述中是什么状况，RMI 都提供捆绑服务。然而，你不能绑一个已经被捆绑的人。 ConnectException：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。 ConnectIOException：你正试图通过 IO 与另一个不能被连接的事物建立连接。尝试连接其他事物吧。或许你可以通过一个特殊的连接对象实现想要的连接。 MarshalException：你的“marshal”出问题了。你应做的事取决于我们正在讨论的是哪种“marshal”。他可以是陆军元帅、警察、消防队员或者只不过是一名普通的司仪。注意这个异常与马绍尔群岛共和国没有任何关系，也称为 RMI。 NoSuchObjectException：你正试图使用一个不存在的对象。以爱因斯坦之名，创造它或者不要使用它！ NotBoundException：如果你正在使用奴隶，请确认至少有一个人被绑住了。 RemoteException：这是一条远程抛出的特殊异常。如果其他人的应用变得不稳定，以致于不能产生一条异常，相反地，你可能会得到这条异常。请找到源头并提醒那位程序员这个错误。 RMISecurityException：马绍尔群岛共和国变得不稳定了。如果你住在这儿，你最好离开，直到安全得到保障为止都别回来。如果你住在其他地方，可以无视这个异常。 ServerException：第二发球（或者双发失误同样适用）。 ServerRuntimeException：只要是网球比赛都很长。当你花太长时间发球时，就会得到这条异常。 StubNotFoundException：当你去看电影的时候，你应该一直保留自己的票根。如果不这么做，并且离开了电影院，你就不能重新进去，不得不去买张新票。所以保留你的票根！ UnexpectedException：这个异常对你来说应该会成为一个大惊喜。如果发生了，所有事都变成它应该的样子。 UnknownHostException：你父母没有教过你不要和陌生人说话吗？ UnmarshalException：.你没有完成一名法律工作人员的职责（例如你曾经的法官工作）。注意这个正确的术语是“曾经”（used to）。你已经被解雇（fire）了（如果你是一名消防队员（firefighter），这可真是讽刺啊）。 java.security AccessControlException：你失去了对 Microsoft Access 的控制。如果你无法重获控制或者通过其他方式停止程序，你应该尽快切断电脑电源。 DigestException：你应该注意自己的食物，消化不良也能变成严重的问题。 GeneralSecurityException：在某些地方做一些事情并不安全。如果你有足够的权力，你应该随机入侵一个国家（最好在中东地区）。如果你没有那种权力，至少应该有一把枪。 InvalidAlgorithmParameterException：你向一位残疾人用他不能理解的方式解释你的算法。简单一点！ InvalidKeyException：这个异常有两种不同的原因：1、你正在使用错误的钥匙。我的建议是在你的钥匙上画不同颜色的小点来帮助你记住哪一把对应哪一个锁。2、 你不能锁住残疾人却不给他们钥匙，如果他们足够聪明发现如何使用钥匙，他们就有自由移动的权- 利。 InvalidParameterException：你使用了蔑视的术语去描述一名残疾人。 KeyException：不要尝试不用钥匙就能开锁。 KeyManagementException：你遗失了自己的钥匙。很可能忘在办公室（如果你正试图进入你家）或者忘在家里（如果你正试图进入办公室）。 KeyStoreException：延续之前 KeyManagementException 的解释就是你的钱包有个洞。 NoSuchAlgorithmException：你试图用以前未知的方法解决问题。停止创新吧，用老算法重写一遍。你也可以为自己的想法申请专利，然后等待未来 Java 发布新版本的时候纳入其中。 NoSuchProviderException：如果你是一名单亲妈妈，你没法成为家庭主妇。首先，你得为家庭找到一名供养者。 PrivilegedActionException：你试图采取一个行动，但是没有得到权限。比如，只有名人才可以做到地从谋杀中逃脱，只有天主教神父和耶和华的高级见证人才能做地猥亵儿童，只有在私人企业担任管理职位的人才能被允许地偷钱。 ProviderException：你是一名妇女并试图供养一个家庭。显而易见，你的丈夫不能成为一名“家庭主妇”，所以你得让他供养个家庭。想象一下，Java固执且不肯改变，事情就是这样工作的，解决它。 SignatureException：要么你是伪造的其他人的签名，要么是无法接受你的签名。一个签名不能太丑陋、太易读或太大。 UnrecoverableKeyException：该死。你把你的钥匙扔进了下水沟。我唯一能安慰你的就是其他人也无法恢复钥匙，所以倒不是必须换掉你的锁。 java.text ParseException：你做的没有任何意义，冷静下来，再试一次。 参考文档： java提高篇之异常（上） java提高篇之异常（下） 深入理解java异常处理机制 Java 中 9 个处理 Exception 的最佳实践 Java常见异常及解释]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要知道的Java枚举知识]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%90%8E%E7%AB%AF%2FJava%2F%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84Java%E6%9E%9A%E4%B8%BE%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[概述定义枚举（enum全称为enumeration）类型是Java 5新增的类型，存放在java.lang包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。 定义格式 创建枚举类型要使用enum关键字，隐含了所创建的类型都是java.lang.Enum类的子类（java.lang.Enum是一个抽象类）。枚举类型符合通用模式Class Enum&lt;E extends Enum&lt;E&gt;&gt;，而E表示枚举类型的名称。枚举类型的每一个值都将映射到protected Enum(String name, int ordinal)构造函数中。在这里每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 枚举类的定义格式如下： 12345enum 类名 &#123;//枚举值&#125; 要点 需要的数据不能是任意的，而必须是一定范围内的值 枚举类也是一个特殊的类，构造方法默认的修饰符是private的 枚举值默认的修饰符是public static final，必须要位于枚举类的第一个语句 枚举类可以定义自己的成员变量、成员函数和带参构造方法，自定义带参构造方法时，枚举值需要传参 枚举类可以存在抽象的方法，但是枚举值必须要实现抽象的方法 可以使用==来比较枚举实例 常用方法枚举中的一些常用方法如下： int ordinal()：返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。 String name()：返回此枚举常量的名称。 String toString()：返回覆盖枚举常量的toString()方法的值。 int compareTo(E o)：比较此枚举与指定对象的顺序。 Class&lt;E&gt; getDeclaringClass()：返回与此枚举常量的枚举类型相对应的 Class 对象。 static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)：返回指定名称的枚举常量指定的enumtype的方法。如：ColorEnum color = ColorEnum.valueOf(&quot;RED&quot;);。 主要应用表达常量在Java 5之前，定义常量的最佳方式是在final修饰的常量类中定义：public static fianl...修饰的属性，且须将构造方法设为private。代码示例如下： 123456789public final class ColorConst &#123; public static final int RED = 1; public static final int GREEN = 2; public static final int BLUE = 3; private ColorConst() &#123;&#125;&#125; 但，不建议在接口中定义常量。在《Effective Java》一书中提到过： The constant interface pattern is a poor use of interfaces. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.There are several constant interfaces in the java platform libraries, such as java.io.ObjectStreamConstants. These interfaces should be regarded as anomalies and should not be emulated. 大意是：如果某个实现了常量接口的类被修改不再需要常量了，也会因为序列化兼容原因不得不保持该实现，而且非final类实现常量接口会导致所有子类被污染。 现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。 12345public enum ColorEnum &#123; RED, GREEN, BLUE&#125; 注意：枚举类的名称一般以Enum结尾，比如ColorEnum等。如果你写个枚举类，取名为Color，那么没人能快速知道它是一个枚举类。 遍历Java 中使用values()方法将枚举所有元素item转换成一个数组。这样就可以通过foreach语法来遍历枚举中的所有元素了。 123for (ColorEnum color: ColorEnum.values()) &#123; log.info("ordinal:&#123;&#125;, name:&#123;&#125;", color.ordinal(), color.name());&#125; 输出结果； 123ordinal:0, name:REDordinal:1, name:GREENordinal:2, name:BLUE switch在JDK7之前，String字符串是不支持通过switch语法来筛选数据，但是 Java 为枚举提供了switch语法的支持。使用示例如下： 123456789101112// 客户端传来的枚举itemColorEnum color = ColorEnum.GREEN;switch (color) &#123; case RED: log.info("进入了 RED 的分支"); break; case GREEN: log.info("进入了 GREEN 的分支"); break; case BLUE: log.info("进入了 BLUE 的分支"); break; default: log.info("进入了 default 的分支");&#125; 输出结果： 1进入了 GREEN 的分支 注意：switch后已经指定了枚举的类型，case后无须再使用全名ColorEnum。 自定义属性和方法Java枚举中允许定义属性和方法，但必须在枚举实例序列的最后一个分号后再添加。Java 要求必须先定义枚举实例在前面，使用示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */public enum ColorEnum &#123; RED(1, "红色"), GREEN(2, "绿色"), BLUE(3, "蓝色"); /** 颜色的code. */ private int code; /** 颜色的名称. */ private String name; /** * 枚举的构造方法默认且只能是private的. * @param code 代码值 * @param name 名称 */ ColorEnum(int code, String name) &#123; this.code = code; this.name = name; &#125; /** * 根据颜色的code值获取到对应的名称. * @param code 颜色code * @return 颜色名称 */ public static String getNameByCode(int code) &#123; for (ColorEnum color: ColorEnum.values()) &#123; if (color.code == code) &#123; return color.name; &#125; &#125; return null; &#125; /** * 覆盖的toString方法. * @return 字符串 */ @Override public String toString() &#123; return this.code + ":" + this.name; &#125; /* getter方法. */ public int getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125;&#125; 注意：枚举的构造方法默认且只能是private的。 使用枚举来表达多态所有的枚举都继承自java.lang.Enum类。由于 Java 不支持多继承，所以枚举不能再继承其他类。但枚举类中可以定义抽象方法，也可以实现一个或者多个接口。由于每一个枚举值会呈现出不同的行为方式，则须要让每个枚举值分别实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */public enum ColorEnum &#123; RED(1, "红色") &#123; @Override public void paint() &#123; log.info("使用了'红色'颜料来喷漆"); &#125; &#125;, GREEN(2, "绿色") &#123; @Override public void paint() &#123; log.info("使用了'绿色'颜料来喷漆"); &#125; &#125;, BLUE(3, "蓝色") &#123; @Override public void paint() &#123; log.info("使用了'蓝色'颜料来喷漆"); &#125; &#125;; private static final Logger log = LoggerFactory.getLogger(ColorEnum.class); /** 颜色的code. */ private int code; /** 颜色的名称. */ private String name; /** * 枚举的构造方法默认且只能是private的. * @param code 代码值 * @param name 名称 */ ColorEnum(int code, String name) &#123; this.code = code; this.name = name; &#125; /** * 使用不同的颜色来喷漆的抽象方法. */ public abstract void paint(); /** * 根据颜色的code值获取到对应的名称. * @param code 颜色code * @return 颜色名称 */ public static String getNameByCode(int code) &#123; for (ColorEnum color: ColorEnum.values()) &#123; if (color.code == code) &#123; return color.name; &#125; &#125; return null; &#125; /* getter方法. */ public int getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125; /** * 覆盖的toString方法. * @return 字符串 */ @Override public String toString() &#123; return this.code + ":" + this.name; &#125;&#125; 枚举集合的使用Java 中提供了两个方便操作enum的集合类：java.util.EnumSet和java.util.EnumMap。EnumSet保证集合中的元素不重复；EnumMap中的key是enum类型且不能为null，而value则可以是任意类型。EnumSet和EnumMap内部以数组来实现，性能更好。 以下是EnumMap的使用示例： 123456EnumMap&lt;ColorEnum, String&gt; colorEnumMap = new EnumMap&lt;ColorEnum, String&gt;(ColorEnum.class);colorEnumMap.put(ColorEnum.RED, "这是EnumMap中的'RED'");colorEnumMap.put(ColorEnum.GREEN, "这是EnumMap中的'GREEN'");colorEnumMap.put(ColorEnum.BLUE, "这是EnumMap中的'BLUE'");log.info("&#123;&#125;", colorEnumMap); 输出结果： 1&#123;1:红色=这是EnumMap中的'RED', 2:绿色=这是EnumMap中的'GREEN', 3:蓝色=这是EnumMap中的'BLUE'&#125; 枚举单例在《Effective Java》一书中强烈推荐使用枚举来实现单例模式，同时枚举单例代码也最为简单： 123456789public enum ColorEnumSingleton &#123; INSTANCE; public static void doSomething()&#123; // do something &#125;&#125; 使用枚举单例有以下好处： 自由序列化 保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量） 线程安全 注意：枚举单例是饿汉式的。 枚举策略在使用 Java 的枚举时往往会结合Switch来进行判断以实现不同值的处理，但是我们知道多用switch不是一种很好的代码风格，不利用维护和适应变化，因为这不符合开闭原则。为此一种方法是用策略模式来重构原有的枚举实现。在《Effective Java》一书中提出了一种枚举策略模式很好的解决了这个问题。 具体使用方法和前面所讲的使用枚举来表达多态一节中的示例一样，这里就不再举例说明了。 总结 枚举类也是一个特殊的类，构造方法默认的修饰符是private（不管写不写）的，它们都可以定义一些属性和方法，但是不能使用extends关键字继承其他类，因为enum已经继承了java.lang.Enum（java是单一继承）。 枚举类中可以定义抽象方法，也可以实现一个或者多个接口。 使用枚举大大加强了程序的可读性、易用性和可维护性，并且可在此基础之上进行了扩展，使之可以像类一样去使用，更是为 Java 对离散量的表示上升了一个台阶。 枚举最大的缺点是：相对于普通的常量会占用更多的内存。所以，我还是不建议大面积的使用枚举来替代整形常量。但是如果这些常量还有关联属性或者行为等，那么强烈推荐使用枚举类型。使用枚举类型的性能几乎是使用静态类的16倍。 枚举类型对象之间的值比较，可以使用==直接来比较值是否相等的，不是必须使用equals方法。 推荐使用枚举单例来实现单例模式，可以使用枚举策略来简化策略模式。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架知识整理]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java集合框架主要由Collection和Map两个根接口及其子接口、实现类组成。 集合类关系梳理 Collection接口继承了Iterable接口，依赖了Predicate、Spliterator、Stream接口（这些均为Java8新增），Iterable接口依赖了Iterator接口。 List接口继承自Collection接口,依赖了UnaryOperator接口（Java8新增）、ListIterator、Comparator接口 Queue接口继承了Collection接口 Deque接口继承了Queue接口 BlockingQueue接口继承了Queue接口 BlockingDeque接口继承了BlockingQueue、Deque接口 TransferQueue接口继承了BlockingQueue接口 AbstractCollection抽象类实现了Collection接口， AbstractList抽象类继承了AbstractCollection抽象类，实现了List接口，依赖了List、RandomAccess、Cloneable、Serializable接口 ArrayList类继承了AbstractList抽象类，实现了List、RandomAccess、Cloneable、Serializable接口 AbstractSequentialList抽象类继承了AbstractList抽象类 LinkedList类继承了AbstractSequentialList抽象类，实现了List、Deque、Cloneable、Serializable接口 CopyOnWriteArrayList实现了List、RandomAccess、Cloneable、Serializable接口 Vector类继承了AbstractList抽象类，实现了List、RandomAccess、Cloneable、Serializable接口 Stack类继承了Vector类 AbstractQueue抽象类继承了AbstractCollection接口，实现了Queue接口 SynchronousQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口，依赖了Collection、Spliterator接口 ArrayBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口 LinkedBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口 PriorityBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口，聚合了Comparator接口，依赖了Collection、Comparator、Comparable接口 DelayQueue类继承了AbstractQueue接口，实现了BlockingQueue接口 LinkedBlockingDeque类继承了AbstractQueue接口，实现了BlockingDeque、Serializable接口 PriorityQueue类继承了AbstractQueue接口 LinkedTransferQueue类继承了AbstractQueue接口，实现了TransferQueue、Serializable接口（Java7新增） ConcurrentLinkedDeque类继承了AbstractCollection抽象类，实现了Deque、Cloneable、Serializable接口 ArrayDeque类继承了AbstractCollection抽象类，实现了Deque、Serializable接口 Set接口继承自Collection接口 AbstractSet抽象类继承了AbstractCollection抽象类，实现了Set接口 HashSet类继承了AbstractSet抽象类，实现了Set、Cloneable、Serializable接口，聚合了HashMap LinkedHashSet类继承了HashSet类，实现了Set、Cloneable、Serializable接口 TreeSet类继承了AbstractSet抽象类，实现了NavigableSet、Cloneable、Serializable接口，聚合了NavigableMap，依赖了Comparator、SortedSet接口 EnumSet抽象类继承了AbstractSet抽象类，实现了Cloneable、Serializable接口，依赖了Comparator、SortedSet接口 RegularEnumSet类继承了EnumSet抽象类 JumboEnumSet类继承了EnumSet抽象类 ConcurrentSkipListSet类继承了AbstractSet抽象类，实现了NavigableSet、Cloneable、Serializable接口 CopyOnWriteArraySet类继承了AbstractSet抽象类，实现了Serializable接口，聚合了CopyOnWriteArrayList类，依赖了Predicate、Consumer接口 SortedSet接口继承自Set接口，依赖了Comparator接口 NavigableSet接口继承自SortedSet接口(Java6新增) Map接口依赖了Set、Collection、BiConsumer、Function、BiFunction接口，Map.Entry是Map中的内部接口 AbstractMap抽象类实现了Map接口，聚合了Collection、Set接口 HashMap类继承了AbstractMap抽象类，实现了Map、Cloneable、Serializable接口，依赖了Collection、Set接口 LinkedHashMap继承了HashMap类，实现了Map接口，依赖了Collection、Set、Consumer、BiConsumer接口 TreeMap类继承了AbstractMap抽象类，实现了NavigableMap、Cloneable、Serializable接口，依赖了Comparator、SortedMap、Collection、Set、BiConsumer、BiFunction接口 EnumMap类继承了AbstractMap抽象类，实现了Cloneable、Serializable接口，依赖了AbstractSet类，Collection、Set接口 WeakHashMap类继承了AbstractMap抽象类，实现了Map接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction接口 IdentityHashMap类继承了AbstractMap抽象类，实现了Map、Serializable、Cloneable接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction接口 ConcurrentHashMap类继承了AbstractMap抽象类，实现了ConcurrentMap、Serializable接口，依赖了Comparable、ParameterizedType、Collection、Set、Spliterator、Consumer、BiConsumer、Function、BiFunction、ToDoubleFunction、DoubleBinaryOperator等接口 ConcurrentSkipListMap类继承了AbstractMap抽象类，实现了ConcurrentNavigableMap、Cloneable、Serializable接口，聚合了Comparator接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction、NavigableSet接口 SortedMap接口继承自Map接口，依赖了Set、Collection、Comparator接口 NavigableMap接口继承了SortedMap接口，依赖了NavigableSet接口 ConcurrentNavigableMap接口继承了ConcurrentMap、NavigableMap接口，聚合了NavigableSet接口 ConcurrentMap接口继承了Map接口，依赖了BiConsumer、BiFunction接口 Hashtable类继承了Dictionary抽象类，实现了Map、Cloneable、Serializable接口，聚合了Collection、Set接口，依赖了Enumeration、BiConsumer、BiFunction接口 Properties类继承了Hashtable类 Collections是Collection的辅助工具类，依赖了上述大多数接口和类 Arrays是数组的辅助工具类，依赖了上述一些接口和类 集合UML关系图Java Collection UML类关系图如下： Java Map UML类关系图如下： 各集合接口、类的介绍 Collection：Collection是最基本集合接口，它定义了一组允许重复的对象。Collection接口派生了三个子接口List、Set和Queue。Collection所有实现类的遍历都可以使用Iterator接口或者是foreach来循环。 List：List代表有序、可重复的集合。 ArrayList：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10，每次扩容都以当前数组大小的1.5倍去扩容。 Vector：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。Vector创建时的默认大小为10；Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。 Stack：Vector的一个子类，是标准的先进后出(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。 LinkedList：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。 CopyOnWriteArrayList：底层使用Copy-On-Write的优化策略实现，适用于读多写少的场景，同ArrayList功能相似，线程安全。CopyOnWriteArrayList在某些情况下比Collections.synchronizedList(List list)有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。 Set：Set代表无序、不可重复的集合。 HastSet：底层使用Hash表来实现，内部使用了HashMap，排列无序不可重复，存取速度快，线程不安全。 LinkedHashSet：底层采用Hash表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较HashSet略慢，比TreeSet快，线程不安全。 TreeSet：底层使用红黑树来实现，内部使用了NavigableMap，按自然顺序或者自定义顺序存放、不可重复，线程不安全。 CopyOnWriteArraySet：底层使用Copy-On-Write的优化策略实现，适用于读多写少的场景，内部使用了CopyOnWriteArrayList，同HastSet功能相似，线程安全。 ConcurrentSkipListSet：底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。 EnumSet：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，EnumSet有两种实现方式，RegularEnumSet和JumboEnumSet，但是这两种实现方式是包私有的，不能在包外访问，因此必须使用工厂方法来创建并返回EnumSet实例，不能通过构造函数来创建。EnumSet中提供了多种创建EnumSet实例的静态工厂方法，例如of方法（进行了函数重载），copyOf方法，noneOf方法等。存储效率快，线程不安全。存储枚举常量时使用EnumSet而不要用HashSet。 Queue：Queue是Java 5之后增加的集合体系，表示队列集合的相关实现，大多遵循先进先出(FIFO, First-In-First-Out)的模式。 PriorityQueue：即优先队列，底层基于优先堆的一个无界队列来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持non-comparable（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。 ArrayBlockingQueue：底层基于定长数组的阻塞队列实现，即是线程安全的有界阻塞队列。ArrayBlockingQueue内部通过互斥锁保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如LinkedBlockingQueue。 LinkedBlockingQueue：即链接队列，底层基于单向链表的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是putLock，获取是takeLock，所以在添加获取方面理论上性能会高于ArrayBlockingQueue。所以LinkedBlockingQueue更适合实现生产者-消费者队列。 PriorityBlockingQueue：即优先阻塞队列，底层基于优先堆的一个无界队列来实现，无界但可选容量界限的阻塞队列，线程安全，功能同PriorityQueue、LinkedBlockQueue相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序。 SynchronousQueue：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个put必须等待一个take，反之亦然。 DelayQueue：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。 ArrayDeque：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque来实现栈的功能，非线程安全。 LinkedBlockingDeque：底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。 ConcurrentLinkedDeque：底层采用了双向链表实现的双端非阻塞并发队列，无限扩展且可选容量。该队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。 LinkedTransferQueue：底层采用了单向链表实现的无界传输阻塞队列，先进先出，无限扩展且可选容量线程安全。 Map：Map代表具有映射关系的集合。 HashMap：底层是用链表数组，Java8后又加了红黑树来实现，键无序不可重复可为null、值可重复可为null，存取速度快，线程不安全。 LinkedHashMap：底层是用链表数组存储，并用双向链表记录插入顺序，键有序不可重复可为null、值可重复可为null，存取速度快较HashMap略慢，比TreeMap快，线程不安全。 HashTable：底层是用链表数组，键无序不可重复可为null、值可重复可为null，存取速度较HashMap慢，线程安全。 Properties：是HashTable的子类，是&lt;String,String&gt;的映射，比HashTable多了load、store两个方法，线程安全。 TreeMap：底层使用红黑树来实现，内部使用了Comparator，按自然顺序或自定义顺序存放键，键不可重复不可为null、值可重复可为null，存取速度较HashMap慢，线程不安全。 EnumMap：底层使用数组来实现，是专门为枚举类型量身定做的Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以EnumMap使用数组来存放与枚举类型对应的值，线程不安全。 WeakHashMap：同HashMap基本相似。区别在于，HashMap的key保留对象的强引用，这意味着只要该HashMap对象不被销毁，该HashMap对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的key-value对象；但WeakHashMap的key只保留对实际对象的弱引用，这意味着当垃圾回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的key-value对象。 IdentityHashMap：同HashMap基本相似。区别在于，在处理两个key相等时，对于普通HashMap而言，只要key1和key2通过equals比较返回true时就认为key相同；在IdentityHashMap中，当且仅当两个key严格相等时(key1 = key2)时才认为两个key相同。 ConcurrentHashMap：底层使用锁分段技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 ConcurrentSkipListMap：底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。 Java集合框架功能介绍思维导图如下： 一些概念解释 跳表：是一种采用了用空间换时间思想的数据结构。它会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。 阻塞队列和非阻塞的区别：如果队列里面已经放满了，如果是阻塞队列那么线程会一直阻塞，而非阻塞对垒则会抛出异常。 一些数据结构的优缺点 Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。 红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。 SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。 一些接口的主要方法梳理Collection接口中的抽象方法 int size()，返回集合的大小 boolean isEmpty()，返回集合是否为空的布尔值 boolean contains(Object o)，返回集合是否包含元素o的布尔值 Iterator&lt;E&gt; iterator()，返回该集合中元素的迭代器，继承自Iterable接口 Object[] toArray()，返回一个包含此集合中所有元素的数组 &lt;T&gt; T[] toArray(T[] a)，toArray()方法的泛型版本，返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定 boolean add(E e)，返回向集合中插入元素e是否成功的布尔值 boolean remove(Object o)，返回从集合中删除元素o是否成功的布尔值 boolean containsAll(Collection&lt;?&gt; c)，返回本集合中是否完全包含集合c的布尔值，即判断集合c是否是本集合子集 boolean addAll(Collection&lt;? extends E&gt; c)，将集合c中的所有元素添加到本集合中并返回 boolean removeAll(Collection&lt;?&gt; c)，移除本集合中所有包含集合c的所有元素 default boolean removeIf(Predicate&lt;? super E&gt; filter)，Java8新增的接口默认方法。将会批量删除符合filter条件的所有元素，该方法需要一个Predicate对象作为作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。 boolean retainAll(Collection&lt;?&gt; c)，返回本集合和集合c中相同的元素并存到本集合中,集合c保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回true void clear()，清空本集合中的所有元素 boolean equals(Object o)，返回本集合是否和对象o相等的布尔值 int hashCode()，返回此集合的Hash码值 default Spliterator&lt;E&gt; spliterator()，在集合中创建Spliterator对象 Spliterator是Java 8引入的新接口，顾名思义，Spliterator可以理解Iterator的Split版本（但用途要丰富很多）。使用Iterator的时候，我们可以顺序地遍历容器中的元素，使用Spliterator的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用Spliterator每次可以处理某个元素集合中的一个元素 — 不是从Spliterator中获取元素，而是使用tryAdvance()或forEachRemaining()方法对元素应用操作。但Spliterator还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。 default Stream&lt;E&gt; stream()，返回一个顺序的Stream对象。Java8引入了Stream以实现对集合更方便地进行函数式编程。 default Stream&lt;E&gt; parallelStream()，返回一个可能并行的Stream对象。Java8新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。 List接口中的额外抽象方法 boolean addAll(int index, Collection&lt;? extends E&gt; c)，将指定集合c中的所有元素插入到指定索引位置处 default void replaceAll(UnaryOperator&lt;E&gt; operator)，Java8新增的使用Lambda的方式，通过应用UnaryOperator获得的结果来替换列表中的每个元素 default void sort(Comparator&lt;? super E&gt; c)，在比较器的基础上将本列表排序 E get(int index)，获取本集合中指定索引位置处的元素 E set(int index, E element)，设置或替换本集合中指定索引位置处的元素 void add(int index, E element)，在本集合中的指定索引位置处插入指定的元素 E remove(int index)，移除本集合中指定索引位置处的元素 int indexOf(Object o)，返回指定元素第一次出现的索引位置 int lastIndexOf(Object o)，返回指定元素最后出现的索引位置 ListIterator&lt;E&gt; listIterator()，返回本集合中的ListIterator迭代器 ListIterator&lt;E&gt; listIterator(int index)，返回本集合中从指定索引位置开始的ListIterator迭代器 List&lt;E&gt; subList(int fromIndex, int toIndex)，返回指定开始和结束索引位置的子集合 Set接口中的额外抽象方法无 Map接口中的抽象方法 boolean containsKey，判断本Map集合中是否包含指定的key键 boolean containsValue，判断本Map集合中是否包含指定的value值 V get(Object key)，根据key获取本Map集合中的value值 V get(Object key)，向本Map集合中存放key键和value值,返回value值 V remove(Object key)，根据key删除本Map集合中的key和value值，并返回删除的value值 void putAll(Map&lt;? extends K, ? extends V&gt; m)，将指定的Map集合添加到本的Map集合当中 Set&lt;K&gt; keySet()，获取本Map集合中的所有key值，并以Set接口的结果作为返回 Collection&lt;V&gt; values()，获取本Map集合中的所有value值，并以Collection接口的结果作为返回 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()，获取本Map集合中的所有key和value值，并以Set&lt;Map.Entry&lt;K, V&gt;&gt;的结果作为返回 default V getOrDefault(Object key, V defaultValue)，根据key获取本Map集合中的value值，如果没找到对应的值或者value值是null,则返回defaultValue的值 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)，Java8新增的使用Lambda的方式遍历操作Map中的元素的默认接口方法 default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)，Java8新增的使用Lambda的方式遍历替换Map中的元素的默认接口方法 default V putIfAbsent(K key, V value)，Java8新增的不用写是否为null值的检测语句向Map中保存key和value的元素的默认接口方法，即如果通过key获取到的value是空的，则在调用put(key, value)方法并返回value值 default boolean remove(Object key, Object value)，Java8新增的默认接口方法，删除给定key所对应的元素，如果value不存在、为null或者与参数中的value不等，则不能删除。即删除操作需要满足给定的值需要和map中的值相等的条件 default boolean replace(K key, V oldValue, V newValue)，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不存在、为null或者与参数中的oldValue不等，则不能替换。即替换操作需要满足给定的值需要和map中的值相等的条件 default V replace(K key, V value)，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不为null，则value值与参数中的value值做替换。 default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)，Java8新增的默认接口方法，根据key获取到的value如果不为null，则直接返回value值，否则将Lambda表达式中的结果值存放到Map中 default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，根据key获取到的value和新计算的值如果不为null，则直接新计算的值，否则移除该key，且返回null default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，将Lambda表达式中的结果值存放到Map中，如果计算的新值为null则返回null，且移除以前有的key和value值 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，将新计算的值覆盖Map中原key对应的value值 SortedSet接口中的额外抽象方法 Comparator&lt;? super E&gt; comparator()，返回本SortedSet集合中的Comparator比较器 SortedSet&lt;E&gt; subSet(E fromElement, E toElement)，获取开始元素和结束元素之间的子SortedSet集合 SortedSet&lt;E&gt; headSet(E toElement)，获取开始元素和toElement元素之间的子SortedSet集合 SortedSet&lt;E&gt; tailSet(E fromElement)，获取fromElement元素和结束元素之间的子SortedSet集合 E first()，获取本SortedSet集合中的第一个元素 E last()，获取本SortedSet集合中的最后一个元素 SortedMap接口中的额外抽象方法 Comparator&lt;? super K&gt; comparator()，返回本SortedMap集合中的Comparator比较器 SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)，获取开始key和结束key之间的子SortedMap集合 SortedMap&lt;K,V&gt; headMap(K toKey)，获取开始key和toKey元素之间的子SortedMap集合 SortedMap&lt;K,V&gt; tailMap(K fromKey)，获取fromKey元素和结束key之间的子SortedMap集合 K firstKey()，获取本SortedMap集合中的第一个key K lastKey()，获取本SortedMap集合中的最后一个key Set&lt;K&gt; keySet()，获取本SortedMap集合中所有key的Set集合 Collection&lt;V&gt; values()，获取本SortedMap集合中所有value的Collection集合 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()，获取本SortedMap集合中所有key和value的Map集合]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML各类关系介绍]]></title>
    <url>%2F2018%2F10%2F22%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2FUML%E5%90%84%E7%B1%BB%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[继承关系（generalization）继承关系用一条带空心箭头的直线表示。如下图所示（A继承自B）： 继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。继承关系为is-a的关系，是类与类或者接口与接口之间最常见的关系之一，在Java中此类关系通过关键字extends来表示。 注意：表现在代码中，继承关系表现为一个类继承另一个类或者一个接口继承另一个接口。 实现关系（realization）实现关系是用一条带空心箭头的虚线表示。如下图所示（A实现B）：： 实现指的是一个class类实现interface接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在Java中此类关系通过关键字implements来表示。 注意：表现在代码中，实现关系表现为普通类实现某个接口。 关联关系（association）关联关系是用一条可能会有方向的直线表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如上图，表示A关联B，但B不关联A；如下图所示： 关联关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。 例如：乘车人和车票之间就是一种关联关系。 注意：表现在代码中，被关联类以类属性的形式出现在关联类中，也可能是关联类引用了一个类型为被关联类的全局变量。 聚合关系（aggregation）聚合关系用一条带空心菱形箭头的直线表示，如下图所示A聚合到B，或者说B由A组成。 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的意思。聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。 注意：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。 组合关系（composition）组合关系用一条带实心菱形箭头的直线表示，如下图表示A组成B，或者B由A组成。 组合关系同样表示整体由部分组成的意思。与聚合关系一样，组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即contains-a的关系，这种关系比聚合更强，也称为强聚合。例如公司由多个部门组成组合，但此时整体与部分是不可分离的，整体的生命周期结束也就意味着部分的生命周期结束。 注意：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。 依赖关系（dependency）依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系。 依赖关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。 注意：表现在代码中，依赖关系体现为类的构造方法及类方法的传入参数。 UML类关系图示例请看以下这个UML类关系图： 开车的类图结构表示的是一个接口 有一个自行车的抽象类，实现了开车的接口，它们之间的关系为实现关系，使用带空心三角箭头的虚线表示 自行车与摩拜单车之间是继承关系，使用带空心三角箭头的实线表示 学生上学需要用到摩拜单车，与摩拜单车是一种依赖关系，使用带箭头的虚线表示 学生与身份证之间为关联关系，使用一根实线表示，如果两个类之间互相通过属性引用，则是双向关联关系 学生与班级、学生与学校之间是聚合关系，使用带空心菱形箭头的实线表示 学校与班级是组合关系，使用带实心菱形箭头的实线表示]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程的理解]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[面向过程和面向对象面向过程思想概述面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。 面向对象思想概述当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。 面向对象特征 抽象 封装 继承 多态 抽象把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面： 数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性) 过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法) 封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。 封装的原则 将不需要对外提供的内容都隐藏起来 把属性都隐藏，提供公共方法对其访问 继承一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。 继承概念的实现方式 类继承：类继承是指直接使用基类的属性和方法而无需额外编码。 接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。 多态多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 实现多态的方式 重载 重写 实现接口 面向对象总结封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了代码重用。而多态则是为了实现另一个目的：接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。 面向对象开发就是不断的创建对象，使用对象，指挥对象做事情。 面向对象设计更好的管理和维护对象之间的关系。 面向对象优点 更符合我们思想习惯的思想 将复杂的事情简单化 将我们从执行者变成了指挥者]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之建造者模式]]></title>
    <url>%2F2018%2F10%2F20%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。 二、模式定义 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式。建造者模式又可以称为生成器模式。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 三、模式结构1. 角色组成建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：导演者 Product：产品角色 2. 结构图 四、示例代码首先，是产品类： 123456789101112131415161718192021222324252627282930/** * 产品类. * * Created by blinkfox on 2016/10/8. */public class Product &#123; private String part1; private String part2; /* getter 和 setter方法. */ public String getPart1() &#123; return part1; &#125; public void setPart1(String part1) &#123; this.part1 = part1; &#125; public String getPart2() &#123; return part2; &#125; public void setPart2(String part2) &#123; this.part2 = part2; &#125;&#125; 其实，是抽象的建造者Builder接口和具体的建造者ConcreteBuilder类： 12345678910111213141516171819202122232425/** * 抽象的建造者. * * Created by blinkfox on 2016/10/8. */public interface Builder &#123; /** * 产品建造部分1. */ void buildPart1(); /** * 产品建造部分2. */ void buildPart2(); /** * 得到建造的产品. * * @return 产品 */ Product getResult();&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 具体的建造者实现类. * * Created by blinkfox on 2016/10/8. */public class ConcreteBuilder implements Builder &#123; /** 产品. */ private Product product = new Product(); /** * 产品建造部分1. */ @Override public void buildPart1() &#123; product.setPart1("编号：95757"); &#125; /** * 产品建造部分2. */ @Override public void buildPart2() &#123; product.setPart2("名称：小机器人"); &#125; /** * 得到建造的产品. * * @return 产品 */ @Override public Product getResult() &#123; return product; &#125;&#125; 最后，导演者Director类： 12345678910111213141516171819202122232425262728/** * 导演者类. * * Created by blinkfox on 2016/10/8. */public class Director &#123; /** 当前需要的建造者对象. */ private Builder builder; /** * 构造方法. * * @param builder */ public Director(Builder builder) &#123; this.builder = builder; &#125; /** * 产品构造方法，负责调用各个零件建造方法. */ public void construct() &#123; builder.buildPart1(); builder.buildPart2(); &#125;&#125; 以下是建造者模式的客户端场景类： 12345678910111213141516171819202122/** * 建造者模式的客户端场景类. * * Created by blinkfox on 2016/10/8. */public class BuilderClient &#123; /** * 主入口方法. * * @param args 数组参数 */ public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.getResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 五、模式分析抽象建造者类中定义了产品的创建方法和返回方法; 建造者模式的结构中还引入了一个导演者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象 在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。 1. 优点建造者模式的优点： 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 2. 缺点建造者模式的缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 3. 适用环境在以下情况下可以使用建造者模式： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 4. 建造者模式与抽象工厂模式的比较 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 六、模式总结 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之外观模式]]></title>
    <url>%2F2018%2F10%2F18%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式定义 外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 二、模式结构1. 角色组成外观模式包含如下角色： Facade: 外观角色 SubSystem: 子系统角色 2. 结构图 三、示例代码首先，是各个子系统角色类，分别如下： 123456789101112/** * 子系统类A. * * Created by blinkfox on 16/8/25. */public class ClassA &#123; public void doSomethingA() &#123; System.out.println("----业务方法A..."); &#125;&#125; 123456789101112/** * 子系统类B. * * Created by blinkfox on 16/8/25. */public class ClassB &#123; public void doSomethingB() &#123; System.out.println("----业务方法B..."); &#125;&#125; 123456789101112/** * 子系统类C. * * Created by blinkfox on 16/8/25. */public class ClassC &#123; public void doSomethingC() &#123; System.out.println("----业务方法C..."); &#125;&#125; 以下是外观模式的外观类： 1234567891011121314151617181920212223242526/** * 外观门面类. * * Created by blinkfox on 16/8/25. */public class Facade &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); // 以下是提供给外部访问的方法. public void methodA() &#123; this.a.doSomethingA(); &#125; public void methodB() &#123; this.b.doSomethingB(); &#125; public void methodC() &#123; this.c.doSomethingC(); &#125;&#125; 四、模式分析根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式的目的在于降低系统的复杂程度。 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 1. 优点外观模式的优点k： 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。 2. 缺点外观模式的缺点： 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 3. 适用环境在以下情况下可以使用外观模式： 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 五、模式总结 在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之中介者模式]]></title>
    <url>%2F2018%2F10%2F17%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题： 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。 二、模式定义 中介者模式(Mediator Pattern)：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。 三、模式结构1. 角色组成中介者模式包含如下角色： Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 2. 结构图 四、示例代码首先，是抽象的Mediator类和具体的ConcreteMediator类： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 通用抽象中介者类. * * Created by blinkfox on 16/8/21. */public abstract class Mediator &#123; /** 定义同事类1. */ protected ConcreteColleague1 colleague1; /** 定义同事类2. */ protected ConcreteColleague2 colleague2; /* getter 和 setter 方法 */ public ConcreteColleague1 getColleague1() &#123; return colleague1; &#125; public void setColleague1(ConcreteColleague1 colleague1) &#123; this.colleague1 = colleague1; &#125; public ConcreteColleague2 getColleague2() &#123; return colleague2; &#125; public void setColleague2(ConcreteColleague2 colleague2) &#123; this.colleague2 = colleague2; &#125; /** * 中介者模式的抽象业务逻辑1. */ public abstract void doSomething1(); /** * 中介者模式的抽象业务逻辑2. */ public abstract void doSomething2();&#125; 1234567891011121314151617181920212223242526/** * 具体的通用中介者类. * * Created by blinkfox on 16/8/21. */public class ConcreteMediator extends Mediator &#123; /** * 中介者模式的具体业务逻辑1. */ @Override public void doSomething1() &#123; super.colleague1.selfMethod1(); super.colleague2.selfMethod2(); &#125; /** * 中介者模式的具体业务逻辑2. */ @Override public void doSomething2() &#123; super.colleague1.selfMethod1(); super.colleague2.selfMethod2(); &#125;&#125; 其实，是抽象的Colleague类和具体的ConcreteColleague类： 123456789101112131415/** * 抽象的同事类. * * Created by blinkfox on 16/8/21. */public abstract class Colleague &#123; /** 中介者. */ protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 123456789101112131415161718192021222324252627/** * 具体的同事类1. * * Created by blinkfox on 16/8/21. */public class ConcreteColleague1 extends Colleague &#123; public ConcreteColleague1(Mediator mediator) &#123; super(mediator); &#125; /** * 自有方法. */ public void selfMethod1() &#123; System.out.println("------ConcreteColleague1-处理自己的业务逻辑1--------"); &#125; /** * 依赖方法. */ public void depMethod1() &#123; System.out.println("------ConcreteColleague1-委托给中介者的业务逻辑1--------"); super.mediator.doSomething1(); &#125;&#125; 123456789101112131415161718192021222324252627/** * 具体的同事类2. * * Created by blinkfox on 16/8/21. */public class ConcreteColleague2 extends Colleague &#123; public ConcreteColleague2(Mediator mediator) &#123; super(mediator); &#125; /** * 自有方法2. */ public void selfMethod2() &#123; System.out.println("------ConcreteColleague2-处理自己的业务逻辑2--------"); &#125; /** * 依赖方法2. */ public void depMethod2() &#123; System.out.println("------ConcreteColleague2-委托给中介者的业务逻辑2--------"); super.mediator.doSomething2(); &#125;&#125; 以下是中介者模式的客户端场景类： 123456789101112131415161718192021/** * 中介者模式的场景类 * Created by blinkfox on 16/8/21. */public class MediatorClient &#123; public static void main(String[] args) &#123; Mediator mediator = new ConcreteMediator(); ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator); ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator); mediator.setColleague1(colleague1); mediator.setColleague2(colleague2); colleague1.depMethod1(); colleague2.depMethod2(); mediator.doSomething1(); mediator.doSomething2(); &#125;&#125; 五、模式分析中介者模式可以使对象之间的关系数量急剧减少。 中介者承担两方面的职责： 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。 1. 优点中介者模式的优点： 简化了对象之间的交互。 将各同事解耦。 减少子类生成。 可以简化各同事类的设计和实现。 2. 缺点中介者模式的缺点： 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 3. 适用环境在以下情况下可以使用中介者模式： 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。 交互的公共行为，如果需要改变行为则可以增加新的中介者类。 六、模式总结 中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。 中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。 通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。 中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之命令模式]]></title>
    <url>%2F2018%2F10%2F16%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。 命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。 二、模式定义 命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 三、模式结构1. 角色组成命令模式包含如下角色： Command: 抽象命令类 ConcreteCommand: 具体命令类 Invoker: 调用者 Receiver: 接收者 Client: 客户类 2. 结构图 四、示例代码首先，是抽象的Receiver类和具体的Receiver类： 12345678910111213/** * 通用的抽象 Receiver 接收者. * * Created by blinkfox on 16/8/17. */public abstract class Receiver &#123; /** * 定义每个接收者都必须完成的业务. */ public abstract void doSomething();&#125; 12345678910111213/** * 具体的 Receiver 类1. * * Created by blinkfox on 16/8/17. */public class ConcreteReceiver1 extends Receiver &#123; @Override public void doSomething() &#123; System.out.println("ConcreteReceiver1 处理的业务逻辑..."); &#125;&#125; 12345678910111213/** * 具体的 Receiver 类2. * * Created by blinkfox on 16/8/17. */public class ConcreteReceiver2 extends Receiver &#123; @Override public void doSomething() &#123; System.out.println("ConcreteReceiver2 处理的业务逻辑..."); &#125;&#125; 其实，是抽象的Command类和具体的Command类： 12345678910111213/** * 抽象的 Command 类. * * Created by blinkfox on 16/8/17. */public abstract class Command &#123; /** * 命令的抽象执行命令的方法. */ public abstract void execute();&#125; 1234567891011121314151617181920212223/** * 具体的 Command 命令类1. * * Created by blinkfox on 16/8/17. */public class ConcreteCommand1 extends Command &#123; /** 对哪个receiver类进行处理. */ private Receiver receiver; public ConcreteCommand1(Receiver receiver) &#123; this.receiver = receiver; &#125; /** * 必须实现的一个命令. */ @Override public void execute() &#123; this.receiver.doSomething(); &#125;&#125; 1234567891011121314151617181920212223/** * 具体的 Command 命令类2. * * Created by blinkfox on 16/8/17. */public class ConcreteCommand2 extends Command &#123; /** 对哪个receiver类进行处理. */ private Receiver receiver; public ConcreteCommand2(Receiver receiver) &#123; this.receiver = receiver; &#125; /** * 必须实现的命令. */ @Override public void execute() &#123; this.receiver.doSomething(); &#125;&#125; 最后，调用者Invoker类： 1234567891011121314151617181920/** * 调用者 Invoker 类. * * Created by blinkfox on 16/8/17. */public class Invoker &#123; private Command command; public void setCommand(Command command) &#123; this.command = command; &#125; /** * 执行命令. */ public void action() &#123; this.command.execute(); &#125;&#125; 以下是命令模式的客户端场景类： 123456789101112131415161718/** * 命令模式的场景类. * * Created by blinkfox on 16/8/17. */public class CommandClient &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new ConcreteReceiver1(); Command command = new ConcreteCommand1(receiver); // 把命令交给调用者执行 invoker.setCommand(command); invoker.action(); &#125;&#125; 五、模式分析命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。 1. 优点命令模式的优点： 降低系统的耦合度。 新的命令可以很容易地加入到系统中。 可以比较容易地设计一个命令队列和宏命令（组合命令）。 可以方便地实现对请求的Undo和Redo。 2. 缺点命令模式的缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 3. 适用环境在以下情况下可以使用命令模式： 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 系统需要将一组操作组合在一起，即支持宏命令 六、模式总结 在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。 命令模式包含四个角色：抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。 命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。 命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道内容概要]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93%2F%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E5%86%85%E5%AE%B9%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！ 一、在正式开始之前，我们先思考几个几个问题：1.需求与代码哪个重要？答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。 2.易读和易懂是一回事吗？答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。 3.什么是测试驱动代码？答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。 4.什么是简单的代码？答：1.能通过所有测试2.没有重复代码3.体现系统中全部设计理念4.包含尽量少的实体，包括，类，函数，方法等 如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。 二、第二章 有意义的命名1.名副其实变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。 2.避免误导必须避免留下掩藏代码本意的错误线索。 3.做有意义的区分只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。 4.使用读得出来的名称不要用傻乎乎的自造词，而不是恰当的英语词。 5.使用可搜索的名称使用便于搜索的名字。 6.避免使用编码把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。 7.避免思维映射不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。 8.类名或对象名最好使用名词或者名词短语9.方法名最好使用动词或者动词短语10.别扮可爱命名一定要通俗易懂。 11.每一个概念对应一个词给每个抽象概念选择一个词，并一以贯之 12.别用双关语词避免将同一个词用于不同目的，遵循一词一义的原则 13.使用解决方案领域名14.使用源自所涉领域名15.添加有意义的语境在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。 16.不要添加没用的语境三、第三章 函数1.短小函数第一规则是要短小。第二条规则是还要更短小。 2.只做一件事 函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。 函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。 3.每个函数一个抽象层级4.switch语句确保每个switch都埋藏在较低的抽象层级，而且永远不重复。 5.使用描述性的名称命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。 6.函数参数 最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。 如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。 函数和函数的参数命名一般是动名词比较好。 7.无副作用8.分割指令与查询函数要么做什么事，要么回答什么事，但二者不可兼得 9.使用异常替代返回错误码 返回错误码的时候，就是在要求调用者立刻处理错误。 如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。 抽离try/catch代码块 10.别重复自己11.结构化编程四、第四章 注释1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？ 法律信息 提供信息的注释 提供意图的解释 阐释 警告 TODO注释 TODO是一种程序要认为应该要做的，但是由于某种原因没有做的 放大,放大某些看似不合理的地方 五、第六章 对象和数据结构1.得墨忒定律模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。 六、第七章 错误处理1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。七、第八章 边界1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。八、第九章 单元测试1.TDD三定律 在编写不能通过的单元测试前，不可编写生产代码。 只可编写刚好无法通过的单元测试，不能编译也算不通过 只可编写刚好足以通过当前失败测试的生产代码 2.整洁测试三要素 可读性 可读性 可读性 3.整洁测试的五条原则： 快速，测试应该够快 独立，测试应该相互独立 可重复，测试应当可在任何环境中重复通过。 自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。 及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。 九、第十章 类1.单一权责原则，类或者模块应有且只有一条加以修改的理由。2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。十、第十一章 系统1.将系统的构造与使用分开软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度） 1.1分解main将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。 1.2工厂模式使用该模式可以将系统构造和系统运行时逻辑分开。 1.3依赖注入（需要强化理解）1.4扩容“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。 1.5测试驱动系统架构最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO)) 1.6优化决策模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。 十一、第十二章 迭进1. 通过迭进设计达到代码整洁的目的：通过这几个原则可以让你的设计变简单（DIP，SRP） 运行所有测试 不可重复， 表达了程序员的意图 尽可能减少类和方法的数量 以上规则按其重要程度排序 2. 简单设计规则1:运行所有测试编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。 3. 简单设计规则2-4：重构在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。 4. 不可重复5. 表达力6. 尽可能少的类和方法十二、第十三章 并发编程1. 为什么要并发并发是一种解耦策略。它帮我们把做什么和何时做分解开。 2. 并发的防御原则13.1 单一权责原则（SRP）并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑， 并发相关代码由自己的开发，修改和调优生命周期 开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难 即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。 建议：分离并发相关代码与其他代码。 13.2 限制数据作用域两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用synchronized关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。 建议：谨记数据封装，严格限制对可能被共享的数据的访问。 13.3 使用数据副本避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。 13.4 线程尽可能地独立让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。 建议：尝试将数据分解到可被独立线程操作的独立子集。 13.5 了解执行模型13.5.1 生产者－－－消费者模型一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。 13.5.2 读者－－－作者模型当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。 挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。 13.5.3哲学家问题（故事内容不在这里描述）从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。 13.6 警惕同步方法之间的依赖同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。 建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段： 基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。 基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。 适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。 13.7保持同步区域微小应该尽可能少地设计临界区，如果有请尽可能减小同步区域。 13.8 编写线程需要注意的几点：(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码 1.单线程与多线程在执行时不同的情况 2.线程代码与实物或测试替身互动 3.用运行速度,缓慢和有变动的测试替身执行 4.将测试配置为能运行一定数量的迭代 建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。 (4). 编写可调整的线程代码在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。 (5). 运行多余处理器数量的线程任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。 (6). 在不同平台上运行(7). 调整代码并强迫错误发生十三、第14章 逐步改进代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。 十四、第17章 味道与启发1. 注释(1). 不恰当的注释信息让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。 (2). 废弃的注释过时，无关或不正确的注释就是废弃的注释。 (3). 冗余注释如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。 (4). 注释要写就要写最好的注释，别画蛇添足(5). 注释掉的代码，看到注释掉的代码就删。2. 环境(1). 需要多步才能实现的构建构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。 (2). 需要多步才能做到测试你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。 3. 函数 函数的参数应该少。 输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。 标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。 永不被调用的方法应该丢弃。 4. 一般性问题(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。 (2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。 (3). 不正确的边界行为，追索每种边界条件，编写测试。 (4). 忽视安全 (5). 重复，尽可能找到并消除重复。 (6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。 (7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。 (8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。 优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。 (9). 死代码一定要删除。 (10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。 (11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。 (12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。 (13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。 (14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。 (15). 选择算子参数，尽量不要把boolean作为函数参数 (16). 晦涩意图，代码要尽可能具有表达力。 (17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。 (18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。 (19). 使用解释性变量，命名要有意义。 (20). 函数名称应该表达其行为 (21). 理解算法 (22). 把逻辑依赖改为物理依赖： 1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。 2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。 (23). 用多态替代if/else 或 switch/case (24). 遵循标准约定 (25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。 (26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。 (27). 结构甚于约定，坚守结构甚于约定的设计决策。 (28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。 例如： 1if(shouldBeDeleted(timer)) 要好于 1if(timer.hasExpired() &amp;&amp; !timer.isRecurrent()) (29). 避免否定性条件，尽可能将条件表示为肯定形式。 (30). 函数只该做一件事 (31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。 (32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。 (33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。 (34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。 (35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。 (36). 避免传递浏览，编写害羞代码。 (37). 不要继承常量 17.5 测试 使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。 别略过小测试 被忽略的测试就是对不确定事物的疑问。 测试边界条件 全面测试相近的缺陷，缺陷趋向于扎堆。 测试失败的模式有启发性。 测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。 测试应该快速。 来自：代码整洁之道内容概要]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>整洁代码</tag>
        <tag>重构</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之观察者模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。 二、模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 观察者模式是一种对象行为型模式。 三、模式结构1. 角色组成：观察者模式包含如下角色： Subject: 目标（抽象的被观察着） ConcreteSubject: 具体目标（具体的被观察者） Observer: 观察者 ConcreteObserver: 具体观察者 2. 结构图： 3. 时序图： 四、示例代码首先，是观察者接口： 12345678910/** * 观察者接口 * Created by blinkfox on 16/7/14. */public interface Observer &#123; // 更新的方法 public void update();&#125; 接下来，是具体的观察者类： 12345678910111213141516/** * 具体的观察者. * * Created by blinkfox on 16/7/15. */public class ConcreteObserver implements Observer &#123; /** * 实现更新方法. */ @Override public void update() &#123; System.out.println("接收到信息,并进行处理..."); &#125;&#125; 然后，是被观察者的抽象类： 1234567891011121314151617181920212223242526272829303132333435363738/** * 被观察者的抽象类. * * Created by blinkfox on 16/7/14. */public abstract class Subject &#123; /** 定义一个观察者的集合. */ private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); /** * 增加一个观察者. * * @param o */ public void addObserver(Observer o) &#123; this.observers.add(o); &#125; /** * 删除一个观察者. * * @param o */ public void delObserver(Observer o) &#123; this.observers.remove(o); &#125; /** * 通知所有观察者. */ public void notifyObservers() &#123; for (Observer o: observers) &#123; o.update(); &#125; &#125;&#125; 具体的被观察者： 123456789101112131415/** * 具体的被观察者. * * Created by blinkfox on 16/7/15. */public class ConcreteSubject extends Subject &#123; /** * 具体的业务. */ public void doSomething() &#123; super.notifyObservers(); &#125;&#125; 最后，是用于测试观察者模式的客户端场景类： 123456789101112131415161718/** * 观察者模式客户端场景类. * * Created by blinkfox on 16/7/15. */public class ObserverClient &#123; public static void main(String[] args) &#123; // 创建一个被观察者和观察者. ConcreteSubject sub = new ConcreteSubject(); Observer obs = new ConcreteObserver(); // 观察者观察被观察者. sub.addObserver(obs); // 观察者开始活动了. sub.doSomething(); &#125;&#125; 五、模式分析 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publish-subscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。 1. 优点观察者模式的优点： 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合“开闭原则”的要求。 2. 缺点观察者模式的缺点： 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 3.适用环境在以下情况下可以使用观察者模式： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 六、总结 观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。 观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。 在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Bash命令整理之其他常用命令]]></title>
    <url>%2F2018%2F10%2F13%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FLinux%2F%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. hostname - 查看主机名hostname命令用于查看系统的主机名，或是修改系统的主机名。 hostname的常用命令如下： 12345678# 显示系统的当前主机名hostname# 修改你系统的主机名hostname blinkfox-system# 使用 -F 选项，从指定的文件中读取主机名hostname -F /root/hostname.txt 2. uptime - 查看系统运行时间uptime命令用于打印系统的运行时间等信息。使用如下： 1uptime 3. w、who - 列出登录的用户w命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下： 1234567w# 打印如下22:42 up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER TTY FROM LOGIN@ IDLE WHATblinkfox console - 日19 6days -blinkfox s000 - 五23 - w who命令有与w命令类似的用途，但它的功能比w命令更强大一些。语法格式如下： 1who [OPTION]... [FILE | ARG1 ARG2] who常用命令如下： 1234567891011121314151617# 显示当前登录的所有用户信息who# 显示系统的启动时间who -b# 显示系统登录进程who -l# 显示与当前标准输入关联的用户信息who -m# 显示系统的运行级别who -r# 显示所有登录用户的用户名和登录用户数who -q 4. uname - 查看系统信息uname命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示： 1uname [OPTION]... 常用使用方式如下： 1234567891011121314151617181920# 只打印内核的名称uname# 使用 -n 选项，只打印系统的主机名uname -n# 使用 -r 选项，打印内核版本信息uname -r# 使用 -m 选项，打印系统的硬件名称uname -m# 使用 -p 选项，打印系统的处理器类型信息uname -p# 使用 -i 选项，打印系统的硬件平台信息uname -i# 使用 -a 选项，打印上述所有示例中的信息uname -a 5. date - 显示和设置系统日期和时间date命令用于以多种格式显示日期和时间，或设置系统的日期和时间。date命令的语法如下所示： 12date [OPTION]... [+FORMAT]date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] 常用使用命令如下： 1234567891011121314151617181920212223242526272829303132333435# 以默认格式显示系统的当前日期时间date# 格式化当前日期date +"%Y-%m-%d"# 格式化输出昨天的日期date -d "1 day ago" +"%Y-%m-%d"# 2秒后格式化输出date -d "2 second" +"%Y-%m-%d %H:%M.%S"# 普通格式化转出date -d "2009-12-12" +"%Y/%m/%d %H:%M.%S"# apache格式转换date -d "Dec 5, 2009 12:00:37 AM" +"%Y-%m-%d %H:%M.%S"# 日期加减操作date +%Y%m%d #显示前天年月日date -d "+1 day" +%Y%m%d #显示前一天的日期date -d "-1 day" +%Y%m%d #显示后一天的日期date -d "-1 month" +%Y%m%d #显示上一月的日期date -d "+1 month" +%Y%m%d #显示下一月的日期date -d "-1 year" +%Y%m%d #显示前一年的日期date -d "+1 year" +%Y%m%d #显示下一年的日期# 设定时间date -s # 设置当前时间，只有root权限才能设置，其他只能查看date -s 20160816 # 设置成20160816，这样会把具体时间设置成空00:00:00date -s 01:01:01 # 设置具体时间，不会对日期做更改date -s "01:01:01 2012-05-23" # 这样可以设置全部时间 date -s "01:01:01 20120523" # 这样可以设置全部时间date -s "2012-05-23 01:01:01" # 这样可以设置全部时间 date -s "20120523 01:01:01" # 这样可以设置全部时间 6. id - 显示用户属性id命令用于打印输出用户uid、gid、用户名和组名等用户身份信息。id命令的语法如下所示： 1id [OPTION]... [USERNAME] 常见使用命令如下： 1234567891011121314151617181920# 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息id# 使用 -u 选项，输出用户的 uidid -u#-u 选项和 -n 选项结合使用，输出账户的用户名id -un# 使用 -g 选项，输出帐号当前起作用的gidid -g# -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名id -gn# 使用 -G 选项，输出帐号所属的所有群组idid -G root# -G 与 -n 选项结合使用，输出账号所属的所有群组的名称id -Gn root]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Bash命令整理之文本处理]]></title>
    <url>%2F2018%2F10%2F11%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FLinux%2F%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. sort - 文本排序sort命令用于将文本文件的行排序。默认情况下，sort命令是按照字符串的字母顺序排序。 sort 的常用命令如下： 1234567891011121314# 将文本内容按字母顺序排序sort example.txt# 使用 -u 选项，移除所有重复行后排序sort -u example.txt# 使用 -n 选项，将令数字按数值的大小排序sort -n example.txt# 使用 -r 选项，以倒序方式排序sort -n -r example.txt# 同时将 file1、file2 的内容排序sort file1 file2 2.uniq - 文本去重uniq命令用于移除或发现文件中重复的条目。 1234567891011121314151617181920212223# 它将移除文件中重复的行并显示单一行uniq example.txt# 可以统计重复行出现的次数uniq -c example.txt# 使用 -d 选项，只显示文件中有重复的行并只显示一次uniq -d example.txt# 使用 -D 选项，显示文件中所有重复的行uniq -D example.txt# 使用 -u 选项，只显示文件中不重复的行uniq -u example.txt# 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复uniq -w 3 example.txt# 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复uniq -s 3 example.txt# 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复uniq -f 1 example.txt 3.tr - 替换或删除字符tr命令主要用于删除文件中控制字符或进行字符转换。使用tr时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。tr刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。 tr命令的语法如下所示： 1tr [OPTION]... SET1 [SET2] 常用命令示例： 1234567891011121314151617181920# 若要将大括号转换为小括号tr '&#123;&#125;' '()' &lt; textfile &gt; newfile# 若要将大括号转换成方括号tr '&#123;&#125;' '\[]' &lt; textfile &gt; newfile# 若要将小写字符转换成大写，请输入：tr 'a-z' 'A-Z' &lt; textfile &gt; newfile# 若要创建一个文件中的单词列表tr -cs '[:lower:][:upper:]' '[\n*]' &lt; textfile &gt; newfile# 若要从某个文件中删除所有空字符tr -d '\0' &lt; textfile &gt; newfile# 若要用单独的换行替换每一序列的一个或多个换行，请输入：tr -s '\n' &lt; textfile &gt; newfile# 要以单个“#”字符替换 &lt;space&gt; 字符类中的每个字符序列tr -s '[:space:]' '[#*]' 4.grep - 查找字符串grep命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，grep命令只显示匹配的行。 grep命令的语法如下所示： 12grep [OPTION]... PATTERN [FILE]...grep [OPTION]... [-e PATTERN | -f FILE] [FILE]... 1234567891011121314151617181920212223# `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息grep blinkfox /etc/passwd# 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写grep -i blinkfox /etc/passwd# 使用 -r 选项，可以递归搜索指定目录下的所有文件grep -r blinkfox /etc/# 使用 -w 选项，只匹配包含指定单词的行grep -w blinkfox /etc/# 使用 -c 选项，报告文件或文本中模式被匹配的次数grep -c blinkfox /etc/passwd# 使用 -n 选项，显示每一个匹配的行的行号grep -n blinkfox /etc/passwd# 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行grep -v blinkfox /etc/passwd# 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出grep --color blinkfox /etc/passwd 5.diff - 比较两个文件diff命令用于比较两个文件，并找出它们之间的不同。diff命令的语法如下所示： 1diff [OPTION]... from-file to-file 常用使用方式如下： 1234567891011# 比较两个文件diff nsswitch.conf nsswitch.conf.org# 使用 -w 选项，比较时忽略空格diff -w nsswitch.conf nsswitch.conf.org# 使用 -y 选项，以并排的格式输出两个文件的比较结果diff -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果diff -c nsswitch.conf nsswitch.conf.org]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Bash命令整理之操作文件和目录]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FLinux%2F%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. touch - 创建文件touch命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。touch命令又如下选项： 12345-a: 只改变访问时间 -c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 [[CC]YY]MMDDhhmm[.ss] 替代当前时间 touch 命令的常见用法如下： 1234567891011121314151617181920# 创建一个名为 effyl 的新空文件touch effyl# 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件touch effyl myeffyl lueffyl# 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个touch -a effyl# 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳touch -c effyl# 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变touch -m effyl# 使用 -c 和 -t 选项，来明确设置文件的时间touch -c -t YYMMDDHHMM filename# 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项touch -r myeffyl effyl 2.mkdir - 创建目录mkdir命令用于创建一个新目录。最基本的mkdir命令的使用方法如下所示： 123456789101112131415# 在当前目录下创建一个给定的目录名mkdir &lt;dirname&gt;# 在 backup 中的相对路径创建一个名为 old 的目录mkdir backup/old# 在 backup 中的绝对路径中创建一个名为 old 的目录mkdir /home/blinkfox/backup/old# 使用 -p 选项，会自动创建所有还不存在的父目录mkdir -p backup/old# 使用 -m 选项，可以设置将要创建目录的权限# 如：创建一个任何人都有读写访问权限的目录mkdir -p -m 777 backup/old 3.cp - 复制文件或目录cp命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。 使用 cp 命令复制文件和目录的语法有以下几种： 12345678# 复制源文件到目标文件cp [OPTION] SOURCE DEST# 复制一个或多个源文件到一个目录cp [OPTION] SOURCE... DIRECTORY# 同上cp [OPTION] -t DIRECTORY SOURCE... 常用使用示例如下： 123456789101112131415# 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txtcp file.txt newfile.txt# 复制当前目录下的 file.txt 文件到 /tmp 目录下cp file.txt /tmp# 复制当前目录下的所有文件到 /tmp 目录下cp * /tmp# 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息cp -p filename /path/to/new/location/myfile# 使用 -R 或 -r 选项，恶意递归地复制一个目录# 即将一个目录及其下的所有文件和子目录都复制到另一个目录cp -R * /home/blinkfox/backup 4.ln - 链接文件或目录ln命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接： 12345# 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.soln -s /home/blinkfox/src/library.so /home/blinkfox/lib# 创建目录的软链接ln -s /home/blinkfox/src source 5. mv - 移动文件或目录mv命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，mv命令还可用于修改文件或目录的名字。 mv 命令的基本语法如下所示： 1mv SOURCE... DIRECTORY 常用命令如下： 1234567891011121314151617# 将当前目录下的文件 source.txt 移到目录 /tmp 下mv source.txt /tmp# 将目录 dir1、dir2 移到目录 dir_dist 下mv dir1 dir2 dir_dist# 将当前目录下的 old.txt 文件更名为 new.txtmv old.txt new.txt# 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息mv -i old.txt new.txt# 将当前目录下的所有文件移动到目录 /tmp 下mv * /tmp/# 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录mv -u dir1/* dir2/ 6.rm - 删除文件或目录rm命令用于删除指定的文件和目录。其语法如下所示： 1rm [OPTIONS]... FILE... rm的常用命令如下： 1234567891011121314151617181920212223242526272829303132333435363738# 删除当前目录下的文件 file1.txt、file2.txt、file3.txtrm file1.txt file2.txt file3.txt# 删除当前目录下的所有文件rm *# 删除你当前帐号主目录下的 temp 目录中的所有文件rm ~/temp/*# 使用 -i 选项，可以在删除每个文件或目录前提示用户确认rm -i *# 删除当前目录下所有以".doc"结尾的文件rm *.doc# 删除当前目录下所有文件名中包含"movie"字符串的文件rm *movie*# 删除当前目录下所有以"a"开头的文件rm a*# 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件rm ???# 删除当前目录下文件扩展名有两个字符的所有文件rm *.??# 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件rm *[abc]*# 删除当前目录下文件名中包含 0~9 的所有文件rm *[0-9]*# 删除当前目录下文件扩展名是字母 c 或 h 的所有文件rm *.[ch]# 删除 /tmp 目录下的所有文件及其子目录rm -rf /tmp/* -f 删除前不提示用户确认，并忽略不存在的文件 -r 递归地删除目录及其下的内容]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Bash命令整理之查看文件和目录]]></title>
    <url>%2F2018%2F10%2F09%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FLinux%2F%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. ls - 列出文件名和目录ls命令是Linux中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入ls命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。 以下便是ls命令及其选项的作用说明： 1234567891011121314151617181920212223242526272829303132# 仅列出当前目录下所有文件和目录ls# 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等ls -l# 将文件大小显示符合人类阅读习惯的格式ls -lh# 将使用不同的特殊字符归类不同的文件类型ls -F# 以长列表格式列出某个目录的信息ls -ld /var/log# 将递归地列出子目录的内容ls -R /etc/sysconfig/# 以长列表格式按文件或目录的修改时间倒序地列出文件和目录ls -ltr# 以长列表格式按文件大小顺序列出文件和目录ls -ls# 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）ls -a# 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）ls -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组ls -n 2. cat - 连接显示文件内容cat 命令也是Linux系统中最常用的命令之一。cat命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。 cat命令的语法如下所示： 1cat [OPTION] [FILE]... cat常用命令如下： 1234567891011121314# 使用 cat 命令查看文件 /etc/group 的内容cat /etc/group# 显示多个文件的内容cat /etc/redhat-release /etc/issue# -n 选项，可以显示文件内容的行号cat -n /etc/fstab# -b 选项和 -n 选项类似，但只标识非空白行的行号cat -b /etc/fstab# -e 选项，将在每一行的结尾显示“$”字符cat -e /etc/fstab 当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。 3.less、more - 分屏显示文件more命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。 12345# 查看一个文件，自动清空屏幕并显示文件开头部分more /etc/inittab# 指定一次显示num行more -num /etc/inittab 与more命令相比，我个人更喜欢less命令来查看文件。less命令与more命令类似，但less命令向前和向后翻页都支持，而且less命令不需要在查看前加载整个文件，即less命令查看文件更快速。 less常用命令参数如下： 1234567891011121314151617181920212223242526-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 4.head - 显示文件头部head命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。 使用-n选项可以指定打印文件的前N行： 123456# 指定打印文件的前5行head -n 5 /etc/inittab（或）head -5 /etc/inittab# 打印文件的前N个字节的数据head -c 10 /etc/inittab 5.tail - 显示文件尾部tail命令和head命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。 使用-n选项可以指定打印文件的最后N行： 123456789# 指定打印文件的后10行tail -n 10 /etc/inittabtail -10 /etc/inittab# 即时打印文件中新写入的行tail -f /var/log/messages# --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件tail -f /tmp/debug.log --retry 6.file - 查看文件类型file命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。 12345678# 查看文件类型file /etc/inittab# 可以MIME类型的格式显示文件类型的信息file -i /etc/inittab# 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示file -N * 7.wc - 查看文件统计信息wc命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示： 12wc filenameX Y Z /etc/inittab 其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。 1234567891011# -l选项，可以只统计文件的行数信息wc -l /etc/inittab# -w选项，可以只统计文件的单词数信息wc -w /etc/inittab# -c选项，可以只统计文件的字节数信息wc -c /etc/inittab# -L选项，可以只统计文件中最长的行的长度wc -L /etc/inittab 8.find - 查找文件或目录find命令用于根据你指定的参数搜索和定位文件和目录的列表。find命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。 find命令常用使用和说明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 查找指定目录下的某个文件find /etc/ -name inittab# 在当前目录下查找名称为 inittab 的文件find . -name inittab# 在当前目录下，文件不区分大小写是example的所有文件find . -iname example# 找出当前目录下所有以 sh 结尾的文件find . -type f -name "*.sh"# 找出当前目录下，文件权限是 777 的所有文件find . -type f -perm 777# 找出当前目录下，文件权限不是 777 的所有文件find . -type f ! -perm 777# 找出当前目录下所有只读文件find . -type f ! -perm /a+w# 找出你帐号主目录下的所有可执行文件find ~ -type f -perm /a+w# 找出 /tmp 目录下的.log文件并将其删除：find /tmp/ -type f -name "*.log" -exec rm -f &#123;&#125; \;# 找出当前目录下的所有空文件find . -type f -empty# 找出当前目录下的所有空目录find . -type d -empty# 找出 /tmp 目录下的所有隐藏文件find /tmp/ -type f -name ".*"# 找出 /tmp 目录下，所有者是 root 的文件和目录find /tmp/ -user root# 找出 /tmp 目录下，用户组是 developer 的文件和目录find /tmp/ -group root# 找出你账号的主目录下，3 天前修改的文件find ~ -type f -mtime 3# 找出你账号的主目录下，30 天以前修改的所有文件find ~ -type f -mtime +30# 找出你账号的主目录下，3 天以内修改的所有文件find ~ -type f -mtime -3# 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件find ~ -type f -mtime +30 -mtime -60# 找出 /etc 目录下，一小时以内变更过的文件find /etc -type f -cmin -60# 找出 /etc 目录下，一小时以内访问过的文件find /etc -type f -amin -60# 找出你账号主目录下，大小是50MB的所有文件find ~ -type f -size 50MB# 找出你账号主目录下，大于50MB小于100MB的所有文件find ~ -type f -size +50MB -size -100MB# 找出你账号主目录下，大于100MB的文件并将其删除find ~ -type f -size +100MB -exec rm -rf &#123;&#125; \;]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量级滚动动画JavaScript库aos.js]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2F%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BBJavaScript%E5%BA%93aos.js%2F</url>
    <content type="text"><![CDATA[一、简介aos.js是一款效果超赞的页面滚动的 JavaScript 动画库插件。该动画库可以在页面滚动时提供28种不同的元素动画效果，以及多种easing效果。在页面往回滚动时，元素会恢复到原来的状态。 注：从2.0.0版本之后,只支持使用data-aos属性，不再支持使用aos属性。 二、安装1. Bower 安装你可以使用 Bower 包管理工具安装aos： 1bower install aos --save 2. npm你也能在 npm 上找到 aos： 1npm install aos --save 3. Github 下载Github 下载点击此处 三、使用示例1. 使用方法引入CSS样式文件： 1&lt;link rel="stylesheet" href="bower_components/aos/dist/aos.css" /&gt; 添加JavaScript脚本文件： 1&lt;script src="bower_components/aos/dist/aos.js"&gt;&lt;/script&gt; 初始化载入AOS： 123&lt;script&gt; AOS.init();&lt;/script&gt; 2. 简单示例123456789101112131415161718192021222324252627282930313233343536373839body &#123; font-family: Helvetica,Tahoma;&#125;*,*:before,*:after &#123; box-sizing: border-box;&#125;.aos-all &#123; width: 1000px; max-width: 98%; margin: 10vh auto 0 auto;&#125;.aos-item &#123; display: inline-block; float: left; width: 33.3333%; height: 300px; padding: 20px;&#125;.aos-item__inner &#123; position: relative; width: 100%; height: 100%; background: #1da4e2; line-height: 260px; text-align: center; color: #fff;&#125;@media screen and (max-width: 800px) &#123; .aos-item &#123; width: 50%; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;AOS的简单示例&lt;/title&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;link type="text/css" rel="stylesheet" href="aos/aos.css" /&gt; &lt;link type="text/css" rel="stylesheet" href="aos_test.css" /&gt;&lt;/head&gt;&lt;body onload="initLoad();"&gt; &lt;div id="transcroller" class="aos-all"&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;1&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;2&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="zoom-out-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;3&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="flip-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;4&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="flip-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;5&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;6&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;7&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;8&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;9&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;10&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;11&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;12&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;13&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;14&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;15&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;16&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;17&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;18&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="zoom-out"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;19&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;20&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="zoom-out"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;21&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;22&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="zoom-out-up"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;23&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="zoom-out-down"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;24&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;25&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;26&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;27&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;28&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;29&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;30&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;31&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;32&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;33&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;34&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;35&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;36&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;37&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;38&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;39&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;40&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;41&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="aos-item" data-aos="fade-in"&gt; &lt;div class="aos-item__inner"&gt;&lt;h3&gt;42&lt;/h3&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="aos/aos.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function initLoad() &#123; AOS.init(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 异步示例12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;AOS 异步使用的示例&lt;/title&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;link type="text/css" rel="stylesheet" href="aos.css" /&gt; &lt;link type="text/css" rel="stylesheet" href="aos_test.css" /&gt;&lt;/head&gt;&lt;body onload="initLoad();"&gt; &lt;div id="aos_async" class="aos-all"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="aos.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function initLoad() &#123; AOS.init(); &#125; // 0.5秒执行一次 setInterval(addItem, 500); var itemsCounter = 1; var container = document.getElementById('aos_async'); /** * 动态生成的div元素 */ function addItem () &#123; if (itemsCounter &gt; 42) return; var item = document.createElement('div'); item.classList.add('aos-item'); item.setAttribute('data-aos', 'fade-up'); item.innerHTML = '&lt;div class="aos-item__inner"&gt;&lt;h3&gt;' + itemsCounter + '&lt;/h3&gt;&lt;/div&gt;'; container.appendChild(item); itemsCounter++; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、动画样式以下是AOS已经提供了的多种动画： 1. Fade animations fade-up fade-down fade-left fade-right fade-up-right fade-up-left fade-down-right fade-down-left 2. Flip animations flip-up flip-down flip-left flip-right 3. Slide animations slide-up slide-down slide-left slide-right 4. Zoom animations zoom-in zoom-in-up zoom-in-down zoom-in-left zoom-in-right zoom-out zoom-out-up zoom-out-down zoom-out-left zoom-out-right 5. Anchor placement top-bottom top-center top-top center-bottom center-center center-top bottom-bottom bottom-center bottom-top 五、Easing 函数你可以选择以下任意一个时间函数来做出很好的做动画元素： linear ease ease-in ease-out ease-in-out ease-in-back ease-out-back ease-in-out-back ease-in-sine ease-out-sine ease-in-out-sine ease-in-quad ease-out-quad ease-in-out-quad ease-in-cubic ease-out-cubic ease-in-out-cubic ease-in-quart ease-out-quart ease-in-out-quart]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全功能JavaScript灯箱画廊插件lightgallery.js]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2F%E5%85%A8%E5%8A%9F%E8%83%BDJavaScript%E7%81%AF%E7%AE%B1%E7%94%BB%E5%BB%8A%E6%8F%92%E4%BB%B6lightgallery.js%2F</url>
    <content type="text"><![CDATA[一、简介 lightgallery.js 是一个全功能、轻量级、无依赖的灯箱画廊显示库。 二、主要特性 全响应式兼容 模块化的架构和内置插件 移动设备和触摸支持 桌面设备拖拽支持 双击查看图像的实际大小 动画缩略图 社交媒体分享 YouTube，Vimeo，DailyMotion，VK和 HTML5 视频支持 20+ 硬件加速CSS3过渡 全屏支持 支持缩放 浏览器历史记录 响应式图像 HTML iframe 支持 支持iFrame框架 单页多实例 可能过CSS(SCSS)定制样式 智能图像预加载与代码优化 桌面键盘导航 字体图标支持 还有更多 三、浏览器支持lightgallery 支持所有主要的浏览器包括IE 9及以上。 四、安装下载1. Bower 安装你可以使用 Bower 包管理工具安装lightgallery： 1bower install lightgallery.js --save 2. npm你也能在 npm 上找到 lightgallery： 1npm install lightgallery.js 3. Github 下载你也可以直接从 GitHub 下载lightgallery 五、基础示例1. 使用方法首先，在 html 头文件&lt;head&gt;中引入lightgallery.css： 123&lt;head&gt; &lt;link rel="stylesheet" href="css/lightgallery.css"&gt;&lt;/head&gt; 然后，在&lt;body&gt;标签结尾引入lightgallery.min.js，如果你想引入其他 lightgallery 的功能插件，你可以将这些插件引入到lightgallery.min.js之后，如下： 123456789&lt;body&gt; ... &lt;script src="js/lightgallery.min.js"&gt;&lt;/script&gt; &lt;!-- lightgallery plugins --&gt; &lt;script src="js/lg-thumbnail.min.js"&gt;&lt;/script&gt; &lt;script src="js/lg-fullscreen.min.js"&gt;&lt;/script&gt;&lt;/body&gt; 以下是页面标记的图片示例： 123456789&lt;div id="lightgallery"&gt; &lt;a href="img/img1.jpg"&gt; &lt;img src="img/thumb1.jpg"&gt; &lt;/a&gt; &lt;a href="img/img2.jpg"&gt; &lt;img src="img/thumb2.jpg"&gt; &lt;/a&gt; ...&lt;/div&gt; 最后，是 JavaScript 调用插件的方式： 123&lt;script&gt; lightGallery(document.getElementById('lightgallery'));&lt;/script&gt; 2. 完整示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;lightgallery.js的使用示例&lt;/title&gt; &lt;link type="text/css" rel="stylesheet" href="/lightGallery/css/lightgallery.min.css" /&gt; &lt;style type="text/css" rel="stylesheet"&gt; ul &#123; float: left; list-style-type: none; &#125; ul li &#123; float: left; display: inline-block; margin: 5px; &#125; .lgallery &#123; width: 213px; height: 137px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onload="initLoad();"&gt; &lt;ul id="lightGallery"&gt; &lt;li data-src="/assets/images/a.jpg"&gt; &lt;img class="lgallery" src="/assets/images/a.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/b.jpg"&gt; &lt;img class="lgallery" src="/assets/images/b.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/c.jpg"&gt; &lt;img class="lgallery" src="/assets/images/c.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/d.jpg"&gt; &lt;img class="lgallery" src="/assets/images/d.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/e.jpg"&gt; &lt;img class="lgallery" src="/assets/images/e.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/f.jpg"&gt; &lt;img class="lgallery" src="/assets/images/f.jpg"&gt; &lt;/li&gt; &lt;li data-src="/assets/images/g.jpg"&gt; &lt;img class="lgallery" src="/assets/images/g.jpg"&gt; &lt;/li&gt; &lt;/ul&gt;&lt;script type="text/javascript" src="/lightGallery/js/lightgallery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-fullscreen.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-thumbnail.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-autoplay.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-hash.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-pager.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-share.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lightGallery/js/plugins/lg-zoom.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;function initLoad() &#123; var lg = document.getElementById('lightGallery'); lightGallery(lg, &#123; mode: 'lg-slide', cssEasing: 'ease', speed: 500 &#125;);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、学习和参考资源 API Reference Events Methods Data Attributes Dynamic variables Sass variables Module API]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Java编程风格指南]]></title>
    <url>%2F2018%2F10%2F05%2F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93%2FGoogle%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1 前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。 1.1 术语说明本文档中除非特殊说明，否则： 术语class可表示一个普通类、枚举类、接口或者注解。 术语comment只用来指代实现的注释(implementation comments)，我们不使用文档注释(documentation comments)一词，而是用Javadoc。 其他术语说明，将在文档中需要说明的地方单独说明。 1.2 指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。 2 源文件基础2.1 文件名源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为.java。 2.2 文件编码：UTF-8源文件编码格式使用UTF-8。 2.3 特殊字符2.3.1 空格字符除了换行符外，ASCII水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着： 所有其他空白字符将被转义。 Tab字符不被用作缩进控制。 2.3.2 特殊转义字符串任何需要转义字符串表示的字符（例如：\b, \t, \n, \f, \r, \&#39;, \\等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 \012）或Unicode码（例如：\u000a）表示。 2.3.3 非ASCII字符对于其余非ASCII字符，直接使用Unicode字符（例如 ∞），或者使用对应的Unicode码（例如：\u221e）转义，都是允许的。唯一需要考虑的是，何种方式更能使代码容易阅读和理解。 注意：在使用Unicode码转义，或者甚至是有时直接使用Unicode字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。 例子： 示例 结论 String unitAbbrev = “μs”; 赞：即使没有注释也非常清晰。 String unitAbbrev = “\u03bcs”; // “μs” 允许，但没有理由要这样做。 String unitAbbrev = “\u03bcs”; // Greek letter mu, “s” 允许，但这样做显得笨拙还容易出错。 String unitAbbrev = “\u03bcs”; 很糟：读者根本看不出这是什么。 return ‘\ufeff’ + content; // byte order mark 很好：对于非打印字符，使用转义，并在必要时写上注释。 注意：永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 3 源文件结构源文件按照先后顺序，由以下几部分组成： 许可证(License)或版权信息(copyright)（如果需要） package语句 import语句 class类声明（每个源码文件只能有唯一一个顶级class）。 注意：以上每个部分之间应该只有一个空行作为间隔。 3.1 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 3.2 package语句package语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里) 3.3 import语句3.3.1 import不使用通配符import语句中不应该使用通配符，不管是否是静态导入。 3.3.2 import不换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 3.3.3 顺序和间距import语句可分为以下几组，按照顺序，每组由一个空行分隔： 所有的静态导入(static import)归为一组 com.google包的import归为一组 使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：android, com, junit, org, sun java包归为一组 javax包归为一组 注意：同一组内的import语句之间不应用空行隔开，同一组中的import语句按字典序排列。 3.4 类声明3.4.1 只声明唯一一个顶级class每个源文件中只能有一个顶级class。 3.4.2 类成员顺序类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 3.4.2.1 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。 4 格式 术语说明：块状结构(block-­like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 4.1 大括号4.1.1 使用大括号(即使是可选的)大括号一般用在if, else, for, do, while等语句，即使只有一条语句(或是空)，也应该把大括号写上。 4.1.2 非空语句块采用K&amp;R风格对于非空语句块，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号结束是一个语句块或者方法体、构造函数体或者有命名的类体，则需要换行。当右括号后面接else或者逗号时，不应该换行。 示例： 123456789101112131415161718192021return () -&gt; &#123; while (condition()) &#123; method(); &#125;&#125;;return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; else if (otherCondition()) &#123; somethingElse(); &#125; else &#123; lastThing(); &#125; &#125;&#125;; 一些例外的情况，将在4.8.1节讲枚举类型的时候讲到。 4.1.3 空语句块：使代码更简洁一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：if/else 或者try/catch/finally）. 示例： 123456// 这是可接受的void doNothing() &#123;&#125;// 这同样是可接受的void doNothingElse() &#123;&#125; 1234// 这是不可接受的：多块语句中没有简洁的空语句块try &#123; doSomething();&#125; catch (Exception e) &#123;&#125; 4.2块缩进：2个空格每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。 注意：根据实际的编程经验，2个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码臃肿不够美观。所以，我这里建议使用4个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。 4.3 一行一个语句每条语句结束都需要换行。 4.4 列长度限制：100Java代码的列长度限制为100个字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。 例外： 不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考) package和import语句(见3.2节和3.3节) 注释中那些可能被剪切并粘贴到shell中的命令行 注意：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，100个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用120个字符的宽度更为合适。 4.5 换行术语说明：一般情况下，一行长代码为了避免超出列限制(100个字符)而被分为多行，我们称之为断行(line­-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。 注意: 提取方法或局部变量可以解决问题，而不不需要进行断行。 4.5.1 在何处断行断行的主要原则是：选择在更高级的语法逻辑处断行。其他一些原则如下： 当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。 如果要在非赋值运算符处断行，那么在该符号前断开(比如+操作符，它将位于下一行)。以下的类运算符也可作为参考： 点操作符. 类型界限中的&amp;、||等（例如：&lt;T extends Foo &amp; Bar&gt;) 当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：=，它与前面的内容留在同一行)。 这条规则也适用于foreach语句中的冒号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。也就是在逗号之后断行。 Lambda表达式在箭头符号(-&gt;)后断行。 示例： 1234567MyLambda&lt;String, Long, Object&gt; lambda = (String label, Long value, Object obj) -&gt; &#123; ... &#125;;Predicate&lt;String&gt; predicate = str -&gt; longExpressionInvolving(str); 注意：换行的主要目标是使代码更清晰易读。 4.5.2 断行的缩进：至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。 当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 4.6 空白4.6.1 垂直空白以下情况需要使用单行空行： 类成员之间需要单个空行隔开：例如：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。但也有以下两种例外情况： 两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。 枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。 在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。 类的第一个成员之前或最后一个成员之后，使用空行(可选)。 本文档所介绍的其他章节的空行要求(比如3.3节：import语句)。 4.6.2 水平空白除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现： 所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：if, for catch等) 所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：else、catch） 在左大括号之前都需要空格隔开。只有两种例外： @SomeAnnotation({a, b}) String[][] x = foo; 所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：a + b、b = a &lt; 0 ? 0 : a) 逗号(,)、冒号(:)、分号(;)和右小括号())、Lambda箭头符号(-&gt;)之后，需要空格隔开。 //双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：a = 0; // 赋值为0） 变量声明时，变量类型和变量名之间需要用空格隔开。（例如：List&lt;String&gt; list） 初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：new int[] {5, 6}和new int[] { 5, 6 }） 注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 4.6.3 水平对齐：不做要求 术语说明：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。 这种对齐是被允许的，但是不会做强制要求。 以下是没有水平对齐和水平对齐的例子： 12345private int x; // 这种挺好private Color color; // 同上private int x; // 允许，但是未来会继续编辑private Color color; // 可能会使它对不齐 注意：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为爆炸半径。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码review的速度，引起更多merge代码冲突的情况。 4.7 分组小括号：推荐使用除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。 4.8 特殊结构4.8.1 枚举类型枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例： 12345678910private enum Answer &#123; YES &#123; @Override public String toString() &#123; return "yes"; &#125; &#125;, NO, MAYBE&#125; 没有方法和Javadoc的枚举类可写成数组初始化的格式： 1private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125; 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 4.8.2 变量声明4.8.2.1 每次声明一个变量不要使用组合声明。例如：int a, b;是不允许的。 4.8.2.2 需要时才声明，尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 4.8.3 数组4.8.3.1 数组初始化：可写成块状结构数组初始化可以写成块状结构，例如以下格式的写法都是允许的： 123456789new int[] &#123; new int[] &#123; 0, 1, 2, 3 0,&#125; 1, 2,new int[] &#123; 3, 0, 1, &#125; 2, 3&#125; new int[] &#123;0, 1, 2, 3&#125; 4.8.3.2 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 4.8.4 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 4.8.4.1 缩进和其他语句块一样，switch大括号之后缩进两个字符。每个switch标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。 4.8.4.2 继续向下执行的注释在一个switch块内，每个语句组要么通过break、continue、return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。例如： 1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; 注意：在case 1之后不需要该注释，仅在语句组的末尾。 4.8.4.3 default标签需要显式声明每个switch语句中，都需要显式声明default标签。即使没有任何代码也需要显示声明。 注意：枚举类型的switch语句可以省略default语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。 4.8.5 注解注解应用到类、方法或者构造方法时，应紧接Javadoc之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如： 123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125; 例外：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如： 1@Override public int hashCode() &#123; ... &#125; 注解应用到成员变量时，也是紧接Javadoc之后。不同的是，多个注解可以放在同一行。例如： 1@Partial @Mock DataLoader loader; 对于参数或者局部变量使用注解的情况，没有特定的规范。 4.8.6 注释4.8.6.1 块注释风格注释的缩进与它所注释的代码缩进相同。可以采用/* */进行注释，也可以用//进行注释。当使用/* */进行多行注释时，每一行都应该以*开始，并且*应该上下对齐。 例如： 12345678910/* * This is * okay. */// And so// is this./* Or you can * even do this. */ 注意：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用/* */，//一般不会自动对齐。 4.8.7 修饰符类和成员变量的修饰符，按Java Lauguage Specification中介绍的先后顺序排序。具体是： 1public protected private abstract default static final transient volatile synchronized native strictfp 4.8.8 数字字面量长整型的数字字面量使用大写的L作为后缀，不得使用小写（以免与数字1混淆）。例如：使用3000000000L，而不是3000000000l。 5 命名约定5.1 对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 5.2 标识符类型的规则5.2.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用com.example.deepspace，而不是com.example.deepSpace或者com.example.deep_space。 5.2.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语。例如：Character或者ImmutableList。接口名称也可以是名词或名词短语（例如：List），但有时可能是形容词或形容词短语（例如：Readable）。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 5.2.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。例如：sendMessage或者stop。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如：testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 5.2.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？ 每个常量都是一个静态final字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如： 1234567891011121314151617// 常量static final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");static final ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of("Ed", 35, "Ann", 32);static final Joiner COMMA_JOINER = Joiner.on(','); // 因为Joiner是不可变的static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// 非常量static String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final ImmutableMap&lt;String, SomeMutableType&gt; mutableValues = ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 这些常量的名字通常是名词或名词短语。 5.2.5 非常量字段名非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。例如：computedValues或者index。 5.2.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 5.2.7 局部变量名局部变量名以lowerCamelCase风格编写。 即使局部变量是final和不可改变的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。 5.2.8 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以视具体情况跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 5.3 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：IPv6或iOS)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：Müller’s algorithm将变成Muellers algorithm。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如AdWords将分割成ad words)。 需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 最后将所有的单词连接起来得到一个标识符。 示例： 散文形式 正确 不正确 “XML HTTP request” XmlHttpRequest XMLHTTPRequest “new customer ID” newCustomerId newCustomerID “inner stopwatch” innerStopwatch innerStopWatch “supports IPv6 on iOS?” supportsIpv6OnIos supportsIPv6OnIOS “YouTube importer” YouTubeImporter YoutubeImporter^ 无 加^号处表示可以，但不推荐。 注意：在英语中，某些带有连字符的单词形式不唯一。例如：nonempty和non-empty都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 6 编程实践6.1 @Override：总是使用只要是合法的方法，就把@Override注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。 例外：当父方法为@Deprecated时，可以省略@Override。 6.2 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123; // 它不是一个数字，不过没关系，继续&#125;return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 6.3 静态成员：使用类来调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // 好aFoo.aStaticMethod(); // 糟somethingThatYieldsAFoo().aStaticMethod(); // 很糟 6.4 Finalizers: 禁用 极少会去重载Object.finalize。 注意：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java第7条款：“Avoid Finalizers”，然后不要使用它。 7 Javadoc7.1 格式7.1.1 一般形式Javadoc块的基本格式如下所示： 12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125; 或者是以下单行形式： 1/** An especially short bit of Javadoc. */ 基本格式总是可以接受的。当整个Javadoc块能容纳于一行时(且没有标记@XXX)，就可以使用单行形式。 7.1.2 段落空行(只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格(注：如果你的缩进统一采用采用4个空格，那么这里就应该是8个空格)。 7.2 摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或者This method returns...开头, 它也不会是一个完整的祈使句，如Save the record.。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 注意：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。 7.3 在哪里使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 7.3.1 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(可以不写)。这种情况下除了写Returns the foo，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 注意：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName，就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 7.3.2 例外：重载如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 7.3.3 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。 原文地址: Google Java Style Guide]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Java调用PhantomJS动态导出ECharts图片到Word文件中]]></title>
    <url>%2F2018%2F10%2F01%2F%E5%90%8E%E7%AB%AF%2FJava%2F%E4%BD%BF%E7%94%A8Java%E8%B0%83%E7%94%A8PhantomJS%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BAECharts%E5%9B%BE%E7%89%87%E5%88%B0Word%E6%96%87%E4%BB%B6%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[前言最近在一个项目中遇到导出为Word文件的问题，导出Word的功能很简单，但是导出Word文件中包含数据库动态查询的统计数据而生成的Echarts图片，且导出Word的时机又是在凌晨的服务器定时执行，所以不能通过客户端访问统计页面时再去生成。 服务端语言使用Java语言，最开始考虑使用JFreeChart来生成统计图片，但是JFreeChart生成的图片很丑，且和ECharts的统计图效果截然不同。所以最终抛弃了使用JFreeChart，而采用了在服务端使用Java调用PhantomJS的指令来导出Ehcarts图片。所以主要的技术方案选型如下： poi-tl，一个简单的基于Word模版生成Word的工具。 PhantomJS，一个基于webkit内核的无头浏览器，可在服务端程序实现加载、操作页面等功能 使用poi-tl导出Wordpoi-tl介绍使用Java导出Word通常采用的是Apache POI的库，但是使用POI来导出Word，会书写大量的段落、样式等细节代码，代码量巨大，而且不易于维护。通过poi-tl只需要制作导出的模版，服务端一行代码调用，传入模版路径和Map或者Bean即可生成Word模版，代码量大大降低，以后导出样式不满意的时候，只需要修改Word模版文件即可。 注意：poi-tl只能生成docx文件，对word2007之前的doc文档则不支持。 Maven引入12345&lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 注：该包带入了POI3.16，如果系统中本身有低于3.15版本的POI，需要排除掉，否则生成Word时会报错。 demo示例首先，制作一个用于测试的word模版，使用poi-tl的标记语法做如下标记，如下图所示： 然后，构造一个需要渲染的model JavaBean类，如果有多个Bean，貌似只能通过继承来复用属性，采用组合的方式是渲染不了的，代码如下： 12345678910111213141516171819202122232425/** * BaseProp * @author blinkfox on 2017-06-28. */public class BaseProp &#123; protected String baseProp; /** * 构造方法. * @param baseProp 基础属性 */ public BaseProp() &#123; super(); &#125; public String getBaseProp() &#123; return baseProp; &#125; public void setBaseProp(String baseProp) &#123; this.baseProp = baseProp; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 测试旅游信息的bean. * @author blinkfox on 2017-06-28. */public class Travel extends BaseProp &#123; private String title; private String smallTitle; private String startDate; private String endDate; private int count; private double money; private String place1; private String place2; private PictureRenderData pic; /** * 构造方法. */ public Travel() &#123; super(); &#125; /*getter和setter方法.*/ public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getSmallTitle() &#123; return smallTitle; &#125; public void setSmallTitle(String smallTitle) &#123; this.smallTitle = smallTitle; &#125; public String getStartDate() &#123; return startDate; &#125; public void setStartDate(String startDate) &#123; this.startDate = startDate; &#125; public String getEndDate() &#123; return endDate; &#125; public void setEndDate(String endDate) &#123; this.endDate = endDate; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; public String getPlace1() &#123; return place1; &#125; public void setPlace1(String place1) &#123; this.place1 = place1; &#125; public String getPlace2() &#123; return place2; &#125; public void setPlace2(String place2) &#123; this.place2 = place2; &#125; public PictureRenderData getPic() &#123; return pic; &#125; public void setPic(PictureRenderData pic) &#123; this.pic = pic; &#125;&#125; 最后，是模拟调用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * poi-tl库的使用示例. * Created by blinkfox on 2017/6/27. */public class PoitlTest &#123; private static final Logger log = LoggerFactory.getLogger(PoitlTest.class); /** 项目资源路径. */ private static final String PATH = "F:/poitl-test/web"; /** word模板路径. */ private static final String DOC_PATH = PATH + "/template/test/test.docx"; /** 图片路径. */ private static final String PIC_PATH = PATH + "/template/test/pic.png"; /** 输出文件及路径. */ private static final String OUTPUT_PATH = "G:/test/poitl_out_word.docx"; /** * 构造Bean型的data数据. * @return map */ private static Travel buildBeanData() &#123; Travel travel = new Travel(); travel.setTitle("我的旅游日记"); travel.setSmallTitle("再写日记"); travel.setStartDate("2017-01-01"); travel.setEndDate("2017-06-28"); travel.setCount(3); travel.setPlace1("九寨沟"); travel.setPlace2("天涯海角"); travel.setMoney(1872.52); travel.setPic(new PictureRenderData(600, 400, PIC_PATH)); travel.setBaseProp("这是"); return travel; &#125; /** * main方法. * @param args 数组参数 */ public static void main(String[] args) throws IOException &#123; XWPFTemplate template = XWPFTemplate.compile(DOC_PATH).render(buildBeanData()); FileOutputStream out = new FileOutputStream(OUTPUT_PATH); template.write(out); out.flush(); out.close(); template.close(); log.info("通过'poi-tl'导出word成功!"); &#125;&#125; 最后，在导出的文件夹中可查看生成的word文件，如下所示： Java调用PhantomJS导出Ehcarts图片PhantomJS介绍PhantomJS是一个基于webkit内核的无头浏览器，即没有UI界面的一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。PhantomJS提供JavaScript API接口，即通过编写js程序可以直接与webkit内核交互，在此之上可以结合Java语言等，通过java调用js等相关操作，从而解决了以前c/c++才能比较好的基于webkit开发优质采集器的限制。 PhantomJS的安装配置windows环境如果是在windows环境下，则在官网下载解压到某个目录后，将其bin目录加入到path变量中即可。 Linux环境如果是在Linux环境下，在官网下载解压后，同样需要将PhantomJS的bin目录加入到path环境变量中，参考的命令和配置如下： 123456789101112# 编辑配置文件.vi ~/.bashrc# 将PhantomJS的bin目录加入到PATH环境变量中.export PHANTOMJS_HOME=/home/blinkfox/Documents/phantomjs-2.1.1-linux-x86_64export PATH=$&#123;PHANTOMJS_HOME&#125;/bin:$PATH# 退出vi编辑器，使用source命令让刚才的配置即时生效.source ~/.bashrc# 测试PhantomJS是否安装成功，如果打出了版本信息，即安装成功.phantomjs -v demo示例这个demo的需求是这样的，我们使用Java调用PhantomJS的指令来在服务端加载含ECharts统计的图html文件，然后调用ECharts的生成图片方法，将图片传输到Java后台最终实现保存图片到指定路径中。 首先，制作ECharts的html页面，示例页面如下代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试的ECharts数据统计图&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main" style="width:560px; height:270px;"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/js/lib/jquery/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/lib/echarts/v3/echarts.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById('main'));// 指定图表的配置项和数据var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, animation: false, // 关闭动画效果 tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;]&#125;;// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);/** * ajax传输图片信息. */function postImage() &#123; // 向后台发起请求保存图片到指定目录. $.ajax(&#123; type: 'POST', url: '/test/saveImage', data: &#123;picInfo: myChart.getDataURL()&#125;, success: function() &#123; console.log('通过post请求传输数据成功!'); &#125; &#125;);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后，使用Servlet来写一个服务端代码，用来获取Base64的图片信息并在后端解析保存图片，Servlet代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 保存Echarts统计图片的Servlet. * @author blinkfox on 2017-06-28. */public class SaveImageServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static final Logger log = LoggerFactory.getLogger(SaveImageServlet.class); /** * 执行获取echarts图片的post请求. * @param request req * @param response resp * @throws ServletException Servlet异常. * @throws IOException IO异常. */ @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取图片信息. String picInfo = request.getParameter("picInfo"); if (StringUtils.isBlank(picInfo)) &#123; log.error("picInfo为空,未从前台获取到base64图片信息!"); return; &#125; this.getAndsaveImage(picInfo, "G:/test/image1.png"); &#125; /** * 获取并保存图片到本地. * @param picInfo 图片信息 * @param imagePath 图片保存的路径 */ private void getAndsaveImage(String picInfo, String imagePath) &#123; // 传递过程中 "+" 变为了 " ". String newPicInfo = picInfo.replaceAll(" ", "+"); String picPath = decodeBase64(newPicInfo, new File(imagePath)); log.warn("从echarts中生成图片的的路径为:&#123;&#125;", picPath); &#125; /** * 解析Base64位信息并输出到某个目录下面. * @param base64Info base64串 * @param picPath 生成的文件路径 * @return 文件地址 */ private String decodeBase64(String base64Info, File picPath) &#123; if (StringUtils.isEmpty(base64Info)) &#123; return null; &#125; // 数据中：data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABI4AAAEsCAYAAAClh/jbAAA ... 在"base64,"之后的才是图片信息 String[] arr = base64Info.split("base64,"); // 将图片输出到系统某目录. OutputStream out = null; try &#123; // 使用了Apache commons codec的包来解析Base64 byte[] buffer = Base64.decodeBase64(arr[1]); out = new FileOutputStream(picPath); out.write(buffer); &#125; catch (IOException e) &#123; log.error("解析Base64图片信息并保存到某目录下出错!", e); &#125; finally &#123; IOUtils.closeQuietly(out); &#125; return picPath; &#125;&#125; 然后，是书写PhantomJS脚本echarts_load.js来加载和调用图片下载的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041var system = require('system');var page = require('webpage').create();// 如果是windows,设置编码为gbk，防止中文乱码,Linux本身是UTF-8var osName = system.os.name;console.log('os name:' + osName);if ('windows' === osName.toLowerCase()) &#123; phantom.outputEncoding="gbk";&#125;// 获取第二个参数(即请求地址url).var url = system.args[1];console.log('url:' + url);// 显示控制台日志.page.onConsoleMessage = function(msg, lineNum, sourceId) &#123; console.log('CONSOLE: ' + msg + ' (from line #' + lineNum + ' in "' + sourceId + '")');&#125;;//打开给定url的页面.var start = new Date().getTime();page.open(url, function(status) &#123; if (status == 'success') &#123; console.log('echarts页面加载完成,加载耗时:' + (new Date().getTime() - start) + ' ms'); // 由于echarts动画效果，延迟500毫秒确保图片渲染完毕再调用下载图片方法. setTimeout(function() &#123; page.evaluate(function() &#123; postImage(); console.log("调用了echarts的下载图片功能."); &#125;); &#125;, 500); &#125; else &#123; console.log("页面加载失败 Page failed to load!"); &#125; // 3秒后再关闭浏览器. setTimeout(function() &#123; phantom.exit(); &#125;, 3000);&#125;); 最后，是使用Java来调用PhantomJS的指令，代码如下： 123456789101112131415161718192021222324252627282930313233343536/** * HttpTest. * @author blinkfox on 2017-06-28. * @version 1.0 */public class HttpTest &#123; private static final Logger log = LoggerFactory.getLogger(HttpTest.class); private static final String PHANTOM_PATH = "phantomjs"; //这里我的test.js是保存在G盘下面的phantomjs目录 private static final String TEST_JS = "G:/test/phantom/test.js "; public void String downloadImage(String url) throws IOException &#123; String cmdStr = PHANTOM_PATH + TEST_JS + url; log.info("命令行字符串:&#123;&#125;", cmdStr); Runtime rt = Runtime.getRuntime(); try &#123; rt.exec(cmdStr); &#125; catch (IOException e) &#123; log.error("执行phantomjs的指令失败！请检查是否安装有PhantomJs的环境或配置path路径！PhantomJs详情参考这里:http://phantomjs.org", e); &#125; &#125; /** * main. * @param args args * @throws IOException IO异常 */ public static void main(String[] args) throws IOException &#123; downloadImage("http://127.0.0.1:8080/test/echart_test/test_echarts.html"); &#125;&#125; 通过调用测试代码即可在指定目录生成Echarts的图片啦！ 联系上面生成Word的功能，两个功能一结合即可动态导出ECharts图片到Word文件中。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons Lang之日期时间工具类]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%90%8E%E7%AB%AF%2FJava%2Fcommons%2FApache%20Commons%20Lang%E4%B9%8B%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[码农不识Apache，码尽一生也枉然。 FastDateFormatFastDateFormat是一个快速且线程安全的时间操作类，它完全可以替代SimpleDateFromat。因为是线程安全的，所以你可以把它作为一个类的静态字段使用。构造方法为protected，不允许直接构造它的对象，可以通过工厂方法获取。FastDateFormat之所以是线程安全的，是因为这个类是无状态的：内部的成员在构造时就完成了初始化，并在对象存活期，不提供任何API供外界修改他们。 getInstance(String pattern)获取指定日期时间格式的FastDateFormat实例。 format(Date date)将日期时间格式化为字符串。 1FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss").format(new Date()); // 2017-06-03 23:32:31 format(long millis)同format(Date date)相似。 format(Calendar calendar)同format(Date date)相似。 DateFormatUtils将时间转化为字符串的工具类。不可实例化对象且线程安全，依赖于FastDateFormat。 预定义的日期格式DateFormatUtils预定义的日期格式有如下几种： 123456public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss");public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ssZZ");public static final FastDateFormat ISO_8601_EXTENDED_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd");public static final FastDateFormat ISO_8601_EXTENDED_TIME_FORMAT = FastDateFormat.getInstance("HH:mm:ss");public static final FastDateFormat ISO_8601_EXTENDED_TIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("HH:mm:ssZZ");public static final FastDateFormat SMTP_DATETIME_FORMAT = FastDateFormat.getInstance("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US); format(Date date, String pattern)将日期格式化为字符串。 123DateFormatUtils.format(new Date(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:03:53DateFormatUtils.ISO_8601_EXTENDED_DATETIME_FORMAT.format(new Date()); // 2017-06-03T23:09:52DateFormatUtils.format(System.currentTimeMillis(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:16:59 format(long millis, String pattern)同format(Date date, String pattern)相似。 format(Calendar calendar, String pattern)同format(Date date, String pattern)相似。 DateUtilsDateUtils提供了很多很方便的功能，减轻了使用Date的复杂性。把原来需用Calendar才能完成的功能统一集中了起来，也就是说没有对应的CalendarUtils类。在JDK中，Date与Calendar概念本身就有些混淆，只是为了保持兼容性才引入的Calendar。相对于Calendar提供的方法，DateUtils提供了更加合理的方法，对时间的单个字段操作变得更加的容易。 常量1234public static final long MILLIS_PER_SECOND = 1000; // 1秒钟的毫秒数public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; // 1分钟的毫秒数public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; // 1小时的毫秒数public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; // 1天的毫秒数 boolean isSameDay(Date date1, Date date2)判断两个日期是否是同一天。 1DateUtils.isSameDay(new Date(), new Date()); // true boolean isSameDay(Calendar cal1, Calendar cal2)同isSameDay(Date date1, Date date2)相似。 Date parseDate(String str, String… parsePatterns)解析日期时间字符串日期时间Date对象，通过尝试各种不同的解析器来解析表示日期的字符串。 12DateUtils.parseDate("2017-06-03 23:51:44", "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:51:44DateUtils.parseDate("2017年06月03日 23时51分44秒", "yyyy-MM-dd HH:mm:ss", "yyyy年MM月dd日 HH时mm分ss秒"); Date addYears(Date date, int amount)得到date日期时间后（前）amount年后的日期时间。 12Date d3 = DateUtils.addYears(new Date(), 3); // 2020-06-04 00:06:21Date d3 = DateUtils.addYears(new Date(), -2); // 2015-06-04 00:06:21 Date addMonths(Date date, int amount)同addYears(Date date, int amount)相似，对月份数进行加减。 Date addWeeks(Date date, int amount)同addYears(Date date, int amount)相似，对周数进行加减。 Date addDays(Date date, int amount)同addYears(Date date, int amount)相似，对天数进行加减。 Date addHours(Date date, int amount)同addYears(Date date, int amount)相似，对小时数进行加减。 Date addMinutes(Date date, int amount)同addYears(Date date, int amount)相似，对分钟数进行加减。 Date addSeconds(Date date, int amount)同addYears(Date date, int amount)相似，对秒数进行加减。 Date addMilliseconds(Date date, int amount)同addYears(Date date, int amount)相似，对毫秒数进行加减。 Date setYears(Date date, int amount)对给定的日期时间设置年份。 1Date d4 = DateUtils.setYears(new Date(), 2028); // 2028-06-04 00:16:48 Date setMonths(Date date, int amount)同setYears(Date date, int amount)相似，对月数进行设置。 Date setDays(Date date, int amount)同setYears(Date date, int amount)相似，对天数进行设置。 Date setHours(Date date, int amount)同setYears(Date date, int amount)相似，对小时数进行设置。 Date setMinutes(Date date, int amount)同setYears(Date date, int amount)相似，对分钟数进行设置。 Date setSeconds(Date date, int amount)同setYears(Date date, int amount)相似，对秒钟数进行设置。 Date setMilliseconds(Date date, int amount)同setYears(Date date, int amount)相似，对毫秒数进行设置。 toCalendar(Date date)将日期转为Calendar实例。 Date round(Date date, int field)对日期时间进行四舍五入。filed指定取整的字段，可以取的值为 Calendar.SECOND Calendar.MINUTE Calendar.HOUR_OF_DAY Calendar.DAY_OF_MONTH Calendar.MONTH Calendar.YEAR… 12345678// 当前时间为'2017-06-04 00:44:41'，则执行以下代码DateUtils.round(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00DateUtils.round(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00DateUtils.round(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 01:00:00DateUtils.round(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00DateUtils.round(new Date(), Calendar.HOUR); // 2017-06-04 01:00:00DateUtils.round(new Date(), Calendar.MINUTE); // 2017-06-04 00:45:00DateUtils.round(new Date(), Calendar.SECOND); // 2017-06-04 00:44:43 Date truncate(Date date, int field)从给定字段开始格式化截取日期。对一个时间对象的某个字段进行截断。 12345678// 当前时间为'2017-06-04 00:56:05'，则执行以下代码DateUtils.truncate(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00DateUtils.truncate(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00DateUtils.truncate(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.HOUR); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.MINUTE); // 2017-06-04 00:56:00DateUtils.truncate(new Date(), Calendar.SECOND); // 2017-06-04 00:56:05 Date ceiling(Date date, int field)从给定字段开始“向上”格式化日期。 12345678// 当前时间为'2017-06-04 01:02:31'，则执行以下代码DateUtils.ceiling(new Date(), Calendar.YEAR); // 2018-01-01 00:00:00DateUtils.ceiling(new Date(), Calendar.MONTH); // 2017-07-01 00:00:00DateUtils.ceiling(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 02:00:00DateUtils.ceiling(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-05 00:00:00DateUtils.ceiling(new Date(), Calendar.HOUR); // 2017-06-04 02:00:00DateUtils.ceiling(new Date(), Calendar.MINUTE); // 2017-06-04 01:03:00DateUtils.ceiling(new Date(), Calendar.SECOND); // 2017-06-04 01:02:32 long getFragmentInDays(Date date, int fragment)返回一个指定时间的天数。关键的是参数fragment，它的作用非常重要。它的值必须是Calendar的时间常量字段。 注意：小时必须用24小时制的，即Calendar.HOUR_OF_DAY，而不能用Calendar.HOUR字段。 123// 当前时间为'2017-06-04 01:12:31'，则执行以下代码DateUtils.getFragmentInDays(new Date(), Calendar.YEAR); // 155DateUtils.getFragmentInDays(new Date(), Calendar.MONTH); // 4 long getFragmentInMilliseconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInSeconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInMinutes(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInHours(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 boolean truncatedEquals(Date date1, Date date2, int field)比较日历对应字段是否相等。 StopWatchStopWatch是一个方便的计时器。 使用示例12345StopWatch stopWatch = new StopWatch();stopWatch.start();...stopWatch.stop();System.out.println(stopWatch.getTime()); 主要方法： start(): 开始计时 stop(): 停止计时 reset(): 重置计时 suspend(): 暂停计时 resume(): 继续计时 getTime(): 获取消耗的毫秒数 getNanoTime(): 获取消耗的纳秒数 getStartTime(): 获取开始的毫秒数 isStarted(): 是否开始 isSuspended(): 是否暂停 isStopped(): 是否停止]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons Lang之ArrayUtils]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%90%8E%E7%AB%AF%2FJava%2Fcommons%2FApache%20commons%20lang%E4%B9%8BArrayUtils%2F</url>
    <content type="text"><![CDATA[码农不识Apache，码尽一生也枉然。 常量数组1234567public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0];public static final String[] EMPTY_STRING_ARRAY = new String[0];public static final long[] EMPTY_LONG_ARRAY = new long[0];public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];public static final int[] EMPTY_INT_ARRAY = new int[0];public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0]; 转换为MaptoMap(Object[] array)将二维数组转换为Map。 12345Map colorMap = ArrayUtils.toMap(new String[][] &#123; &#123;"RED", "#FF0000"&#125;, &#123;"GREEN", "#00FF00"&#125;, &#123;"BLUE", "#0000FF"&#125;&#125;); 生成数组T[] toArray(final T… items)将不定参数转换为数组。 12String[] array = ArrayUtils.toArray("1", "2");String[] emptyArray = ArrayUtils.&lt;String&gt;toArray(); null转空数组Object[] nullToEmpty(Object[] array)将null数组转为对应类型的空数组，如果array不是null，则返回array。 1String[] arr = ArrayUtils.nullToEmpty((String[]) null); 数组操作 T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)截取数组开始索引位置和结束索引位置的数组为子数组 12Object[]s1=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,1); // ["aa"]Object[]s2=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,2); // ["aa", "bb"] reverse(long[] array)反转数组。 1ArrayUtils.reverse(new String[]&#123;"aa","bb"&#125;);//结果是：&#123;"bb"，"aa"&#125; swap(Object[] array, int offset1, int offset2)交换数组中的元素。 12345ArrayUtils.swap(["1", "2", "3"], 0, 2) -&gt; ["3", "2", "1"]ArrayUtils.swap(["1", "2", "3"], 0, 0) -&gt; ["1", "2", "3"]ArrayUtils.swap(["1", "2", "3"], 1, 0) -&gt; ["2", "1", "3"]ArrayUtils.swap(["1", "2", "3"], 0, 5) -&gt; ["1", "2", "3"]ArrayUtils.swap(["1", "2", "3"], -1, 1) -&gt; ["2", "1", "3"] 数组元素查找int indexOf(Object[] array, Object objectToFind)数组元素所在的索引位置,如果没有则返回-1,可指定起始搜索位置。 123ArrayUtils.indexOf(new String[]&#123;"aa","bb","cc"&#125;,"cc"); // 2ArrayUtils.indexOf(new String[]&#123;"aa","bb","bb"&#125;,"bb",2); // 2ArrayUtils.indexOf(newObject[]&#123;"aa","bb","cc"&#125;,"cc",3); // -1 int lastIndexOf(Object[] array, Object objectToFind, int startIndex)同indexOf(Object[] array, Object objectToFind)相反。反向查询某个object在数组中的位置，可以指定起始搜索位置。 contains(Object[] array, Object objectToFind)判断数组中是否包含某个元素。 1ArrayUtils.contains(new String[]&#123;"a", "b", "c"&#125;, "a"); // true 数组判空boolean isEmpty(Object[] array)判断数组是否为空。 1234ArrayUtils.isEmpty(new String[]&#123;"21","是"&#125;); // falseArrayUtils.isEmpty(new String[]&#123;""&#125;); // falseArrayUtils.isEmpty(new String[]&#123;null&#125;); // falseArrayUtils.isEmpty(new String[]&#123;&#125;); // true boolean isNotEmpty(T[] array)同相反。判断数组是否不为空。 合并数组元素 T[] addAll(T[] array1, T… array2)合并多个数组到某一个数组中。 123456ArrayUtils.addAll(null, null) = nullArrayUtils.addAll(array1, null) = cloned copy of array1ArrayUtils.addAll(null, array2) = cloned copy of array2ArrayUtils.addAll([], []) = []ArrayUtils.addAll([null], [null]) = [null, null]ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"] T[] add(T[] array, T element)将单个元素合并到数组中。 12345ArrayUtils.add(null, null) = IllegalArgumentExceptionArrayUtils.add(null, "a") = ["a"]ArrayUtils.add(["a"], null) = ["a", null]ArrayUtils.add(["a"], "b") = ["a", "b"]ArrayUtils.add(["a", "b"], "c") = ["a", "b", "c"] T[] add(T[] array, int index, T element)将单个元素合并到指定索引位置的数组中。 12345ArrayUtils.add(null, 0, null) = IllegalArgumentExceptionArrayUtils.add(null, 0, "a") = ["a"]ArrayUtils.add(["a"], 1, null) = ["a", null]ArrayUtils.add(["a"], 0, "b") = ["b", "a"]ArrayUtils.add(["a", "b"], 1, "c") = ["a", "c", "b"] 移除数组元素 T[] remove(T[] array, int index)移除数组中指定索引位置的元素。 1234ArrayUtils.remove(["a"], 0) = []ArrayUtils.remove(["a", "b"], 0) = ["b"]ArrayUtils.remove(["a", "b"], 1) = ["a"]ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"] T[] removeAll(T[] array, int… indices)同&lt;T&gt; T[] remove(T[] array, int index)相似，移除数组中所有指定索引位置的元素。 12ArrayUtils.removeAll(["a", "b", "c"], 0, 2) = ["b"]ArrayUtils.removeAll(["a", "b", "c"], 1, 2) = ["a"] T[] removeElement(T[] array, Object element)移除数组中的第一个element元素。 12345ArrayUtils.removeElement(null, "a") = nullArrayUtils.removeElement([], "a") = []ArrayUtils.removeElement(["a"], "b") = ["a"]ArrayUtils.removeElement(["a", "b"], "a") = ["b"]ArrayUtils.removeElement(["a", "b", "a"], "a") = ["b", "a"]]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons Lang之StringUtils]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%90%8E%E7%AB%AF%2FJava%2Fcommons%2FApache%20Commons%20Lang%E4%B9%8BStringUtils%2F</url>
    <content type="text"><![CDATA[码农不识Apache，码尽一生也枉然。 判断空字符串isEmpty(CharSequence cs)判断是否是空字符串，代码示例： 12345StringUtils.isEmpty(null) = trueStringUtils.isEmpty("") = trueStringUtils.isEmpty(" ") = falseStringUtils.isEmpty("bob") = falseStringUtils.isEmpty(" bob ") = false isNotEmpty(CharSequence cs)判断是否不是空字符串，与isEmpty(CharSequence cs)相反。 isAnyEmpty(CharSequence… css)判断是否含有空字符串，代码示例： 1234567StringUtils.isAnyEmpty(null) = trueStringUtils.isAnyEmpty(null, "foo") = trueStringUtils.isAnyEmpty("", "bar") = trueStringUtils.isAnyEmpty("bob", "") = trueStringUtils.isAnyEmpty(" bob ", null) = trueStringUtils.isAnyEmpty(" ", "bar") = falseStringUtils.isAnyEmpty("foo", "bar") = false isNoneEmpty(CharSequence… css)判断是否都不是空字符串，与isAnyEmpty(CharSequence... css)相反。 isAllEmpty(CharSequence… css)判断是否都是空字符串，代码示例： 123456789StringUtils.isAllEmpty(null) = trueStringUtils.isAllEmpty(null, "") = trueStringUtils.isAllEmpty(new String[] &#123;&#125;) = trueStringUtils.isAllEmpty(null, "foo") = falseStringUtils.isAllEmpty("", "bar") = falseStringUtils.isAllEmpty("bob", "") = falseStringUtils.isAllEmpty(" bob ", null) = falseStringUtils.isAllEmpty(" ", "bar") = falseStringUtils.isAllEmpty("foo", "bar") = false isBlank(CharSequence cs)判断是否是“大空字符串”，代码示例： 12345StringUtils.isBlank(null) = trueStringUtils.isBlank("") = trueStringUtils.isBlank(" ") = trueStringUtils.isBlank("bob") = falseStringUtils.isBlank(" bob ") = false isNotBlank(CharSequence cs)判断是否不是“大空字符串”，与isBlank(CharSequence cs)相反，与isNotEmpty(CharSequence cs)相似。 isAnyBlank(CharSequence… css)判断是否有“大空字符串”，与isAnyEmpty(CharSequence... css)相似。 isNoneBlank(CharSequence… css)判断是否都不是“大空字符串”，与isAnyBlank(CharSequence... css)相反，与isNoneEmpty(CharSequence... css)相似。 isAllBlank(CharSequence… css)判断是否都是“大空字符串”，与isAllEmpty(CharSequence... css)相似。 截取字符串trim(String str)去除字符串前后的控制符，代码示例： 12345StringUtils.trim(null) = nullStringUtils.trim("") = ""StringUtils.trim(" ") = ""StringUtils.trim("abc") = "abc"StringUtils.trim(" abc ") = "abc" trimToNull(String str)去除字符串前后的控制符，如何是空字符串则转为null，代码示例： 12345StringUtils.trimToNull(null) = nullStringUtils.trimToNull("") = nullStringUtils.trimToNull(" ") = nullStringUtils.trimToNull("abc") = "abc"StringUtils.trimToNull(" abc ") = "abc" trimToEmpty(String str)去除字符串前后的控制符，如何是null则转为空字符串，代码示例： 12345StringUtils.trimToEmpty(null) = ""StringUtils.trimToEmpty("") = ""StringUtils.trimToEmpty(" ") = ""StringUtils.trimToEmpty("abc") = "abc"StringUtils.trimToEmpty(" abc ") = "abc" truncate(String str, int maxWidth)截断字符串，具有以下特点： 如果str字符串的长度小于maxWidth，则直接返回str。 不满足第一条时，则为substring(str, 0, maxWidth)。 如果maxWidth小于0，则抛出IllegalArgumentException。 在任何情况下都不会返回长度大于maxWidth的字符串。 代码示例： 12345678StringUtils.truncate(null, 0) = nullStringUtils.truncate(null, 2) = nullStringUtils.truncate("", 4) = ""StringUtils.truncate("abcdefg", 4) = "abcd"StringUtils.truncate("abcdefg", 6) = "abcdef"StringUtils.truncate("abcdefg", 7) = "abcdefg"StringUtils.truncate("abcdefg", 8) = "abcdefg"StringUtils.truncate("abcdefg", -1) = throws an IllegalArgumentException truncate(String str, int offset, int maxWidth)截断字符串，具有以下特点： 如果str字符串的长度小于maxWidth，则直接返回str。 不满足第一条时，则为substring(str, offset, maxWidth)。 如果maxWidth或者offset小于0，则抛出IllegalArgumentException。 在任何情况下都不会返回长度大于maxWidth的字符串。 代码示例： 123456789101112131415161718192021222324252627282930StringUtils.truncate(null, 0, 0) = nullStringUtils.truncate(null, 2, 4) = nullStringUtils.truncate("", 0, 10) = ""StringUtils.truncate("", 2, 10) = ""StringUtils.truncate("abcdefghij", 0, 3) = "abc"StringUtils.truncate("abcdefghij", 5, 6) = "fghij"StringUtils.truncate("raspberry peach", 10, 15) = "peach"StringUtils.truncate("abcdefghijklmno", 0, 10) = "abcdefghij"StringUtils.truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentExceptionStringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, 10) = "abcdefghij"StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, Integer.MAX_VALUE) = "abcdefghijklmno"StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE) = "abcdefghijklmno"StringUtils.truncate("abcdefghijklmno", 1, 10) = "bcdefghijk"StringUtils.truncate("abcdefghijklmno", 2, 10) = "cdefghijkl"StringUtils.truncate("abcdefghijklmno", 3, 10) = "defghijklm"StringUtils.truncate("abcdefghijklmno", 4, 10) = "efghijklmn"StringUtils.truncate("abcdefghijklmno", 5, 10) = "fghijklmno"StringUtils.truncate("abcdefghijklmno", 5, 5) = "fghij"StringUtils.truncate("abcdefghijklmno", 5, 3) = "fgh"StringUtils.truncate("abcdefghijklmno", 10, 3) = "klm"StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE) = "klmno"StringUtils.truncate("abcdefghijklmno", 13, 1) = "n"StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE) = "no"StringUtils.truncate("abcdefghijklmno", 14, 1) = "o"StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE) = "o"StringUtils.truncate("abcdefghijklmno", 15, 1) = ""StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE) = ""StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE) = ""StringUtils.truncate("abcdefghij", 3, -1) = throws an IllegalArgumentExceptionStringUtils.truncate("abcdefghij", -2, 4) = throws an IllegalArgumentException left(String str, int len)得到一个字符串最左边的len个字符 123StringUtils.left("abc", 0) = ""StringUtils.left("abc", 2) = "ab"StringUtils.left("abc", 4) = "abc" right(String str, int len)同left(String str, int len)相反，从右边截取len个字符。 mid(String str, int pos, int len)得到一个字符串中间的len个字符。 12345StringUtils.mid("abc", 0, 2) = "ab"StringUtils.mid("abc", 0, 4) = "abc"StringUtils.mid("abc", 2, 4) = "c"StringUtils.mid("abc", 4, 2) = ""StringUtils.mid("abc", -2, 2) = "ab" substringBefore(String str, String separator)得到一个字符串第一个分隔符字符串之前的字符串。 123456StringUtils.substringBefore("abc", "a") = ""StringUtils.substringBefore("abcba", "b") = "a"StringUtils.substringBefore("abc", "c") = "ab"StringUtils.substringBefore("abc", "d") = "abc"StringUtils.substringBefore("abc", "") = ""StringUtils.substringBefore("abc", null) = "abc" substringAfter(String str, String separator)同substringBefore(String str, String separator)相反。得到一个字符串第一个分隔符字符串之后的字符串。 substringBetween(String str, String open, String close)得到一个字符串两个字符串之间字符串。 123456StringUtils.substringBetween("", "", "") = ""StringUtils.substringBetween("", "", "]") = nullStringUtils.substringBetween("", "[", "]") = nullStringUtils.substringBetween("yabcz", "", "") = ""StringUtils.substringBetween("yabcz", "y", "z") = "abc"StringUtils.substringBetween("yabczyabcz", "y", "z") = "abc" substringBetween(String str, String tag)是substringBetween(String str, String open, String close)的特殊情形。得到一个字符串中同一个字符串之间的字符串。 比较字符串equals(CharSequence cs1, CharSequence cs2)判断两字符串相等，代码示例： 12345StringUtils.equals(null, null) = trueStringUtils.equals(null, "abc") = falseStringUtils.equals("abc", null) = falseStringUtils.equals("abc", "abc") = trueStringUtils.equals("abc", "ABC") = false equalsIgnoreCase(CharSequence str1, CharSequence str2)判断两字符串相等，忽略大小写，代码示例： 12345StringUtils.equalsIgnoreCase(null, null) = trueStringUtils.equalsIgnoreCase(null, "abc") = falseStringUtils.equalsIgnoreCase("abc", null) = falseStringUtils.equalsIgnoreCase("abc", "abc") = trueStringUtils.equalsIgnoreCase("abc", "ABC") = true equalsAny(CharSequence string, CharSequence… searchStrings)比较一个字符串是否与其后的某个字符串相等，代码示例： 123456StringUtils.equalsAny(null, (CharSequence[]) null) = falseStringUtils.equalsAny(null, null, null) = trueStringUtils.equalsAny(null, "abc", "def") = falseStringUtils.equalsAny("abc", null, "def") = falseStringUtils.equalsAny("abc", "abc", "def") = trueStringUtils.equalsAny("abc", "ABC", "DEF") = false equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)比较一个字符串是否与其后的某个字符串相等，忽略大小写，代码示例： 123456StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null) = falseStringUtils.equalsAnyIgnoreCase(null, null, null) = trueStringUtils.equalsAnyIgnoreCase(null, "abc", "def") = falseStringUtils.equalsAnyIgnoreCase("abc", null, "def") = falseStringUtils.equalsAnyIgnoreCase("abc", "abc", "def") = trueStringUtils.equalsAnyIgnoreCase("abc", "ABC", "DEF") = true compare(String str1, String str2)比较两字符串的大小，代码示例： 12345678StringUtils.compare(null, null) = 0StringUtils.compare(null , "a") &lt; 0StringUtils.compare("a", null) &gt; 0StringUtils.compare("abc", "abc") = 0StringUtils.compare("a", "b") &lt; 0StringUtils.compare("b", "a") &gt; 0StringUtils.compare("a", "B") &gt; 0StringUtils.compare("ab", "abc") &lt; 0 compareIgnoreCase(String str1, String str2)比较两字符串的大小，忽略大小写，代码示例： 12345678910StringUtils.compareIgnoreCase(null, null) = 0StringUtils.compareIgnoreCase(null , "a") &lt; 0StringUtils.compareIgnoreCase("a", null) &gt; 0StringUtils.compareIgnoreCase("abc", "abc") = 0StringUtils.compareIgnoreCase("abc", "ABC") = 0StringUtils.compareIgnoreCase("a", "b") &lt; 0StringUtils.compareIgnoreCase("b", "a") &gt; 0StringUtils.compareIgnoreCase("a", "B") &lt; 0StringUtils.compareIgnoreCase("A", "b") &lt; 0StringUtils.compareIgnoreCase("ab", "ABC") &lt; 0 查找元素indexOf(CharSequence seq, int searchChar)查找某个字符在字符串中第一次出现时的索引位置，代码示例： 12StringUtils.indexOf("aabaabaa", 'a') = 0StringUtils.indexOf("aabaabaa", 'b') = 2 indexOf(CharSequence seq, CharSequence searchSeq)同indexOf(CharSequence seq, int searchChar)相似。 12345StringUtils.indexOf("aabaabaa", "c") = -1StringUtils.indexOf("aabaabaa", "a") = 0StringUtils.indexOf("aabaabaa", "b") = 2StringUtils.indexOf("aabaabaa", "ab") = 1StringUtils.indexOf("aabaabaa", "") = 0 indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)同indexOf(CharSequence seq, int searchChar)相似。 12345678StringUtils.indexOf("aabaabaa", "a", 0) = 0StringUtils.indexOf("aabaabaa", "b", 0) = 2StringUtils.indexOf("aabaabaa", "ab", 0) = 1StringUtils.indexOf("aabaabaa", "b", 3) = 5StringUtils.indexOf("aabaabaa", "b", 9) = -1StringUtils.indexOf("aabaabaa", "b", -1) = 2StringUtils.indexOf("aabaabaa", "", 2) = 2StringUtils.indexOf("abc", "", 9) = 3 indexOfIgnoreCase(CharSequence str, CharSequence searchStr)同indexOf(CharSequence seq, int searchChar)相似,忽略大小写。 lastIndexOf(CharSequence seq, int searchChar)同indexOf(CharSequence seq, int searchChar)相似，从后面开始查找。 contains(CharSequence seq, CharSequence searchSeq)判断某字符串是否包含某子字符串。 1234StringUtils.contains("", "") = trueStringUtils.contains("abc", "") = trueStringUtils.contains("abc", "a") = trueStringUtils.contains("abc", "z") = false containsIgnoreCase(CharSequence str, CharSequence searchStr)同contains(CharSequence seq, CharSequence searchSeq)相似，忽略大小写。 containsWhitespace(final CharSequence seq)是contains(CharSequence seq, CharSequence searchSeq)的特殊情形，判断是否包含空白字符。 containsAny(CharSequence cs, CharSequence… searchCharSequences)判断某字符串是否包含其后的任意一个字符串。 123StringUtils.containsAny("abcd", "ab", null) = trueStringUtils.containsAny("abcd", "ab", "cd") = trueStringUtils.containsAny("abc", "d", "abc") = true containsNone(CharSequence cs, String invalidChars)判断某字符串是否不含其后字符串的任意一个字符。 1234StringUtils.containsNone("ab", "") = trueStringUtils.containsNone("abab", "xyz") = trueStringUtils.containsNone("ab1", "xyz") = trueStringUtils.containsNone("abz", "xyz") = false 分割字符串split(String str, String separatorChars)将某字符串按字符分割成数组，默认按空格分组。 1234StringUtils.split("abc def", null) = ["abc", "def"]StringUtils.split("abc def", " ") = ["abc", "def"]StringUtils.split("abc def", " ") = ["abc", "def"]StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"] split(String str, String separatorChars, int max)将某字符串按字符分割成最大max长度的数组，默认按空格分组。 1234StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"]StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"]StringUtils.split("ab:cd:ef", ":", 0) = ["ab", "cd", "ef"]StringUtils.split("ab:cd:ef", ":", 2) = ["ab", "cd:ef"] splitByCharacterType(final String str)按字符串类型划分字符串为数组。 123456789StringUtils.splitByCharacterType(null) = nullStringUtils.splitByCharacterType("") = []StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"]StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"]StringUtils.splitByCharacterType("ab:cd:ef") = ["ab", ":", "cd", ":", "ef"]StringUtils.splitByCharacterType("number5") = ["number", "5"]StringUtils.splitByCharacterType("fooBar") = ["foo", "B", "ar"]StringUtils.splitByCharacterType("foo200Bar") = ["foo", "200", "B", "ar"]StringUtils.splitByCharacterType("ASFRules") = ["ASFR", "ules"] 连接字符串join(T… elements)无连接符连接字符串。 12345StringUtils.join(null) = nullStringUtils.join([]) = ""StringUtils.join([null]) = ""StringUtils.join(["a", "b", "c"]) = "abc"StringUtils.join([null, "", "a"]) = "a" join(Object[] array, String separator)将提供的数组按连接符连成字符串。 123456StringUtils.join(null, *) = nullStringUtils.join([], *) = ""StringUtils.join([null], *) = ""StringUtils.join(["a", "b", "c"], ';') = "a;b;c"StringUtils.join(["a", "b", "c"], null) = "abc"StringUtils.join([null, "", "a"], ';') = ";;a" 删除字符串deleteWhitespace(String str)删除空白字符。 1234StringUtils.deleteWhitespace(null) = nullStringUtils.deleteWhitespace("") = ""StringUtils.deleteWhitespace("abc") = "abc"StringUtils.deleteWhitespace(" ab c ") = "abc" removeStart(String str, String remove)删除指定字符串前缀的字符串。 1234StringUtils.removeStart("www.domain.com", "www.") = "domain.com"StringUtils.removeStart("domain.com", "www.") = "domain.com"StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com"StringUtils.removeStart("abc", "") = "abc" removeStartIgnoreCase(String str, String remove)同removeStart(String str, String remove)相似，忽略大小写。 removeEnd(String str, String remove)同removeStart(String str, String remove)相反。 removeEndIgnoreCase(String str, String remove)同removeEnd(String str, String remove)相似，忽略大小写。 remove(String str, String remove)移除字符串中指定的字符串。 12StringUtils.remove("queued", "ue") = "qd"StringUtils.remove("queued", "zz") = "queued" removeIgnoreCase(String str, String remove)同remove(String str, String remove)相似，忽略大小写。 替换字符串replace(String text, String searchString, String replacement)替换某字符串为另一个字符串。 123StringUtils.replace("aba", "a", null) = "aba"StringUtils.replace("aba", "a", "") = "b"StringUtils.replace("aba", "a", "z") = "zbz" replaceIgnoreCase(String text, String searchString, String replacement)同replace(String text, String searchString, String replacement)相似，忽略大小写。 replace(String text, String searchString, String replacement, int max)替换某字符串为另一个字符串,从左到右替换最大max次。 123456StringUtils.replace("abaa", "a", null, -1) = "abaa"StringUtils.replace("abaa", "a", "", -1) = "b"StringUtils.replace("abaa", "a", "z", 0) = "abaa"StringUtils.replace("abaa", "a", "z", 1) = "zbaa"StringUtils.replace("abaa", "a", "z", 2) = "zbza"StringUtils.replace("abaa", "a", "z", -1) = "zbzz" replaceEach(String text, String[] searchList, String[] replacementList)替换某些字符串为另一些字符串。 12345678StringUtils.replaceEach("aba", null, null) = "aba"StringUtils.replaceEach("aba", new String[0], null) = "aba"StringUtils.replaceEach("aba", null, new String[0]) = "aba"StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, null) = "aba"StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, new String[]&#123;""&#125;) = "b"StringUtils.replaceEach("aba", new String[]&#123;null&#125;, new String[]&#123;"a"&#125;) = "aba"StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"w", "t"&#125;) = "wcte"StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"d", "t"&#125;) = "dcte" 填充字符串repeat(final String str, final int repeat)生成重复的字符串，repeat代表生成次数。 123456StringUtils.repeat(null, 2) = nullStringUtils.repeat("", 0) = ""StringUtils.repeat("", 2) = ""StringUtils.repeat("a", 3) = "aaa"StringUtils.repeat("ab", 2) = "abab"StringUtils.repeat("a", -2) = "" repeat(String str, String separator, int repeat)生成重复的字符串，repeat代表生成次数。 123456StringUtils.repeat(null, null, 2) = nullStringUtils.repeat(null, "x", 2) = nullStringUtils.repeat("", null, 0) = ""StringUtils.repeat("", "", 2) = ""StringUtils.repeat("", "x", 3) = "xxx"StringUtils.repeat("?", ", ", 3) = "?, ?, ?" 字符串计数countMatches(CharSequence str, CharSequence sub)计算某字符串在字符串中的出现次数。 12345StringUtils.countMatches("abba", null) = 0StringUtils.countMatches("abba", "") = 0StringUtils.countMatches("abba", "a") = 2StringUtils.countMatches("abba", "ab") = 1StringUtils.countMatches("abba", "xxx") = 0 字符测试isAlpha(CharSequence cs)判断字符串是否是Unicode字母。 123456StringUtils.isAlpha(null) = falseStringUtils.isAlpha("") = falseStringUtils.isAlpha(" ") = falseStringUtils.isAlpha("abc") = trueStringUtils.isAlpha("ab2c") = falseStringUtils.isAlpha("ab-c") = false isAlphaSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是Unicode字母或空格。 1234567StringUtils.isAlphaSpace(null) = falseStringUtils.isAlphaSpace("") = trueStringUtils.isAlphaSpace(" ") = trueStringUtils.isAlphaSpace("abc") = trueStringUtils.isAlphaSpace("ab c") = trueStringUtils.isAlphaSpace("ab2c") = falseStringUtils.isAlphaSpace("ab-c") = false isAlphanumeric(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是Unicode字母或数字。 isAlphanumericSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是Unicode字母、空格或数字。 isNumeric(CharSequence cs)判断字符串是否是数字。 1234567StringUtils.isNumeric("123") = trueStringUtils.isNumeric("12 3") = falseStringUtils.isNumeric("ab2c") = falseStringUtils.isNumeric("12-3") = falseStringUtils.isNumeric("12.3") = falseStringUtils.isNumeric("-123") = falseStringUtils.isNumeric("+123") = false isNumericSpace(CharSequence cs)同isNumeric(CharSequence cs)相似。判断字符串是否是空格或数字。 getDigits(String str)从字符串中提取出数字为字符串。 123456StringUtils.getDigits(null) = nullStringUtils.getDigits("") = ""StringUtils.getDigits("abc") = ""StringUtils.getDigits("1000$") = "1000"StringUtils.getDigits("1123~45") = "12345"StringUtils.getDigits("(541) 754-3010") = "5417543010" isWhitespace(CharSequence cs)判断是否是空格。 123456StringUtils.isWhitespace(null) = falseStringUtils.isWhitespace("") = trueStringUtils.isWhitespace(" ") = trueStringUtils.isWhitespace("abc") = falseStringUtils.isWhitespace("ab2c") = falseStringUtils.isWhitespace("ab-c") = false isAllLowerCase(CharSequence cs)判断字符串是否都是小写。 12345678StringUtils.isAllLowerCase(null) = falseStringUtils.isAllLowerCase("") = falseStringUtils.isAllLowerCase(" ") = falseStringUtils.isAllLowerCase("abc") = trueStringUtils.isAllLowerCase("abC") = falseStringUtils.isAllLowerCase("ab c") = falseStringUtils.isAllLowerCase("ab1c") = falseStringUtils.isAllLowerCase("ab/c") = false isAllUpperCase(CharSequence cs)同isAllLowerCase相反。判断字符串是否都是大写。 isMixedCase(CharSequence cs)同isAllLowerCase相似。判断字符串是否大小写都有。 默认字符串defaultString(String str)得到默认字符串，默认空字符串。 123StringUtils.defaultString(null) = ""StringUtils.defaultString("") = ""StringUtils.defaultString("bat") = "bat" defaultString(String str, String defaultStr)如果是null，则得到默认字符串。 123StringUtils.defaultString(null, "NULL") = "NULL"StringUtils.defaultString("", "NULL") = ""StringUtils.defaultString("bat", "NULL") = "bat" defaultIfEmpty(T str, T defaultStr)同defaultString(String str, String defaultStr)相似。如果是空字符串，则得到默认字符串。 反转字符串reverse(final String str)反转字符串。 123StringUtils.reverse(null) = nullStringUtils.reverse("") = ""StringUtils.reverse("bat") = "tab" 缩写字符串abbreviate(String str, int maxWidth)缩写字符串为最大maxWidth长度的字符串，使用...作为缩写的后缀，maxWidth不能小于等于3。 123456StringUtils.abbreviate("", 4) = ""StringUtils.abbreviate("abcdefg", 6) = "abc..."StringUtils.abbreviate("abcdefg", 7) = "abcdefg"StringUtils.abbreviate("abcdefg", 8) = "abcdefg"StringUtils.abbreviate("abcdefg", 4) = "a..."StringUtils.abbreviate("abcdefg", 3) = IllegalArgumentException abbreviate(String str, String abbrevMarker, int maxWidth)缩写字符串为最大maxWidth长度的字符串，使用abbrevMarker作为缩写的后缀，maxWidth不能小于等于abbrevMarker的长度。 12345678StringUtils.abbreviate("", "...", 4) = ""StringUtils.abbreviate("abcdefg", ".", 5) = "abcd."StringUtils.abbreviate("abcdefg", ".", 7) = "abcdefg"StringUtils.abbreviate("abcdefg", ".", 8) = "abcdefg"StringUtils.abbreviate("abcdefg", "..", 4) = "ab.."StringUtils.abbreviate("abcdefg", "..", 3) = "a.."StringUtils.abbreviate("abcdefg", "..", 2) = IllegalArgumentExceptionStringUtils.abbreviate("abcdefg", "...", 3) = IllegalArgumentException 字符串钱后缀startsWith(CharSequence str, CharSequence prefix)判断某字符串是否包含有指定前缀的字符串。 12345StringUtils.startsWith(null, null) = trueStringUtils.startsWith(null, "abc") = falseStringUtils.startsWith("abcdef", null) = falseStringUtils.startsWith("abcdef", "abc") = trueStringUtils.startsWith("ABCDEF", "abc") = false startsWithIgnoreCase(CharSequence str, CharSequence prefix)同startsWith(CharSequence str, CharSequence prefix)相似。忽略大小写。 startsWithAny(CharSequence sequence, CharSequence… searchStrings)判断某字符串是否包含有其后任意一个指定前缀的字符串。 12345678StringUtils.startsWithAny(null, null) = falseStringUtils.startsWithAny(null, new String[] &#123;"abc"&#125;) = falseStringUtils.startsWithAny("abcxyz", null) = falseStringUtils.startsWithAny("abcxyz", new String[] &#123;""&#125;) = trueStringUtils.startsWithAny("abcxyz", new String[] &#123;"abc"&#125;) = trueStringUtils.startsWithAny("abcxyz", new String[] &#123;null, "xyz", "abc"&#125;) = trueStringUtils.startsWithAny("abcxyz", null, "xyz", "ABCX") = falseStringUtils.startsWithAny("ABCXYZ", null, "xyz", "abc") = false endsWith(CharSequence str, CharSequence suffix)同startsWith(CharSequence str, CharSequence prefix)相反。 endsWithIgnoreCase(CharSequence str, CharSequence suffix)同startsWithIgnoreCase(CharSequence str, CharSequence prefix)相反。 endsWithAny(CharSequence sequence, CharSequence… searchStrings)同startsWithAny(CharSequence sequence, CharSequence... searchStrings)相反。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL基础知识整理]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FPostgreSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库操作DMLCREATE TABLECREATE TABLE语句用于创建数据库中的表。语法是： 123456CREATE TABLE 表名称 (列名1 数据类型,列名2 数据类型,列名3 数据类型,....); 例： 1234567CREATE TABLE user (id integer,user_name varchar(255),email varchar(255),age integer,address varchar(255)) 注意：字段类型char和varchar区别： 容纳固定长度的字符串。 容纳可变长度的字符串。 CONSTRAINT约束、限制，常见的约束如下： CHECK(检查约束) NOT NULL(非空约束) UNIQUE(唯一约束) Primary Key(主键) Foreign Key(外键) 例： 1234567-- 各种约束的使用示例CREATE TABLE user ( id integer NOT NULL PRIMARY KEY, corp_id integer REFERENCES corp (id), user_name text UNIQUE, age numeric CHECK (age &gt; 0)); ALTER TABLEALTER TABLE用来添加，删除或修改现有表中的列，也可以用来添加和删除现有表上的各种制约因素。语法如下： 1234567891011121314151617181920212223242526-- 现有表中添加一个新的列ALTER TABLE table ADD column datatype;-- 现有表中删除一个新的列ALTER TABLE table DROP COLUMN column;-- 现有表中更改数据类型的列ALTER TABLE table MODIFY COLUMN column datatype;-- 现有表中一列添加NOT NULL约束ALTER TABLE table MODIFY column datatype NOT NULL;-- 现有表中添加唯一约束ALTER TABLE table ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);-- 现有表中添加CHECK约束ALTER TABLE table ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);-- 现有表中添加PRIMARY KEY约束ALTER TABLE table ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...);-- 现有表中删除约束ALTER TABLE table DROP CONSTRAINT MyUniqueConstraint;-- 现有表中删除主键ALTER TABLE table DROP CONSTRAINT MyPrimaryKey; DROP TABLEDROP TABLE语句是用来删除表定义及其所有相关的数据表的索引，规则，触发器和约束。语法如下： 1DROP TABLE table; TRUNCATE TABLETRUNCATE TABLE命令用于从现有的表删除完整的数据。在每个表上的DELETE（删除）具有相同的效果，但是，因为它没有实际扫描的表，它的速度快。语法如下： 1TRUNCATE TABLE table; DELETE FROMDELETE FROM用来从一个表中删除现有的记录。可以使用WHERE子句DELETE查询删除所选行，否则所有的记录会被删除。语法如下： 1DELETE FROM table WHERE [condition]; INSERT INTOINSERT INTO语句允许一个到一个表中插入新行。一个可以作为一个查询的结果，在一个时间或几行插入一行。基本语法如下： 12INSERT INTO table (column1, column2, column3,...columnN)]VALUES (value1, value2, value3,...valueN); 注：1.这里 column1, column2,…columnN是要插入数据的表中的列名。 可以以任何顺序列出目标列名。 VALUES子句或查询的值都与显式或隐式的列列表从左到右。 如果要添加表中的所有列的值，可能不需要在SQL查询中指定列（次）名称。但要确保表中是在相同的顺序的列值的顺序。INSERT INTO语法如下： 1INSERT INTO table VALUES (value1,value2,value3,...valueN); UPDATEUPDATE被用来修改现有的表中的记录。可以使用UPDATE查询的WHERE子句更新选定行，否则会被更新的所有行。基本语法如下： 1UPDATE table SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; SQL基础SELECT1SELECT column FROM table; DISTINCT找出表内的不同值的情况。 1SELECT DISTINCT column FROM table; 例： 1SELECT DISTINCT id, email FROM user; WHERE1SELECT column FROM table WHERE [condition]; AND / OR1SELECT column FROM table WHERE [condition1] [AND|OR] [condition2]; IN / NOT IN1SELECT column FROM table WHERE column IN ('value1', 'value2', ...); 例： 1SELECT * FROM user WHERE user_name IN ('张三', '李四'); BETWEEN … AND …1SELECT column FROM table WHERE column BETWEEN 'value1' AND 'value2'; 例： 1SELECT * FROM user WHERE age BETWEEN 18 AND 25; LIKE1SELECT column FROM table WHERE column LIKE &#123;模式&#125;; 例： 1SELECT * FROM user WHERE user_name LIKE '%张%'; ORDER BY1SELECT column FROM table [WHERE condition] ORDER BY column [ASC, DESC]; 注：ASC（默认）代表结果会以由小往大的顺序列出，而DESC代表结果会以由大往小的顺序列出。 例： 1SELECT user_name, email, age FROM user ORDER BY age DESC; GROUP BY1SELECT column1, SUM(column2) FROM table GROUP BY column1; 例： 1SELECT user_name, SUM(age) FROM user GROUP BY user_name; HAVING对函数产生的值来设定条件。 1SELECT column1, SUM(column2) FROM table GROUP BY column1 HAVING [condition]; 例： 1SELECT user_name, SUM(ages) FROM user GROUP BY user_name HAVING SUM(age) &gt; 1500; ALIAS SELECT ‘表别名’.’列名’ AS ‘列别名’ FROM table AS ‘表别名’; 例： 1SELECT u.user_name AS name, sum(age) ages FROM user AS u GROUP BY u.store_name; 函数 AVG (平均) COUNT (计数) MAX (最大值) MIN (最小值) SUM (总合) 1SELECT fun_name(column) FROM table; 例： 1SELECT count(u.id) AS user_count FROM user AS u; 表连接INNER JOIN: 如果表中有至少一个匹配，则返回行；LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行；RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行；FULL JOIN: 只要其中一个表中存在匹配，就返回行。 例： 1SELECT u.uesr_name, c.corp_name FROM user AS u LEFT JOIN corp AS c ON c.id = u.corp_id; SQL进阶UNION / UNION ALLUNION用于合并两个或多个SELECT语句的结果，不返回任何重复的行。UNION ALL运算符语句，则包括重复行的结果。使用UNION，每个SELECT选择的列数必须具有相同的，相同数目的列表达式相同的数据类型，并让它们在相同的顺序，但它们不必是相同的长度。语法如下： 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION [UNION ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] INTERSECT / INTERSECT ALL和UNION指令类似，INTERSECT也是对两个SQL语句所产生的结果做处理的。不同的地方是，UNION基本上是一个OR(如果这个值存在于第一句或是第二句，它就会被选出)，而INTERSECT则比较像AND(这个值要存在于第一句和第二句才会被选出)。UNION是并集，而INTERSECT是交集。INTERSECT ALL则包含交集后的重复数据。语法如下： 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]INTERSECT [INTERSECT ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] EXCEPT / EXCEPT ALLEXCEPT用于求差集，其将查询在前一个结果集中但是不再后面一个结果集中的记录。EXCEPT ALL则包含交集后的重复数据。语法如下： 123456789SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]EXCEPT [EXCEPT ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition] 注：在其他数据库求差集的关键字是：MINUS。 SUBQUERYSUBQUERY即子查询，子查询也是一个普通查询，目的是将用子查询返回的数据将被用来在主查询中作为条件，以进一步限制要检索的数据。可以使用子查询的有SELECT，INSERT，UPDATE和DELETE语句，与运算符如=，&lt;，&gt;，&gt;=，&lt;=，IN等一起使用。有几个子查询必须遵循的规则： 必须用括号括起来的子查询。 子查询只能有一个在SELECT子句中的列，除非多列在主查询的查询来比较其选定的列。 ORDER BY不能使用在子查询中，虽然主查询就可以使用ORDER BY。GROUP BY可以用来执行相同的功能在子查询中的ORDER BY。 子查询返回多于一行只能用于使用多值的运算符，如为IN，EXISTS，IN，ANY / SOME，ALL运算符。 使用示例如下： 1234567891011-- SELECT语句中的子查询SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000);-- INSERT语句的子查询INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY);-- UPDATE语句的子查询UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27);-- UPDATE语句的子查询DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 ); EXISTS / NOT EXISTSEXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。NOT EXISTS的作用与EXISTS正好相反。如果子查询没有返回行，则满足了NOT EXISTS中的WHERE子句。语法如下： 1EXISTS subquery EXISTS 和 IN 的比较： EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOLEAN值。EXISTS内部有一个子查询语句(SELECT … FROM…)，我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。而IN引导的子查询只能返回一个字段 EXISTS : 强调的是是否返回结果集，不要求知道返回什么，IN则需要知道返回的字段值。 EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。 CONCATENATE连接字符串。有的时候，我们有需要将由不同列获得的资料串连在一起。每一种数据库都有提供方法来达到这个目的。 Oracle: CONCAT(), || SQL Server: + MySQL: CONCAT() PostgreSQL: CONCAT(), || PostgreSQL的CONCAT()的语法如下： concat(str “any” [, str “any” [, …] ]) PostgreSQL的||的语法如下： string || stringstring || non-string 或 non-string || string 例： 1SELECT u.user_name || ' ' || u.age FROM user AS u; SUBSTRING截取字符串。 Oracle: SUBSTR() SQL Server: SUBSTRING() MySQL: SUBSTR(), SUBSTRING() PostgreSQL: SUBSTRING() PostgreSQL的SUBSTRING()语法如下： substring(string [from int] [for int]) 截取子字符串。 substring(string from pattern) 截取匹配POSIX正则表达式的子字符串。 substring(string from pattern for escape) 截取匹配SQL正则表达式的子字符串。 例： 12345678-- 得到homsubstring('Thomas' from 2 for 3);-- 得到massubstring('Thomas' from '...$')-- 得到omasubstring('Thomas' from '%#"o_a#"_' for '#') TRIMSQL中的TRIM函数是用来移除掉一个字符串中的字头或字尾。最常见的用途是移除字首或字尾的空白。这个函数在不同的数据库中有不同的名称： Oracle: LTRIM(), RTRIM() SQL Server: LTRIM(), RTRIM() MySQL: TRIM(), LTRIM(), RTRIM() PostgreSQL: TRIM(), BTRIM(), LTRIM(), RTRIM() PostgreSQL的TRIM()语法如下： trim([leading | trailing | both] [characters] from string) 从字符串string的开头/结尾/两边删除只包含characters中字符(缺省是空白)的最长的字符串。 btrim(string text [, characters text]) 从string开头和结尾删除只包含 characters中字符(缺省是空白)的最长字符串。 ltrim(string text [, characters text]) 从字符串string的开头删除只包含characters 中字符(缺省是一个空白)的最长的字符串。 rtrim(string text [, characters text]) 从字符串string的结尾删除只包含characters中字符(缺省是个空白)的最长的字符串。 1234567891011-- 得到Tomtrim(both 'x' from 'xTomxx')-- 得到trimbtrim('xyxtrimyyx', 'xy')-- 得到trimltrim('zzzytrim', 'xyz')-- 得到trimrtrim('trimxxxx', 'x') CASECASE表达式是一种通用的条件表达式，类似于其它编程语言中的if/else语句。 1234CASE WHEN [condition] THEN result [WHEN ...] [ELSE result]END 示例如下： 123456SELECT sex, CASE WHEN sex = 0 THEN '女' WHEN sex = 1 THEN '男' ELSE '未知' END FROM user; COALESCECOALESCE返回它的第一个非NULL的参数值。如果所有参数都是NULL那么返回NULL。它常用于在显示数据时用缺省值替换NULL。语法如下： 1COALESCE(value [, ...]) 使用示例： 1SELECT COALESCE(NULL, NULL, GETDATE()); NULLIF当且仅当value1等于value2时，NULLIF才返回null。否则它返回value1。这些可以用于执行上面给出的COALESCE例子的反例。语法如下： 1NULLIF(value1, value2) GREATEST / LEASTGREATEST和LEAST函数从一个任意数字表达式的列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型。列表中的NULL值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。语法如下： 12GREATEST(value [, ...])LEAST(value [, ...]) 注意：GREATEST和LEAST都不是 SQL 标准，但却是很常见的扩展。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git知识点整理]]></title>
    <url>%2F2018%2F09%2F24%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2FGit%2FGit%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. Git基本概念。 repository config init clone fetch pull commit push branch head tag merge conflict diff log show status 2. Git工作空间和文件状态(1).工作空间 左侧为工作区，右侧为版本库。 工作区（Working Directory） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。 版本库（Repository）工作区有一个隐藏目录.git，是Git的版本库。 在版本库中标记为index的区域为暂存区，标记为master的是Git为我们自动创建的第一个分支，代表的是目录树。此时HEAD实际是指向master分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用master来替换。图中的objects标识的区域为git的对象库，实际位于.git/objects目录下。 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。 当执行提交操作git commit时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。 当执行git reset HEAD命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。 当执行git rm --cached命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行git checkout .或git checkout -- 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。 当执行git checkout HEAD .或git checkout HEAD命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。 (1).文件状态Git 有三种状态，你的文件可能处于其中之一：已提交(committed)、已修改(modified)和已暂存(staged)。 3. Git配置系统级、全局、当前仓库用户名、邮箱的命令系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填) 12git config --global user.name "Jerry Mouse"git config --global user.email "jerry@yiibai.com" 列出Git设置 123git config --listgit config -l 4. Git fetch和pull的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动merge. git pull：相当于是从远程获取最新版本并merge到本地. (1). git fetch示例：123Git fetch origin mastergit log -p master..origin/mastergit merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 上述过程其实可以用以下更清晰的方式来进行： (1). git pull示例：1git pull origin master 上述命令其实相当于git fetch和git merge。在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。 5. Git reset和revert的却别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。 git reset是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。 另外，说一下git revert， git reset –hard和 –soft的区别 git reset –mixed id: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。 git reset –soft id: 实际上，是git reset –mixed id后，又做了一次git add。 git reset –herd id: 是将git的HEAD变了，文件也变了。 6. Git merge和reabse的相同点和不同点merge是合并的意思，rebase是复位基底的意思，相同点都是用来合并分支的。 不同点: merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而rebase操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。 git pull和git pull --rebase区别：git pull做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。 总结：选择 merge 还是 rebase？ merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容 merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面 rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面 rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面 merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定 merge 和 rebase 还有很多强大的选项，可以使用 git help 查看 7. Git stash是什么？它的相关使用方式命令 git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。 git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。 git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。 git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来 git stash drop[] 删除某一个进度，默认删除最新进度 git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了 123456789101112# 恢复工作进度git stash pop [--index] [&lt;stash&gt;]--index 参数：不仅恢复工作区，还恢复暂存区&lt;stash&gt; 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度# 这是git stash保存进度的完整命令形式git stash [save message] [-k|--no-keep-index] [--patch]-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注# git stash save "这是保存的进度" 8. Git只从暂存区删除，从工作空间删除的命令分别是什么?1234git rm --cachedgit rmgit commit 9. Git标签的使用12345678# 列出现有的标签git tag# 打标签git tag -a v1.01 -m "Relase version 1.01"# 查看相应标签的版本信息git show v1.4 -a 选项,创建一个含附注类型的标签 -m 选项,指定了对应的标签说明 9. Git分支的使用1234567891011121314151617181920212223242526272829# 查看本地分支git branch# 查看远程分支git branch -r# 创建本地分支(注意新分支创建后不会自动切换为当前分支)git branch [name]# 切换分支git checkout [name]# 创建新分支并立即切换到新分支git checkout -b [name]# 强制删除一个分支git branch -D [name]# 合并分支(将名称为[name]的分支与当前分支合并)git merge [name]# 查看各个分支最后提交信息git br -v# 查看已经被合并到当前分支的分支git br --merged# 查看尚未被合并到当前分支的分支git br --no-merged 10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个git checkout upstream的过程，将HEAD从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。 11. Git远程操作相关(1). clone git clone &lt;版本库的网址&gt;git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 1234# 克隆jQuery的版本库 git clone https://github.com/jquery/jquery.git git clone -o jQuery https://github.com/jquery/jquery.git (2). remote1234567891011121314151617# 列出所有远程主机git remote# 使用-v选项，可以参看远程主机的网址git remote -v # 可以查看该主机的详细信息git remote show &lt;主机名&gt; # 添加远程主机git remote add &lt;主机名&gt; &lt;网址&gt;# 删除远程主机git remote rm &lt;主机名&gt;# 修改远程主机名称git remote rename &lt;原主机名&gt; &lt;新主机名&gt; (3). fetch123456789101112# 取回所有分支(branch)的更新到本地git fetch &lt;远程主机名&gt;# 取回某的特定分支的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt;# 取回origin主机的master分支的更新git fetch origin master# 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支git merge origin/mastergit rebase origin/master (4). pull git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 123456789101112# 取回origin主机的next分支，与本地的master分支合并git pull origin next:master# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin next# 上面的命令实质上等同于先做git fetch，再做git merge。git fetch origingit merge origin/next# 合并需要采用rebase模式git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; (5). push git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 注意:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 123456789101112131415161718192021222324# 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建git push origin master# 省略了本地分支，以下等同，删除origin主机的master分支git push origin :mastergit push origin --delete master# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略git push origin# 如果当前分支只有一个追踪分支，那么主机名都可以省略。git push# 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git pushgit push -u origin master# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机git push --all origin# 强制推送git push --force origin# git push不会推送标签(tag)，除非使用–tags选项git push origin --tags 12. Git Flow使用简介就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程： Git flow Github flow Gitlab flow 三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是Git flow。 它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。 (1). Git Flow流程图 (2). Git Flow常用的分支 Production分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。 Develop分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。 Feature分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。 Release分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。 Hotfix分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。 (3). Git Flow代码示例a. 创建develop分支12git branch developgit push -u origin develop b. 开始新Feature开发12345678git checkout -b some-feature develop# Optionally, push branch to origin:git push -u origin some-feature# 做一些改动git statusgit add some-filegit commit c. 完成Feature123456789git pull origin developgit checkout developgit merge --no-ff some-featuregit push origin developgit branch -d some-feature# If you pushed branch to origin:git push origin --delete some-feature d. 开始Relase1234git checkout -b release-0.1.0 develop# Optional: Bump version number, commit# Prepare release, commit e. 完成Release123456789101112131415git checkout mastergit merge --no-ff release-0.1.0git pushgit checkout developgit merge --no-ff release-0.1.0git pushgit branch -d release-0.1.0# If you pushed branch to origin:git push origin --delete release-0.1.0 git tag -a v0.1.0 mastergit push --tags f. 开始Hotfix1git checkout -b hotfix-0.1.1 master g. 完成Hotfix123456789101112git checkout mastergit merge --no-ff hotfix-0.1.1git pushgit checkout developgit merge --no-ff hotfix-0.1.1git pushgit branch -d hotfix-0.1.1git tag -a v0.1.1 mastergit push --tags]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之状态模式]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。 二、模式定义 状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 三、模式结构1. 角色组成：状态模式包含如下角色： Context: 环境类 State: 抽象状态角色 ConcreteState: 具体状态角色类 2. 结构图： 3. 时序图： 四、示例代码首先，是抽象的状态角色接口： 1234567891011121314151617/** * 抽象状态角色 * Created by blinkfox on 16/7/12. */public interface IState &#123; /** * 抽象方法1 */ void handle1(); /** * 抽象方法2 */ void handle2();&#125; 接下来，是多个具体的状态角色类，分别如下： 1234567891011121314151617181920212223/** * 具体状态角色类1 * Created by blinkfox on 16/7/12. */public class ConcreteState1 implements IState &#123; /** * 具体状态角色类1中的方法1 */ @Override public void handle1() &#123; System.out.println("执行了具体状态角色类1中的方法1..."); &#125; /** * 具体状态角色类1中的方法2 */ @Override public void handle2() &#123; System.out.println("执行了具体状态角色类1中的方法2..."); &#125;&#125; 1234567891011121314151617181920212223/** * 具体状态角色类2 * Created by blinkfox on 16/7/12. */public class ConcreteState2 implements IState &#123; /** * 具体状态角色类2中的方法1 */ @Override public void handle1() &#123; System.out.println("执行了具体状态角色类2中的方法1..."); &#125; /** * 具体状态角色类2中的方法2 */ @Override public void handle2() &#123; System.out.println("执行了具体状态角色类2中的方法2..."); &#125; &#125; 然后，是环境类： 1234567891011121314151617181920212223242526272829303132/** * 环境角色类 * Created by blinkfox on 16/7/12. */public class Context &#123; // 当前状态 private IState state; /** * 构造方法 * @param state */ public Context(IState state) &#123; this.state = state; &#125; /** * 方法1 */ public void handle1() &#123; this.state.handle1(); &#125; /** * 方法2 */ public void handle2() &#123; this.state.handle2(); &#125;&#125; 最后，是用于测试状态模式的客户端场景类： 12345678910111213/** * 状态模式的客户端场景累 * Created by blinkfox on 16/7/12. */public class StateClient &#123; public static void main(String[] args) &#123; Context context = new Context(new ConcreteState1()); context.handle1(); context.handle2(); &#125;&#125; 五、模式分析 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。 状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。 在状态模式结构中需要理解环境类与抽象状态类的作用： 环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。 抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。 1. 优点状态模式的优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 2. 缺点状态模式的缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 3.适用环境在以下情况下可以使用状态模式： 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。 状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。 六、总结 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。 状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。 状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。 状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之代理模式]]></title>
    <url>%2F2018%2F09%2F20%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。 通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。 二、模式定义 代理模式(Proxy Pattern)：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 三、模式结构1. 角色组成代理模式包含如下角色： Subject: 抽象主题角色 RealSubject: 真实主题角色 Proxy: 代理主题角色 2. 结构图 四、示例代码首先，是抽象的主题接口和真实主题类： 1234567891011121314package com.blinkfox.patterns.proxy;/** * 抽象主题类 * Created by blinkfox on 2017/1/1. */public interface ISubject &#123; /** * 定义一个方法 */ public void request();&#125; 1234567891011121314151617package com.blinkfox.patterns.proxy;/** * 真实主题类 * Created by blinkfox on 2017/1/1. */public class RealSubject implements ISubject &#123; /** * 实现方法 */ @Override public void request() &#123; System.out.println("真实主题类请求方法..."); &#125;&#125; 然后，是代理类： 123456789101112131415161718192021222324252627282930313233343536package com.blinkfox.patterns.proxy;/** * 代理类 * Created by blinkfox on 2017/1/1. */public class Proxy implements ISubject &#123; private ISubject subject; public Proxy(ISubject subject) &#123; this.subject = subject; &#125; @Override public void request() &#123; this.before(); this.subject.request(); this.after(); &#125; /** * 预处理 */ private void before() &#123; System.out.println("执行前(before)的处理..."); &#125; /** * 善后处理 */ private void after() &#123; System.out.println("执行后(after)的处理..."); &#125;&#125; 最后，是客户端场景测试类： 123456789101112131415package com.blinkfox.patterns.proxy;/** * 代理模式客户端场景类 * Created by blinkfox on 2017/1/1. */public class ProxyClient &#123; public static void main(String[] args) &#123; ISubject subject = new RealSubject(); Proxy proxy = new Proxy(subject); proxy.request(); &#125;&#125; 五、模式分析1. 优点代理模式的优点： 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对真实对象的使用权限。 2. 缺点代理模式的缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 3. 适用环境根据代理模式的使用目的，常见的代理模式有以下几种类型： 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。 保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙(Firewall)代理：保护目标不让恶意用户接近。 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。 模式总结 在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。 代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVEL2.x模板指南]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%90%8E%E7%AB%AF%2FJava%2FMVEL2.x%E6%A8%A1%E6%9D%BF%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[简介 MVEL最初作为Mike Brock创建的 Valhalla项目的表达式计算器（expression evaluator）。Valhalla本身是一个早期的类似 Seam 的“开箱即用”的Web 应用框架，而 Valhalla 项目现在处于休眠状态， MVEL则成为一个继续积极发展的项目。相比最初的OGNL、JEXL和JUEL等项目，而它具有远超它们的性能、功能和易用性 - 特别是集成方面。它不会尝试另一种JVM语言，而是着重解决嵌入式脚本的问题。关于MVEL的语法请参考MVEL 2.x语法指南 MVEL 2.0提供了一个新的，更强大的，统一的模板引擎，汇集了1.2中引入的许多模板概念。 不幸的是，1.2中的模板引擎的架构不足以用于常规维护，并且决定从头开始完全重写模板引擎。 一、MVEL 2.0基本模板MVEL模板由纯文本文档中的orb-tags组成。 Orb标记表示引擎将在运行时计算模板的动态元素。 如果你熟悉FreeMarker，这种类型的语法将不会完全陌生。 1. 一个简单的模板123Hello, @&#123;person.getSex() == 'F' ? 'Ms.' : 'Mr.'&#125; @&#123;person.name&#125;This e-mail is to thank you for your interest in MVEL Templates 2.0. 此模板展示了可以在简单文本中嵌入表达式。当计算结果时，输出可能如下所示： 123Hello, Ms. Sarah PetersonThis e-mail is to thank you for your interest in MVEL Templates 2.0. 2. 转义@符号当然，由于@符号用于表示orb-tag的开头，因此您可能需要对其进行转义，以防止其被编译器处理。幸运的是，只有一种情况，即当你实际上需要输出‘@{‘字符串在您的模板上时。 由于编译器需要@和{组合触发orb识别，你可以自由使用@符号而不转义它们。例如： 1234Email any questions to: foo@bar.com@&#123;date&#125;@include&#123;'disclaimer.html'&#125; 但是在你需要一个@符号挨着一个orb-tag的情况下，你需要通过重复它两次来避免它： 1@&#123;username&#125;@@@&#123;domain&#125; 这是两个@转义一个符号，第三个@是标签的开始。如果你感觉这看起来太乱，你可以使用替代方法，即使用表达式标签，如下所示： 1@&#123;username&#125;@&#123;'@'&#125;@&#123;domain&#125; 二、MVEL 2.0 Orb标签本文包含了MVEL 2.0模板引擎中所有开箱即用的orb标签。 1. @{} Orb表达式@{}表达式是orb-tag的最基本形式。它包含一个对字符串求值的值表达式，并附加到输出模板中。例如： 1Hello, my name is @&#123;person.name&#125; 2. @code{} 静默代码标签静默代码标记允许您在模板中执行MVEL表达式代码。它不返回值，并且不以任何方式影响模板的格式。 12@code&#123;age = 23; name = 'John Doe'&#125;@&#123;name&#125; is @&#123;age&#125; years old 该模板将计算出：John Doe is 23 years old。 3. @if{}@else{} 控制流标签@if{}和@else{}标签在MVEL模板中提供了完全的if-then-else功能。 例如： 1234567@if&#123;foo != bar&#125; Foo not a bar!@else&#123;bar != cat&#125; Bar is not a cat!@else&#123;&#125; Foo may be a Bar or a Cat!@end&#123;&#125; MVEL模板中的所有块必须用@end{}标签来终止，除非是if-then-else结构，其中@else{}标记表示前一个控制语句的终止。 4. @foreach{} Foreach迭代foreach标签允许您在模板中迭代集合或数组。 注意：foreach的语法已经在MVEL模板2.0中改变，以使用foreach符号来标记MVEL语言本身的符号。 123@foreach&#123;item : products&#125; - @&#123;item.serialNumber&#125;@end&#123;&#125; MVEL 2.0要求您指定一个迭代变量。虽然MVEL 1.2假设您没有指定别名，但由于对该默认操作有一些抱怨，因此已被删除。 5. 多重迭代您可以通过逗号分隔迭代在一个foreach循环中一次性迭代多个集合： 123@foreach&#123;var1 : set1, var2 : set2&#125; @&#123;var1&#125;-@&#123;var2&#125;@end&#123;&#125; 6. 分隔你可以通过在@end{}标签中指定迭代器的文本分隔符。 1@foreach&#123;item : people&#125;@&#123;item.name&#125;@end&#123;', '&#125; 将返回类似这样的结果：John, Mary, Joseph。 7. @include{} 包含模板文件您可以使用此标签将模板文件包含到MVEL模板中。 123@include&#123;'header.mv'&#125;This is a test template. 您还可以通过在模板名称后面添加分号在include标签内执行MVEL表达式： 1@include &#123;'header.mv'; title ='Foo Title'&#125; 8. @includeNamed{} 包括一个命名模板命名模板是已经通过TemplateRegistry预先编译并传递到运行时的模板，或者已在模板本身中声明的模板。 您只需添加： 12@includeNamed &#123;'fooTemplate'&#125;@includeNamed &#123;'footerTemplate'，showSomething = true&#125; 你也可以在@includeNamed{}标签中执行MVEL代码，就像@include{}标签一样。 9. @declare{} 声明一个模板除了包括外部文件的外部模板，并以编程方式传递它们之外，您还可以从模板中声明模板。 它允许你做这样的事情： 123456@declare&#123;'personTemplate'&#125; Name: @&#123;name&#125; Age: @&#123;age&#125;@end&#123;&#125;@includeNamed&#123;'personTemplate'; name='John Doe'; age=22&#125; 10. @comment{} 注释标签注释标签允许您向模板添加不可见的注释。 例如： 1234@comment&#123; This is a comment&#125;Hello: @&#123;name&#125;! 三、MVEL 2.0模板集成使用MVEL模板是直接和容易的。 与常规MVEL表达式一样，它们可以解释性地执行，或者预编译并重新用于更快的评估。 1. org.mvel.templates.TemplateRuntime 类TemplateRuntime类是模板引擎的中心。您可以通过eval()方法将要计算的模板传递给模板引擎。 一般来说，模板引擎遵循上下文和变量绑定的所有相同规则，使用一组重载的eval()方法。 下面是一个解析模板的简单例子： 12345String template = "Hello, my name is @&#123;name.toUpperCase()&#125;");Map vars = new HashMap();vars.put("name", "Michael");String output = (String) TemplateRuntime.eval(template, vars); 在执行结束时，“output”变量将包含字符串： 1Hello, my name is MICHAEL 2. org.mvel.templates.TemplateCompiler类TemplateCompiler类允许预先编译模板。 当编译模板时，将生成一个紧凑，可重用的评估树，可以快速用于计算模板。它直接使用： 1234567String template = "1 + 1 = @&#123;1+1&#125;";// 编译模板CompiledTemplate compiled = TemplateCompiler.compileTemplate(template);// 执行模板String output = (String) TemplateRuntime.execute(compiled); 在执行结束时，“output”变量将包含字符串： 11 + 1 = 2]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MVEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVEL 2.x语法指南]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%90%8E%E7%AB%AF%2FJava%2FMVEL2.x%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MVEL 2.x语法指南MVEL全称为：MVFLEX Expression Language，是用来计算Java语法所编写的表达式值的表达式语言。MVEL的语法很大程度上受到Java语法的启发，但为了使表达式语法更高效,还是有一些基本差异，例如可以像正则表达式一样直接支持集合、数组和字符串匹配的运算。 除了表达式语言之外，MVEL还用作配置和字符串构造的模板语言。这里还有一个关于MVEL介绍信息的wiki页面是：https：//en.wikipedia.org/wiki/MVEL。 MVEL 2.x表达式主要包括以下特性： 属性表达式 布尔表达式 方法调用 变量赋值 函数定义 一、基本语法MVEL是基于Java语法的表达式语言，具有特定于MVEL的一些明显差异。与Java不同，MVEL是动态类型化（可选类型化），意味着在源代码中不需要类型限定。 MVEL可以方便的集成到产品中使用。Maven的集成方式如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.mvel&lt;/groupId&gt; &lt;artifactId&gt;mvel2&lt;/artifactId&gt; &lt;version&gt;2.2.8.Final&lt;/version&gt;&lt;/dependency&gt; 一个MVEL表达式，简单的可以是单个标识符，复杂的则可能是一个充满了方法调用和内部集合创建的庞大的布尔表达式。使用MVEL提供的API。可以动态得到表达式的执行结果。 1. 简单属性表达式1user.name 在这个表达式中，我们只有一个标识符（user.name），在MVEL中我们称它为属性表达式，因为表达式的唯一目的就是从上下文中提取出变量或者对象的属性。属性表达式是最常见的用途之一，通过它，MVEL可以用来作为一个高性能，易使用的反射优化器。 MVEL甚至可以用来计算布尔表达式： 1user.name =='John Doe' 与Java一样，MVEL支持所有优先级规则，包括通过括号来控制执行顺序。 1(user.name == 'John Doe') &amp;&amp; ((x * 2) - 1) &gt; 20 2. 复合语句您可以使用分号来表示语句的终止，使用任意数量的语句编写脚本。分号在所有情况下都是必需的，除非在脚本中只有一个语句或最后一个语句。 1statement1; statement2; statement3 注意：statement3语句后可以缺少分号。 另外，换行不能替代分号来作为一个语句的结束标识。 3. 返回值MVEL是被设计为一个集成语言作为核心，允许开发人员提供简单的脚本设置绑定和逻辑。因此，MVEL表达式使用“last value out”原则（输出最后值原则）。这意味着，尽管MVEL支持return关键字，但却没必要使用它。例如： 123a = 10;b = (a = a * 2) + 10;a; 在该示例中，表达式返回a的值，因为a;是表达式的最后一个值。它在功能上与下面的脚本等价： 123a = 10;b = (a = a * 2) + 10;return a; 二、值判断在MVEL中所有的判断是否相等，都是对值的判断，而没有对引用的判断，因此表达式foo == &#39;bar&#39;等价于Java中的foo.equals(&quot;bar&quot;)。 1. 判断空值MVEL提供了一个特殊的字符来表示值为空的情况，叫作empty，例如： 1foo == empty 若foo满足空的任何条件，这个表达式值都为true。 2. 判断Null值MVEL中，null和nil都可以用来表示一个Null值，如： 12foo == null;foo == nil; // 和null一样 3. 强制转换当两个不同类型且没有可比性的值进行比较时，MVEL会应用类型强制转换系统，即将左边的值强制转换成右边的值的类型，反之亦然。如： 1"123" == 123; 这个表达式的值为true,因为为了执行比较，强制类型转换系统会隐式的将数字123转换成字符串。 三、内联Lists、Maps和数组ArraysMVEL允许你使用简单优雅的语法来表示Lists，Mpas和数组Arrays。 且看下面的示例： 1["Bob" : new Person("Bob"), "Michael" : new Person("Michael")] 这个表达式的功能等价于： 123Map map = new HashMap();map.put("Bob", new Person("Bob"));map.put("Michael", new Person("Michael")); 用这种结构描述MVEL内部数据结构，功能非常强大，你可以在任何地方使用它，甚至可以作为方法的参数使用，如： 1something.someMethod(["foo" : "bar"]); 1. ListsLists用以下格式来表示：”[item1, item2, …]”，如： 1["Jim", "Bob", "Smith"] 2. MapsMaps用以下格式来表示：”[key1 : value1, key2: value2, …]”，如： 1["Foo" : "Bar", "Bar" : "Foo"] 3. 数组Arrays数组Arrays用以下格式来表示：”{item1, item2, …}”，如： 1&#123;"Jim", "Bob", "Smith"&#125; 4. 数组强制转换关于内联数组，需要知道的一个非常重要的方面是，它可以被强制转换成其它类型的数组，当你声明一个数组时，是不直接指定其类型的，但你可以通过将其传递给一个接收int[]类型参数的方法来指定。如： 1foo.someMethod(&#123;1,2,3,4&#125;); 在这种情况下，当MVEL发现目标方法接收的是一个int[]，会自动的将{1,2,3,4}转换成int[]类型。 四、属性导航MVEL属性导航遵循在其他语言（如Groovy，OGNL，EL等）中bean属性表达式中公认惯例的使用方式。和其它语言必须通过底层的方法来控制权限不同的是，MVEL提供了一种单一的，统一的语法来访问属性，静态字段和maps等。 1. Bean属性大多数java开发者都熟悉getter/setter模式，并在java对象中用它来封装属性的访问权限。例如，你可能会通过下面的方式访问一个对象的属性： 1user.getManager().getName(); 为了简化此操作，您可以使用以下表达式访问相同的属性： 1user.manager.name 注意：当一个对象中的字段的作用域是public时，MVEL仍然倾向于通过get方法来访问其属性。 2. Bean的安全属性导航有时，当你的表达式中会含有null元素时，这时就需要你进行一个为空判断，否则就会发生错误。当你使用null-safe操作符时你可以简化这个操作： 1user.?manager.name 它的功能相当于： 1if (user.manager != null) &#123; return user.manager.name; &#125; else &#123; return null; &#125; 3. 集合集合的遍历也可以通过简单的语法来实现： (1). List的访问List可以像访问数组一样访问，如： 1user[5] 这等价与java中的代码： 1user.get(5); (2). Map的访问Map的访问和访问数组也非常相似，不同的是，在访问Map时索引值可以是任意对象，如： 1user["foobar"] 这等价与java中的代码： 1user.get("foobar"); 当Map的key是String类型时，还可以使用特殊的方式来访问，如： 1user.foobar 4. 字符串作数组为了能使用属性的索引（迭代也是如此），所有的字符串都可以看成是一个数组，在MVEL中你可以用下面的方式来获取一个字符串变量的第一个字符： 12foo = "My String";foo[0]; // returns 'M' 五、文字常量在脚本语言中，一段文字（常量）用来代表一个固定的值。 1. 字符串常量字符串常量可以用一对单引号或一对双引号来界定。如： 12"This is a string literal"'This is also string literal' 字符串转义字符 \ - 代表一个反斜杠。 \n - 换行符 \r - 回车符 \u#### - Unicode字符 (如: /uAE00) ### - 八进制字符 (如: /73) 2. 数字常量整数可以表示为十进制（基数为10），8进制（基数为8），或十六进制（基数为16）。 一个十进制数字，不从零开始（相对于8进制、16进制而言），可以表示任意数，如： 1125 // 十进制 一个八进制数，以0为前缀，后面跟着0到7内的数字。 10353 // 八进制 一个十六进制，以0X为前缀，后面可以跟着0-9，A-F范围内的数字。 10xAFF0 // 十六进制 3. 浮点型常量浮点数由整数和由点/周期字符表示的小数部分组成，带有可选的类型后缀。 12310.503 // double型94.92d // double型14.5f // float型 4. 大数字常量您可以使用后缀B和I（必须大写）来表示BigDecimal和BigInteger文字，如： 12104.39484B // BigDecimal8.4I // BigInteger 5. 布尔常量布尔型常量用保留关键字true和false来表示。 6. 空常量用null或nil来表示。 六、类型常量类型常量的处理方式与Java中的相同，格式为：”.“。 所以一个类可以这样限定： 1java.util.HashMap 或者如果类已经通过或者通过外部配置被导入，则它被简单地通过其非限定名称来引用： 1HashMap 嵌套类嵌套类不能通过MVEL 2.0中的标准点表示法（如Java中）来访问。 相反，你必须用$符号限定这些类。 1org.proctor.Person$BodyPart 七、流程控制MVEL的强大已经超出了简单的表达式。事实上，MVEL提供了一系列的程序流程控制操作符来方便你进行高级的脚本操作。 1. If-Then-ElseMVEL提供了完整的C/Java式的if-then-else块，如： 1234567if (var &gt; 0) &#123; System.out.println("Greater than zero!");&#125; else if (var == -1) &#123; System.out.println("Minus one!");&#125; else &#123; System.out.println("Something else!");&#125; 2. 三目运算符其实就是Java中的条件表达式，如： 1var &gt; 0 ? "Yes" : "No"; 可以嵌套三目运算符 1var &gt; 0 ? "Yes" : (var == -1 ? "Minus One!" : "No") 3. ForeachMVEL的强大特性之一就是其Foreach操作符，在功能和语法上，他都类似于java1.5中的for each操作符，它接收用冒号隔开的两个参数，第一个是当前元素的一个域变量，而第二个是要迭代的集合或数组。如下所示： 1234567count = 0;foreach (name : people) &#123; count++; System.out.println("Person #" + count + ":" + name);&#125; System.out.println("Total people: " + count); 因为MVEL将字符串视作一个可以迭代的对象，所以你可以用foreach语句来迭代一个字符串（一个字符接一个字符的）： 12345str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";foreach (el : str) &#123; System.out.print("["+ el + "]"); &#125; 上面的示例将会输出： 1[A][B][C][D][E][F][G][H][I][J][K][L][M][N][O][P][Q][R][S][T][U][V][W][X][Y][Z] 你也可以利用MVEL进行计数（从1开始）： 123foreach (x : 9) &#123; System.out.print(x);&#125; 这会输出： 1123456789 注意：像java5.0一样，在MVEL2.0中，可以将foreach简化成关键字for来使用，如： 1for (item : collection) &#123; ... &#125; 4. for循环MVEL实现了标准的C语言的for循环： 123for (int i =0; i &lt; 100; i++) &#123; System.out.println(i);&#125; 5. Do While, Do Until和java中的意义一样，MVEL也实现了Do While,Do Until，While和Until意义正好相反。 1234do &#123; x = something();&#125; while (x != null); 在语义上相当于： 1234do &#123; x = something();&#125;until (x == null); 6. While, UntilMVEL中实现了标准的While，并添加了一个与之相反的Until。 123while (isTrue()) &#123; doSomething();&#125; 或者写成 123until (isFalse()) &#123; doSomething();&#125; 八、投影和交集简单地说，投影是一种描述集合的方式。 通过非常简单的语法，您可以检索集合中非常复杂的对象模型。 假设，你有一个User对象的集合。 每个对象都有一个Parent。 现在你想获得集合users中的所有parent的name的列表（假设Parent中有字段name），你可以这样来写： 1parentNames = (parent.name in users); 您甚至可以执行嵌套操作，假设，User对象有个集合成员叫做familyMembers，现在我们想获得一个所有家庭成员姓名的集合： 1familyMembers = (name in (familyMembers in users)); 九、赋值MMVEL允许你对表达式中的变量进行赋值，以便在运行时获取，或在表达式内部使用。因为MVEL是动态类型语言，所以你不必为了声明一个变量而指定其类型。当然，你也可以选择指定。 12str =“My String”; // validString str =“My String”; // valid 与java语言不同的是，当给一个指定类型的变量赋值时，MVEL会提供自动的类型转换（可行的话），如： 12String num = 1;assert num instanceof String＆amp;＆amp; num ==“1”; 对于动态类型变量而言，你要想对其进行类型转换，你只需要将值转换成相应的类型既可： 12num =（String）1;assert num instanceof String＆amp;＆amp; num ==“1”; 十、函数定义MVEL可以使用def或function关键字来定义本地函数。 函数必须是先声明后引用，唯一例外的是递归调用的时候。 1. 一个简单示例定义一个简单函数： 1def hello() &#123; System.out.println("Hello!"); &#125; 定义了一个没有参数的函数hello.当调用该函数时会在控制台打印”Hello!” 一个MVEL定义的函数就像任何常规的方法调用。 1hello(); // 调用函数 2. 传参和返回值函数可以接收参数和返回一个值，看下面的示例： 123def addTwo(a, b) &#123; a + b;&#125; 这个函数会接收两个参数(a和b)，然后将这两个变量相加。因为MVEL遵循last-value-out原则，所以结果将会被返回。因此，你可以这样来使用这个函数： 12val = addTwo(5, 2);assert val == 10; 当然，也可以使用return关键字来强制从程序内部返回一个函数值。 3. 闭包MVEL支持闭包,然而其功能与本地java函数没有任何关联。 12345678// 定义一个接收一个参数的函数def someFunction(f_ptr) &#123; f_ptr(); &#125;// 定义变量avar a = 10;// 传递函数闭包someFunction(def &#123; a * 10 &#125;); 十一、Lambda表达式MVEL允许定义Lambda方法，如下所示： 12threshold = def (x) &#123; x &gt;= 10 ? x : 0 &#125;;result = cost + threshold(lowerBound); 上面的例子定义了一个Lambda，并将其赋值给变量”threshold”.Lambda实质上就是一个用来给变量赋值的函数，也是闭包。 翻译原文：http://mvel.documentnode.com/]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MVEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring基础介绍]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%90%8E%E7%AB%AF%2Fspring%2FSpring%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、Spring 概述（一）Spring 的简史Spring 的历史网上有很多的介绍，下面是 Spring 发展历程的一个简介。 1. 第一阶段：xml 配置在 Spring 1.x 时代，使用 Spring 开发满眼都是 xml 配置的 Bean，随着项目的扩大，我们需要把 xml 配置文件放到不同的配置文件里，那时候需要频繁地在开发的类和配置文件之间切换。 2. 第二阶段：注解配置在 Spring 2.x 时代，随着 JDK 1.5 带来的注解支持，Spring 提供了声明 Bean 的注解（如：@Component、@Service），大大减少了配置量。这时 Spring 圈子里存在着一种争论：注解配置和 xml 配置究竟哪个更好？我们最终的选择是应用的基本配置（如：数据库配置）用 xml，业务配置用注解。 3. 第三阶段：Java 配置从 Spring 3.x 到现在，Spring 提供了 Java 配置的能力，使用 Java 配置可以让你更理解你配置的 Bean。我们目前刚好处于这个时代，Spring 4.x 和 Spring Boot 都推荐使用 Java 配置。 （二）Spring 概述Spring 框架是一个轻量级的企业级开发的一站式解决方案。所谓解决方案就是可以基于 Spring 解决 JavaEE 开发的所有问题。Spring 框架主要提供了IoC容器、AOP、数据访问、Web 开发、消息、测试等相关技术的支持。 Spring 使用简单的 POJO（Plain Old Java Object，即无任何限制的普通Java对象）来进行企业级开发。每一个被 Spring 管理的 Java 对象都被称之为 Bean；而 Spring 提供了一个 IoC 容器用来初始化对象，解决对象间的依赖管理和对象的使用。 1. Spring 的模块Spring 是模块化的，这意味着你可以只使用你需要的Spring的模块。如下图所示： 图中的每个最小单元，Spring 都至少有一个对应的 jar 包。 （1）核心容器（Core Contariner） Spring-Core：核心工具类，Spring 其他模块大量使用 Spring-Core Spring-Beans：Spring 定义 Bean 的支持 Spring-Context：运行时 Spring 容器 Spring-Context-Support：容器对第三方包的集成支持 Spring-Expression：使用表达式语言在运行时查询和操作对象 （2）AOP Spring-AOP：基于代理的 AOP 支持 Spring-Aspects：基于 AspectJ 的 AOP 支持 （3）消息（Messaging） Spring-Messaging：对消息架构和协议的支持 （4）Web Spring-Web：提供基础的 Web 集成的功能，在 Web 项目中提供 Spring 的容器 Spring-Webmvc：提供基于 Servlet 的 Spring MVC Spring-WebSocket：提供 WebSocket 功能 Spring-Webmvc-Portlet：提供 Portlet 环境功能 （5）数据访问/集成（Data Access/Integration） Spring-JDBC：提供以 JDBC 访问数据库的支持 Spring-TX：提供编程式和声明式的事务支持 Spring-ORM：提供对对象/关系映射技术的支持 Spring-OXM：提供对对象/xml 映射技术的支持 Spring-JMS：提供对 JMS 的支持 1. Spring 的生态Spring 发展到现在已经不仅仅是 Spring 框架本身的内容，Spring 目前提供了大量的基于 Spring 的项目，可以用来更深入地降低我们的开发难度，提高开发效率。目前 Spring 的生态里主要有以下项目，我们可以根据自己项目的需要来选择使用相应的项目。 Spring Boot：使用默认开发配置来实现快速开发 Spring XD：用来简化大数据应用开发 Spring Cloud：为分布式系统开发提供工具集 Spring Data：对主流关系型和 NoSQL 数据库的支持 Spring Integration：通过消息机制对企业集成模式（EIP）的支持 Spring Batch：简化及优化大量数据的批处理操作 Spring Security：通过认证和授权保护应用 Spring HATEOAS：基于 HATEOAS 原则简化 REST 服务开发 Spring Social：与社交网络 API（如：Facebook、新浪微博等）的集成 Spring AMQP：对基于 AMQP 的消息的支持 Spring Mobile：提供对手机设备检测的功能，给不同的设备返回不同的页面的功能 Spring for Android：主要提供在 Android 上消费 RESTful API 的功能 Spring Web Flow：基于 SpringMVC 提供基于向导流程式的 Web 应用开发 Spring Web Services：提供了基于协议有限的 SOAP/Web 服务 Spring LDAP：简化使用 LDAP 开发 Spring Session：提供一个 API 及实现来管理用户会话信息 二、Spring 项目快速搭建这里我们使用目前 Java 主流的项目构建工具Maven来搭建项目。 （一）Maven 介绍Apache Maven 是一个基于项目对象模型（Project Object Model，POM）的软件项目管理工具。Maven 可用来管理项目的依赖、编译、打包、文档等信息。使用 Maven 来管理项目时，项目依赖的 jar 包将不再包含在项目内，而是集中放置在用户目录下的 .m2 文件夹下。关于 Maven 的详细安装介绍可参考这里。 （二）创建项目在创建项目之前，须确保你的计算机上已经安装好有 Java 和 Maven 环境。然后，打开终端通过以下简单的命令就可以在你的当前目录下创建一个 Jave web 的项目结构： 1mvn archetype:generate -DgroupId=com.blinkfox -DartifactId=springdemo -DpackageName=com.blinkfox.springdemo -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false 其中-DgroupId=com.blinkfox是组织名，-DartifactId=springdemo是该组织下的项目名称，-DarchetypeArtifactId=maven-archetype-webapp代表创建一个简单的 webapp 项目。 创建项目的时候，Maven会自动下载一些需要用到的 jar 包和 Maven 插件。如果顺利创建成功的话，就会在你的当前目录下看到名为 springdemo 的项目，其中包含src的文件夹和pom.xml文件。且在你的终端会看到如下输出： （三）添加 Spring 依赖接下来需要通过修改 pom.xml 来添加 Spring 的依赖，添加编译插件，且将编译级别设置为1.7，pom.xml文件的修改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.blinkfox&lt;/groupId&gt; &lt;artifactId&gt;springdemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springdemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springdemo&lt;/finalName&gt; &lt;!-- 指定maven的默认操作为 --&gt; &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 三、Spring 基础配置Spring 框架本身有四大原则： 使用 POJO 进行轻量级和最小侵入式开发 通过依赖注入和面向接口编程来实现松耦合 通过 AOP 和默认习惯进行声明式编程 使用 AOP 和模板(template)减少模式化代码 Spring 的所有功能设计和实现都是基于此四大原则。 （一）依赖注入1. 重点说明我们经常说的控制反转（Inversion of Control，IoC）和依赖注入（dependency injection，DI）在 Spring 环境下是等同的概念，控制反转是通过依赖注入实现的。所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。 依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。如果你希望你的类具备某项功能的时候，是继承自一个具有此功能的父类好呢？还是组合另外一个具有这个功能的类好呢？答案是不言而喻的，继承一个父类，之类将与父类耦合，组合另外一个类则使耦合度大大降低。 Spring IoC 容器（ApplicationContext）负责创建 Bean，并通过容器将功能类 Bean 注入到你需要的 Bean 中。Spring 提供使用 xml、注解、Java 配置、groovy 配置实现 Bean 的创建和注入。 无论是 xml 配置、注解配置还是 Java 配置，都被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行的能力，只能通过外界代码来对这些元数据行解析后进行一些有意义操作。Spring 容器解析这些配置元数据进行 Bean 初始化、配置和管理依赖。 声明 Bean 的注解： @Component: 组件，没有明确角色 @Controller: 在展现层（MVC -&gt; Spring MVC）使用 @Service: 在业务逻辑层（service层）使用 @Repository: 在数据访问层（dao层）使用 注入 Bean 的注解，一般情况下通用： @Autowired: Spring 提供的注解 @Inject: JSR-330 提供的注解 @Resource: JSR-250 提供的注解 @Autowired、@Inject、@Resource可注解在 set 方法上或者属性上，推荐注解在属性上，优点是代码更少、层次更清晰。 2. 代码示例（1）编写功能类的 Bean。 123456789101112131415package com.blinkfox.service.impl;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/27. */@Servicepublic class FunctionService &#123; public String sayHello(String word) &#123; return "Hello " + word + "!"; &#125;&#125; 代码解释： 使用 @Service 注解声明当前 FunctionService 类是 Spring 管理的一个 Bean。其中，使用 @Component、@Service、@Repository、@Controller 是等效的，可根据需要选用。 （2）使用功能类的 Bean。 1234567891011121314151617181920package com.blinkfox.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/27. */@Servicepublic class UseFunctionService &#123; @Autowired private FunctionService functionService; public String sayHello(String word) &#123; return functionService.sayHello(word); &#125;&#125; 代码解释： 使用 @Service 注解声明当前 UseFunctionService 类是 Spring 管理的一个 Bean。 使用 @Autowired 将 FunctionService 的实体 Bean 注入到 UseFunctionService 中，让 UseFunctionService 具备 FunctionService 的功能，此处使用 JSR-330 的 @Inject 注解或者 JSR-250 的 @Resource 注解是等效的。 （3）配置类。 123456789101112package com.blinkfox.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * Created by blinkfox on 2016/10/27. */@Configuration@ComponentScan("com.blinkfox.service.impl")public class DiConfig &#123;&#125; 代码解释： 使用 @Configuration 注解声明当前类是一个配置类。 使用 @ComponentScan 将 自动扫描包名下所有使用的 @Component、@Service、@Repository、@Controller 类，并注册为 Bean。 （4）运行。 1234567891011121314151617181920package com.blinkfox.maintest;import com.blinkfox.config.DiConfig;import com.blinkfox.service.impl.UseFunctionService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/27. */public class FunctionMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DiConfig.class); UseFunctionService useFunctionService = context.getBean(UseFunctionService.class); System.out.println(useFunctionService.sayHello("Spring")); context.close(); &#125;&#125; 代码解释： 使用 AnnotationConfigApplicationContext 作为 Spring 容器，接收使用一个配置类作为参数。 获得声明配置的 UseFunctionService 的 Bean。 （二）Java 配置1. 重点说明Java 配置是 Spring4.x 推荐的配置方式，可以完全替代 xml 配置；Java 配置也是 Spring Boot 推荐的配置方式。 Java 配置是通过 @Configuration 和 @Bean 来实现的。 @Configuration 声明当前类是一个配置类，相当于一个Spring配置的 xml 文件。 @Bean 注解在方法上，声明当前方法的返回值是一个 Bean。 何时使用 Java 配置或者注解配置呢？我们主要的原则是：全局配置使用 Java 配置（如数据库相关配置、MVC相关配置），业务 Bean 的配置使用注解配置（@Service、@Component、@Repository、@Controller）。 2. Java配置代码示例（1）编写功能类的 Bean 12345678910111213package com.blinkfox.service.impl;/** * Created by blinkfox on 2016/10/27. */// 1public class JavaConfigService &#123; public String sayHello(String word) &#123; return "Hello " + word + "!"; &#125;&#125; 代码解释： 此处没有使用 @Service 声明 Bean。 （2）使用功能类的 Bean 12345678910111213141516171819package com.blinkfox.service.impl;/** * Created by blinkfox on 2016/10/27. */// 1public class UseJavaConfigService &#123; // 2 private JavaConfigService javaConfigService; public void setJavaConfigService(JavaConfigService javaConfigService) &#123; this.javaConfigService = javaConfigService; &#125; public String sayHello(String word) &#123; return javaConfigService.sayHello(word); &#125;&#125; 代码解释： 此处没有使用 @Service 声明 Bean。 此处没有使用 @Autowired 注解注入 Bean。 （3）Java 配置类 1234567891011121314151617181920212223242526package com.blinkfox.config;import com.blinkfox.service.impl.JavaConfigService;import com.blinkfox.service.impl.UseJavaConfigService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by blinkfox on 2016/10/27. */@Configuration // 1public class JavaConfig &#123; @Bean // 2 public JavaConfigService javaConfigService() &#123; return new JavaConfigService(); &#125; @Bean public UseJavaConfigService useJavaConfigService() &#123; UseJavaConfigService useJavaConfigService = new UseJavaConfigService(); useJavaConfigService.setJavaConfigService(javaConfigService()); // 3 return useJavaConfigService; &#125;&#125; 代码解释： 使用 @Configuration 注解表明当前类是一个配置类，这意味着这个类型里可能有0个或者多个 @Bean 注解，此处没有使用包扫描，是因为所有的 Bean 都在此类中定义了。 使用 @Bean 注解声明当前方法 JavaConfigService 的返回值是一个 Bean，Bean的名称是方法名。 注入 FunctionService 的 Bean 时候直接调用 javaConfigService()。 （4）运行 1234567891011121314151617181920package com.blinkfox.maintest;import com.blinkfox.config.JavaConfig;import com.blinkfox.service.impl.UseJavaConfigService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/27. */public class JavaConfigMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class); UseJavaConfigService useJavaConfigService = context.getBean(UseJavaConfigService.class); System.out.println(useJavaConfigService.sayHello("Spring Java Config")); context.close(); &#125;&#125; （三）AOP1. 重点说明AOP：面向切面编程，是面向对象编程（OOP）的补充。 Spring 的 AOP 的存在目的是为了解耦。AOP 可以让一组类共享相同的行为。在 OOP 中只能通过继承和实现接口来共享相同的行为，从而使代码的耦合度增强，且类继承只能为单继承，阻碍更多行为添加到一组类上，AOP 弥补了 OOP 的不足。 Spring 支持 AspectJ 的注解式切面编程。 使用 @AspectJ 声明是一个切面。 使用 @After、@Before、Around 定义通知（advice）类型，可直接将拦截规则（切点）作为参数。 其中 @After、@Before、Around 参数的拦截规则为切点（PointCut），为了使切点复用，可使用 @PointCut 专门定义拦截规则，然后在 @After、@Before、Around 的参数中调用。 其中符合条件的每一个拦截处为连接点（JoinPoint）。 Spring本身在事务处理（@Transcational）和数据缓存（@Cacheable）等都使用注解拦截。下面示例将演示基于注解和方法规则的拦截方式，演示一种模拟记录操作的日志系统的实现。 2. 注解拦截代码示例（1）添加 Spring aop 支持及 AspectJ 依赖。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt; （2）编写拦截规则的注解。 123456789101112131415package com.blinkfox.annotation;import java.lang.annotation.*;/** * Created by blinkfox on 2016/10/29. */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LogAction &#123; String name() default "这是默认的操作名称";&#125; 代码解释：注解本身是没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓的配置。注解的功能来自用这个注解的地方。 （3）编写使用注解的被拦截类。 1234567891011121314151617package com.blinkfox.service.impl;import com.blinkfox.annotation.LogAction;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/29. */@Servicepublic class DemoAnnotationService &#123; @LogAction(name = "注解式拦截的 add 操作") public void add() &#123; &#125;&#125; （4）编写使用方法规则被拦截规类。 123456789101112131415package com.blinkfox.service.impl;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/29. */@Servicepublic class DemoMethodService &#123; public void add() &#123; &#125;&#125; （5）编写切面。 12345678910111213141516171819202122232425262728293031323334353637383940package com.blinkfox.aop;import com.blinkfox.annotation.LogAction;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;/** * Created by blinkfox on 2016/10/29. */@Aspect // 1@Component // 2public class LogAspect &#123; @Pointcut("@annotation(com.blinkfox.annotation.LogAction)") // 3 public void annotationPointCut() &#123; &#125; @After("annotationPointCut()") // 4 public void after(JoinPoint joinPoint) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); LogAction logAction = method.getAnnotation(LogAction.class); System.out.println("---注解式拦截:" + logAction.name()); // 5 &#125; @After("execution(* com.blinkfox.service.impl.DemoMethodService.*(..))") // 6 public void before(JoinPoint joinPoint) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); System.out.println("---方法规则式拦截:" + method.getName()); &#125;&#125; 代码解释： 通过 @Aspect 注解声明一个切面。 通过 @Component 让此切面成为 Spring 容器管理的Bean。 通过 @PointCut 注解声明切点。 通过 @After 注解声明一个通知类型，并使用 @PointCut定义的切点。 通过可获得注解上的属性，然后做日志记录相关的操作，下面相同。 通过 @Before 注解声明一个通知类型，此通知直接使用拦截规则作为参数。 （6）配置类。 123456789101112131415package com.blinkfox.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;/** * Created by blinkfox on 2016/10/29. */@Configuration@ComponentScan("com.blinkfox")@EnableAspectJAutoProxypublic class AopConfig &#123;&#125; 代码解释： 使用 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ的支持。 （6）运行。 1234567891011121314151617181920212223package com.blinkfox.maintest;import com.blinkfox.config.AopConfig;import com.blinkfox.service.impl.DemoAnnotationService;import com.blinkfox.service.impl.DemoMethodService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/29. */public class AopMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class); DemoMethodService demoMethodService = context.getBean(DemoMethodService.class); demoAnnotationService.add(); demoMethodService.add(); context.close(); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之工厂方法模式]]></title>
    <url>%2F2018%2F09%2F14%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 二、模式结构1. 角色组成工厂方法模式包含如下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 2. 结构图 3. 时序图 三、示例代码首先，是抽象的产品类和具体的产品类： 12345678910111213141516171819/** * 抽象产品类 * Created by blinkfox on 16-6-29. */public abstract class Product &#123; /** * 产品类的公共方法 */ public void method1() &#123; System.out.println("这是产品类的公共方法"); &#125; /** * 抽象方法 */ public abstract void method2();&#125; 123456789101112/** * 具体产品类1 * Created by blinkfox on 16-6-29. */public class ConcreteProduct1 extends Product &#123; @Override public void method2() &#123; System.out.println("ConcreteProduct1的method2方法"); &#125;&#125; 123456789101112/** * 具体产品类2 * Created by blinkfox on 16-6-29. */public class ConcreteProduct2 extends Product &#123; @Override public void method2() &#123; System.out.println("ConcreteProduct2的method2方法"); &#125;&#125; 然后，是抽象的工厂类和具体的工厂类： 12345678910111213141516/** * 抽象的工厂类 * Created by blinkfox on 16-6-29. */public abstract class Factory &#123; /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T&gt; * @return */ public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);&#125; 1234567891011121314151617181920212223242526/** * 具体生产产品的工厂类 * Created by blinkfox on 16-6-29. */public class ConcreteFactory extends Factory &#123; /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T&gt; * @return */ @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; System.out.println("生产产品出错"); e.printStackTrace(); &#125; return (T) product; &#125;&#125; 最后，是客户端场景类： 123456789101112131415161718/** * 工厂方法模式客户端场景类 * Created by blinkfox on 16-6-29. */public class Client &#123; public static void main(String[] args) &#123; Factory factory = new ConcreteFactory(); Product product1 = factory.createProduct(ConcreteProduct1.class); product1.method1(); product1.method2(); Product product2 = factory.createProduct(ConcreteProduct2.class); product2.method1(); product2.method2(); &#125;&#125; 四、模式分析在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 1. 优点工厂方法模式的优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 2. 缺点工厂方法模式的缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 3. 适用环境在以下情况下可以使用工厂方法模式： 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 五、模式扩展工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。 1. 简单工厂模式我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下： 12345678910111213141516171819202122232425/** * 简单工厂模式中的工厂类 * Created by blinkfox on 16-6-29. */public class SimpleFactory &#123; /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T&gt; * @return */ public static &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; System.out.println("生产产品出错"); e.printStackTrace(); &#125; return (T) product; &#125;&#125; 1234567891011121314151617/** * 简单工厂模式客户端场景类 * Created by blinkfox on 16-6-29. */public class SimpleClient &#123; public static void main(String[] args) &#123; Product product1 = SimpleFactory.createProduct(ConcreteProduct1.class); product1.method1(); product1.method2(); Product product2 = SimpleFactory.createProduct(ConcreteProduct2.class); product2.method1(); product2.method2(); &#125;&#125; 运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。 2. 多工厂类工厂方法模式当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下： 多工厂模式的抽象工厂类： 12345678910111213/** * 生成多个产品的抽象工厂类 * Created by blinkfox on 16-7-2. */public abstract class MultiFactory &#123; /** * 生成某种产品的方法 * @return */ public abstract Product createProduct();&#125; 第一种产品的创建工厂实现： 12345678910111213141516/** * 生成产品1的具体工厂类1 * Created by blinkfox on 16-7-2. */public class ConcreteFactory1 extends MultiFactory &#123; /** * 生成产品1的方法 * @return */ @Override public Product createProduct() &#123; return new ConcreteProduct1(); &#125;&#125; 第二种产品的创建工厂实现： 12345678910111213141516/** * 生成产品2的具体工厂类2 * Created by blinkfox on 16-7-2. */public class ConcreteFactory2 extends MultiFactory &#123; /** * 生成产品2的方法 * @return */ @Override public Product createProduct() &#123; return new ConcreteProduct2(); &#125;&#125; 多工厂模式的客户端场景类 1234567891011121314151617/** * 多工厂方法模式客户端场景类 * Created by blinkfox on 16-7-2. */public class MultiClient &#123; public static void main(String[] args) &#123; Product concreteProduct1 = (new ConcreteFactory1()).createProduct(); concreteProduct1.method1(); concreteProduct1.method2(); Product concreteProduct2 = (new ConcreteFactory2()).createProduct(); concreteProduct1.method1(); concreteProduct1.method2(); &#125;&#125; 3. 工厂方法的单例模式单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。 下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下： 12345678910111213141516171819/** * 工厂方法模式中的单例类 * Created by blinkfox on 16-7-4. */public class Singleton &#123; /** * 私有化构造方法，不允许new产生一个对象 */ private Singleton() &#123;&#125; /** * 工厂方法模式中的单例模式业务方法 */ public void doSomething() &#123; System.out.println("工厂方法模式中的单例模式方法。。。"); &#125;&#125; 以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下： 123456789101112131415161718192021222324252627/** * 生成单例的工厂类 * Created by blinkfox on 16-7-4. */public class SingletonFactory &#123; private static Singleton singleton; static &#123; try &#123; Class c = Class.forName(Singleton.class.getName()); // 获得无参构造 Constructor constructor = c.getDeclaredConstructor(); // 设置无参构造是可访问的 constructor.setAccessible(true); // 产生一个实例对象 singleton = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("生成单例的工厂类方法中生成单例出错");zuihou &#125; &#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 最后是工厂方法单例模式的客户端场景类： 123456789101112/** * 工厂方法单例模式客户端场景类 * Created by blinkfox on 16-7-4. */public class SingleClient &#123; public static void main(String[] args) &#123; Singleton singleton = SingletonFactory.getSingleton(); singleton.doSomething(); &#125;&#125; 4. 工厂方法的延迟初始化何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下： 1234567891011121314151617181920212223242526272829/** * 延迟加载的工厂类 * Created by blinkfox on 16-7-4. */public class LazyFactory &#123; private static final Map&lt;String, Product&gt; lazyMap = new HashMap&lt;String, Product&gt;(); public static synchronized Product createProduct(String type) &#123; Product product = null; // 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中 if (lazyMap.containsKey(type)) &#123; return lazyMap.get(type); &#125; // 根据类型创建具体的产品对象 if ("product1".equals(type)) &#123; product = new ConcreteProduct1(); &#125; else &#123; product = new ConcreteProduct2(); &#125; // 同时把对象放到缓存容器中 lazyMap.put("type", product); return product; &#125;&#125; 上面即为延迟加载的工厂类。代码比较简单，通过定义一个map容器来容纳所有产生的对象，如果在map容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到map容器中，以便下次调用。 延迟加载的工厂模式客户端场景类代码如下： 12345678910111213/** * 延迟加载的工厂模式客户端场景类 * Created by blinkfox on 16-7-4. */public class LazyClient &#123; public static void main(String[] args) &#123; Product product1 = LazyFactory.createProduct("product1"); Product product11 = LazyFactory.createProduct("product1"); &#125;&#125; 六、总结 工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之装饰模式]]></title>
    <url>%2F2018%2F09%2F14%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机一般有两种方式可以实现给一个类或对象增加行为： 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator) 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。 二、模式定义 装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。 策略模式是一种对象结构型模式。 三、 模式结构装饰模式包含如下角色： Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 结构图 时序图 四、示例代码首先定义一个抽象构件接口： 12345678910/** * 抽象构件 * Created by blinkfox on 16-6-26. */public interface Component &#123; // 接口方法 void operate();&#125; 然后是具体构件实现类： 123456789101112131415/** * 具体构件 * Created by blinkfox on 16-6-26. */public class ConcreteComponent implements Component &#123; /** * 具体实现方法 */ @Override public void operate() &#123; System.out.println("do Something..."); &#125;&#125; 接着是装饰角色： 1234567891011121314151617181920212223242526/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * Created by blinkfox on 16-6-26. */public class Decorator implements Component &#123; private Component component; /** * 通过构造函数传递被修饰者 * @param component */ public Decorator(Component component) &#123; this.component = component; &#125; /** * 委托给被修饰者执行 */ @Override public void operate() &#123; this.component.operate(); &#125;&#125; 下面是具体的装饰类： 123456789101112131415161718192021222324252627282930/** * 具体的装饰类1 * Created by blinkfox on 16-6-26. */public class ConcreteDecorator1 extends Decorator &#123; /** * 通过构造函数传递被修饰者 * @param component */ public ConcreteDecorator1(Component component) &#123; super(component); &#125; /** * 定义自己的修饰方法1 */ private void method1() &#123; System.out.println("method1修饰..."); &#125; /** * 重写父类的operate方法 */ public void operate() &#123; this.method1(); super.operate(); &#125;&#125; 123456789101112131415161718192021222324252627282930/** * 具体的装饰类2 * Created by blinkfox on 16-6-26. */public class ConcreteDecorator2 extends Decorator &#123; /** * 通过构造函数传递被修饰者 * @param component */ public ConcreteDecorator2(Component component) &#123; super(component); &#125; /** * 定义自己的修饰方法2 */ private void method2() &#123; System.out.println("method2修饰..."); &#125; /** * 重写父类的operate方法 */ public void operate() &#123; this.method2(); super.operate(); &#125;&#125; 最后是客户端的场景类： 1234567891011121314151617181920/** * 装饰模式的客户端场景类 * Created by blinkfox on 16-6-26. */public class Client &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); // 第一修饰 component = new ConcreteDecorator1(component); // 第二修饰 component = new ConcreteDecorator2(component); // 修饰后运行 component.operate(); &#125;&#125; 五、模式分析总体分析 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。 优点装饰模式的优点： 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。 缺点装饰模式的缺点： 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 适用环境在以下情况下可以使用装饰模式： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。 模式扩展装饰模式的简化-需要注意的问题: 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。 六、总结 装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。 装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。 装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。 装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象设计之策略模式]]></title>
    <url>%2F2018%2F09%2F14%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。 在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。 除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。 二、模式定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 策略模式是一种对象行为型模式。 三、 模式结构策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 结构图 时序图 四、示例代码首先定义一个策略接口： 12345678public interface IStrategy &#123; /** * 策略模式的运算法则 */ public void doSomething();&#125; 然后是具体的策略实现类： 12345678public class ConcreteStrategy1 implements IStrategy &#123; @Override public void doSomething() &#123; System.out.println("具体策略的策略方法1"); &#125;&#125; 12345678public class ConcreteStrategy2 implements IStrategy &#123; @Override public void doSomething() &#123; System.out.println("具体策略的策略方法2"); &#125;&#125; 接着是封装角色的类： 123456789101112131415161718192021public class Context &#123; // 抽象策略 private IStrategy strategy; /** * 构造函数设置具体策略 * @param strategy */ public Context(IStrategy strategy) &#123; this.strategy = strategy; &#125; /** * 封装后的策略方法 */ public void doAnything() &#123; this.strategy.doSomething(); &#125;&#125; 最后是客户端的调用策略类： 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; // 声明一个具体的策略 IStrategy strategy = new ConcreteStrategy1(); // 声明上下文对象 Context context = new Context(strategy); // 执行封装后的方法 context.doAnything(); &#125;&#125; 五、模式分析总体分析 策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。 策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。 优点策略模式的优点： 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 缺点策略模式的缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 适用环境在以下情况下可以使用策略模式： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。 模式扩展策略模式与状态模式： 可以通过环境类状态的个数来决定是使用策略模式还是状态模式。 策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。 使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。 如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。 六、总结 在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。 策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。 策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。 策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。 策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础教程]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJavaScript%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、JavaScript介绍JavaScript是目前所有主流浏览器上唯一支持的脚本语言，这也是早期JavaScript的唯一用途。其主要作用是在不与服务器交互的情况下修改HTML页面内容，因此其最关键的部分是DOM（文档对象模型），也就是HTML元素的结构。通过Ajax可以使HTML页面通过JavaScript，在不重新加载页面的情况下从服务器上获取数据并显示，大幅提高用户体验。通过JavaScript，使Web页面发展成胖客户端成为可能。 语言的性质本节对JavaScript的性质做简要介绍，以帮你理解一些疑问。 JavaScript和ECMAScript（JavaScript versus ECMAScript）编程语言称为JavaScript，语言标准被称为ECMAScript。他们有不同名字的原因是因为“Java”已经被注册为商标（属于Oracle）。目前，只有Mozilla被正式允许使用“JavaScript”名称，因为很久以前他们得到一份许可。因此，开放的语言标准拥有不同的名字。当前的JavaScript版本是ECMAScript 6，ECMAScript 7当前是开发版。 JavaScript之父，Brendan Eich迅速了创建一门编程语言。（否则，Netscape将使用其他技术）。他借鉴了几门其他语言的一些特性： JavaScript借鉴了Java的语法和如何区分原始值和对象。 JavaScript的函数设计受Scheme和AWK的启发——他们（的函数）都是第一类（first-class）对象，并且在语言中广泛使用。闭包使他们（函数）变成强大的工具。 Self影响了JavaScript独一无二的面向对象编程(OOP)风格。它的核心思想（在这里我们没有提到）非常优雅，基于此创建的语言非常少。但后面会提到一个简单的模式照顾大部分用例。JavaScript面向对象编程的杀手级特性是你可以直接创建对象。不需要先创建类或其他类似的东西。 Perl和Python影响了JavaScript字符串，数组和正则表达式的操作。 JavaScript在最初的时候并不是一个完善的语言，因此也导致JavaScript遗留了很多令人诟病的问题。在开发稍大规模的应用时会显得力不从心，但是由于JavaScript本身是一种非常灵活的语言，因此在它的基础上开发程序库比较容易，因此出现了一大批非常优秀的第三方库，如jQuery，ExtJS，underscorejs，backbone等等，由于这些第三方库，JavaScript变得非常简单。其中jQuery的使用非常广泛，它大幅简化了DOM和Ajax，已经成为了很多网站的标配。jQuery虽然基于JavaScript，但它提供了另外一种编程范式，也就是逻辑式编程，与SQL和正则表达式类似。 JavaScript能做什么 如上图，JavaScript作为Github上最流行、最火的编程语言，几乎无所不能。这里是PuYart的关于JavaScript就要统治世界了的文章，可以让我们了解JavaScript到底能做什么的一些介绍。 Web前端(各种前端工具类库、前端框架、动画效果、数据可视化等) 服务端开发(Node.js) 移动应用或者Hybrid App(Cordova) 桌面应用(NW.js、Electron) 游戏(Unity3D、Cocos2d-js、Pomelo) VR(JavaScript在VR世界的应用) 硬件、嵌入式物联网等(Tessel：用JavaScript做嵌入式开发) 操作系统(NodeOS) Atwood’s Law: any application that can be written in JavaScript, will eventually be written in JavaScript.(Atwood定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。) 二、 JavaScript语法语句和表达式了解JavaScript的语法，先来了解两个主要的语法类型：语句和表达式。 语句通常是“做某些事情”。程序是一组语句的序列。举个例子，下面声明（创建）一个变量 foo： 1var foo; 表达式是产生“值”。他们通常位于赋值操作的右边、函数参数等。举个例子： 13 * 7 语句和表达式之间的区别最好通过实例说明，JavaScript（像Java）有两种不同的方式实现if-then-else。一种是用语句： 123456var x;if (y &gt;= 0) &#123; x = y;&#125; else &#123; x = -y;&#125; 另一种是表达式： 1var x = y &gt;= 0 ? y : -y; 你可以将后者作为函数参数（但前者不行）： 1myFunction(y &gt;= 0 ? y : -y) 最后，每当JavaScript期待一个语句，你也可以用一个表达式代替。例如： 1foo(bar(7, 1)); foo(...);是一个语句（也叫做表达式语句），bar(7, 1)则是一个表达式。他们都实现函数调用。 流程控制语句和语句块流程控制语句，其语句体可以是单条语句。举两个例子： 123if (obj !== null) obj.foo();while (x &gt; 0) x--; 然而，任何语句总能被语句块代替，花括号包含零或多条语句。因此，你也可以这样写： 1234567if (obj !== null) &#123; obj.foo();&#125;while (x &gt; 0) &#123; x--;&#125; 为便于程序的阅读和维护，推荐使用后一种方式，即语句块方式。 分号JavaScript中的分号是可选的。但省略（分号）可能会带来意想不到的结果，所以我建议还是写上分号。 正如上面所看到的，分号作为语句的结尾，但语句块不需要。仅有一种情况下你能看到语句块后面有分号——函数表达式后面的函数体块。表达式作为语句的结尾，后面是分号： 12var x = 3 * 7;var f = function () &#123; &#125;; 注释JavaScript的注释有两种形式：单行注释和多行注释。单行注释以//开头，以换行符结尾： 1x++; // 单行（single-line）注释 多行注释用/**/包裹 1234/* 这是多行注释 多行哦 */ 三、变量和赋值JavaScript中的变量在使用前必须先声明，否则会报错引用错误（Reference Error）： 1var foo; // 声明变量“foo” 赋值你可以在声明变量的同时为其赋值： 1var foo = 6; 你也可以给已经存在的变量重新赋值： 1foo = 4; // 更改变量的值 复合赋值操作符有很多复合赋值操作符，例如+=。下面的两个赋值操作等价： 12x += 1;x = x + 1; 标识符和变量名标识符就是事物的名字，在JavaScript中他们扮演不同的语法角色。例如，变量的名称是一个标识符。 大体上，标识符的第一个字符可以是任何Unicode字符、美元标志符（$）或下划线（_）。后面可以是任意字符和数字。因此，下面全是合法的标识符： 1234arg0_tmp$elemπ 注意：首字符不能是数字，如果是数字的话，该如何区分是数字还是变量呢？ 一些标识符是“保留关键字”——他们是语法的一部分，不能用作变量名。从技术上讲，下面三个标识符不是保留字，但也不应该作为变量名： 1Infinity NaN undefined 四、值JavaScript有所有我们期待的编程语言值类型：布尔，数字，字符串，数组等。JavaScript中的所有值都有属性。每个属性有一个键（或名字）和一个值。你可以使用点（.）操作符读取属性： 1value.propKey 举个例子：字符串abc有属性lenght（长度） 12var str = 'abc';console.log(str.length); // 得到3 上面的代码也可以写成下面这样： 1'abc'.length // 得到3 点操作符也可以用来给属性赋值： 123var obj = &#123;&#125;; // 空对象obj.foo = 123; // 创建属性“foo”，设置它为123console.log(obj.foo); // 得到123 你也可以通过它（.）调用方法： 1'hello'.toUpperCase(); // 得到HELLO 上面，我们在值hello上面调用方法toUpperCase()。 原始类型值和对象JavaScript定义了不同值之间的区别： 原始值包括：boolean，number，string，null和undefined。 所有其他的值都是对象。实际上对象被定义为——所有不为原始值的值。 两者之间的主要区别在于他们是如何被比较的：每一个对象有一个独一无二的标志，并且仅和自己相等： 1234var obj1 = &#123;&#125;; // 一个空对象var obj2 = &#123;&#125;; // 另一个空对象obj1 === obj2 // falseobj1 === obj1 // true 相反，所有原始值只要编码值相同就被认为是相同的： 123var prim1 = 123;var prim2 = 123;prim1 === prim2 // true 原始类型值下面全是原始类型值（简称：原始值）： 布尔类型：true，false 数字类型：1736，1.351 字符串类型: ‘abc’，”abc” 两个“无值（non-values）”：undefined，null原始值的特征： 值做比较时,“内容”做比较。 123 === 3 // true'abc' === 'abc' // true 无法更改：值的属性无法更改，无法添加和移除属性，获取未知属性总返回undefined。 123var str = 'abc';str.foo = 3; // try to create property `foo` ⇒ no effectstr.foo // unknown property ⇒ undefined 对象对象的类型所有非原始值的值都是对象。最常见的几种对象类型是： 简单对象（类型是Object）能通过对象字面量创建： 1234&#123; firstName: ‘Jane’, lastName: ‘Doe’&#125; 上面的对象有两个属性：firstName属性的值是“Jane”，lastName属性的值是“Doe”。 数组（类型是Array）能通过数组字面量创建： 1[ ‘apple’, ‘banana’, ‘cherry’ ] 上面的数组有三个元素，可以通过数字索引访问。例如“apple”的索引是0。 正则表达式对象（类型是RegExp）能通过正则表达式字面量创建。 1/^a+b+$/ 对象的特征 比较的是引用：比较的是标识符，每个值有自己的标识符。 1234&#123;&#125; === &#123;&#125; // 两个不同的空对象, falsevar obj1 = &#123;&#125;;var obj2 = obj1;obj1 === obj2 // true 默认可以更改。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo //123 所有的数据结构（如数组）都是对象，但并不是所有的对象都是数据结构。例如：正则表达式是对象，但不是数据结构。 undefined 和 nullJavaScript有两个“无值）”：undefined和null。 undefined的意思是“没有值”。未初始化的变量是undefined： 12var foo;foo // undefined 读取不存在的属性时，将返回undefined： 12&gt; var obj = &#123;&#125;; // 空对象&gt; obj.foo // undefined 缺省的参数也是undefined： 1234function f(x) &#123; return x;&#125;f(); //undefined null的意思是“没有对象”。它被用来表示对象的无值（参数，链上的对象等）。 通常情况下你应该把undefined和null看成是等价的，如果他们代表相同意义的无值的话。检查他们的一种方式是通过严格比较： 123if (x === undefined || x === null) &#123; ...&#125; 另一种在实际中使用的方法是认为undefined 和 null 都是false： 123if (!x) &#123; ...&#125; 警告：false，0，NaN 和 “” 都被当作false。 包装类型对象类型的实例Foo（包括内建类型，例如Array和其他自定义类型）从对象Foo.prototype上获取方法。你可以通过读取这个方法的方式（不是调用）验证这点： 1[].push === Array.prototype.push // true 相反，原始类型是没有类型的，所以每个原始类型有一个关联类型，称之为包装类型： 布尔值的包装类型是 Boolean。布尔值从Boolean.prototype上获取方法： 1&gt; true.toString === Boolean.prototype.toString //true 注意：包装类型名字的首字母是大写的B。如果在JavaScript中布尔值的类型可以访问，那么它可能会被转换为布尔对象。 数字值的包装类型是Number。 字符串值的包装类型是String。 包装类型也有实例（他们的实例是对象），但不常用。相反，包装类型有其他用处：如果你将他们作为函数调用，他们可以将值转换为原始类型。 12Number('123') //123String(true) //'true' 通过typeof和instanceof将值分类有两个操作符可以用来将值分类：typeof主要用于原始值，instanceof主要用于对象。 typeof 使用方法如下：typeof «value» typeof返回描述value“类型”的一个字符串。例如： 1234typeof true //'boolean'typeof 'abc' //'string'typeof &#123;&#125; // 空对象字面量,'object'typeof [] // 空数组字面量,'object' 下面列出了typeof操作的所有结果： 12345678操作数 结果undefined &apos;undefined&apos;null &apos;object&apos;Boolean value &apos;boolean&apos;Number value &apos;number&apos;String value &apos;string&apos;Function &apos;function&apos;All other values &apos;object&apos; 有两个结果和我们上面说的的原始值与对象是矛盾的： 函数的类型是function而不是object。因为函数（类型为“function”）是对象（类型是对象）的子类型，这不是一个错误。 null的类型是object。这是一个bug，但从没被修复，因为修复后会破坏现有的代码。 instanceof使用方法如下：«value» instanceof «Constr» 如果value是一个对象，并且value 是由构造函数Constr创建的（参考：类）。例如： 1234var b = new Bar(); // 通过构造函数Bar创建对象b instanceof Bar //true&#123;&#125; instanceof Object //true[] instanceof Array //true 深入阅读 探索JavaScript中Null和Undefined的深渊 五、布尔布尔类型原始值包括true和false。下面的操作符会得到布尔值： 二元逻辑运算符：&amp;&amp;（与），||（或） 前缀逻辑运算符：!（非） 等值运算符：=== !== == != 比较运算符（字符串或数字）：&gt; &gt;= &lt; &lt;= 真值和假值每当JavaScript希望一个布尔值时（例如：if语句的条件），可以使用任何值。它将被理解（转换）为true或false。下面的值被理解为false： undefined, null 布尔: false 数字: 0, NaN 字符串: ‘’ 所有其他值被认为true。被理解为false的值称为假值，被理解为true的值称为真值。可以使用Boolean作为函数，测试值被理解为什么。 123Boolean(undefined) //falseBoolean(0) //falseBoolean(3) //true 二元逻辑运算符JavaScript中的二元逻辑运算符是短路运算——如果第一个操作数可以确定结果，第二个操作数将不被验证（运算）。例如，在下面的代码中，函数foo()永远不会被调用。 12false &amp;&amp; foo()true || foo() 此外，二元逻辑运算符会返回操作数中的一个，可能是一个布尔值，也可能不是。 与：如果第一个操作数是假值，返回第一个。否则返回第二个操作数。 12NaN &amp;&amp; 'abc' //NaN123 &amp;&amp; 'abc' //'abc' 或：如果第一个操作数是真值，返回第一个。否则，返回第二个操作数。 12'abc' || 123 //'abc''' || 123 //123 等值运算符在JavaScript中检测相等，你可以使用严格相等（===）和严格不等（!==）。或者你也可以使用非严格相等（==）和非严格不等（!=）。 经验规则：总是用严格运算符，假装非严格运算符不存在。严格相等更安全。 深入阅读 在JavaScript中什么时候使用==是正确的？ 六、数字JavaScript中的所有数字都是浮点型（虽然大部分的JavaScript引擎内部也使用整数）。至于为什么这样设计，查看这里（每一个JavaScript开发者应该了解的浮点知识）。 11 === 1.0 //true 特殊数字： NaN (“不是一个数字 not a number”): 错误值。 1Number('xyz') // 'xyz' 不能被转换为数字得到:NaN Infinity：也是最大错误值（无穷大） 123 / 0 //InfinityMath.pow(2, 1024) // 数字太大了,得到Infinity Infinity有时很有用，因为它比任何其他数字都大。同样，-Infinity 比其他任何数字都小。 JavaScript有两个零，+0和-0。它（js引擎）通常不让你看到，并简单将两个零都显示为0： 12+0 //0-0 //0 因此最好假装只有一个零（正如我们看到假值时所做的那样：-0 和 +0 都是假值）。 运算符JavaScript中有下列算数运算符： 123456789加: number1 + number2减: number1 - number2乘: number1 * number2除: number1 / number2模: number1 % number2自增: ++variable, variable++自减: –variable, variable–负值: -value正值（转换为数字）: +value 全局对象Math通过函数提供更多算数运算操作。 JavaScript中也有位运算符（例如：&amp;）。 七、字符串字符串可以直接通过字符串字面量创建。这些字面量被单引号或双引号包裹。反斜线（\）转义字符并且产生一些控制字符。例如： 1234567891011'abc'"abc"'Did she say "Hello"?'"Did she say \"Hello\"?"'That\'s nice!'"That's nice!"'Line 1\nLine 2' // 换行'Backlash: \\' 可以通过方括号访问单个字符： 12var str = 'abc';str[1] //'b' length属性是字符串的字符数量。 1'abc'.length //3 提醒：字符串是不可变的，如果你想改变现有字符串，你需要创建一个新的字符串。 字符串运算符字符串可以通过加号操作符（+）拼接，如果其中一个操作数为字符串，会将另一个操作数也转换为字符串。 12var msgCount = 3;'You have '+ msgCount + ' messages' //'You have 3 messages' 连续执行拼接操作可以使用+=操作符： 12345var str = '';str += 'Multiple ';str += 'pieces ';str += 'are concatenated.';console.log(str); //'Multiple pieces are concatenated.' 字符串方法字符串有许多有用的方法。例如： 123456789'abc'.slice(1) // 复制子字符串,得到索引1及其之后的字符串，即：'bc''abc'.slice(1, 2) //得到索引1和2之间的字符串，即：'b''\t xyz '.trim() // 移除空白字符，即：'xyz''mjölnir'.toUpperCase() //转成大写，即：'MJÖLNIR''abc'.indexOf('b') // 查找第一个b的索引，即：1'abc'.indexOf('x') //没有返回-1 八、语句条件（Conditionals）if语句通过布尔条件决定执行那个分支： 12345678910111213141516171819if (myvar === 0) &#123; // then&#125;if (myvar === 0) &#123; // then&#125; else &#123; // else&#125;if (myvar === 0) &#123; // then&#125; else if (myvar === 1) &#123; // else-if&#125; else if (myvar === 2) &#123; // else-if&#125; else &#123; // else&#125; 下面的switch语句，furit的值决定那个分支被执行。 12345678910switch (fruit) &#123; case 'banana': // ... break; case 'apple': // ... break; default: // 所有其他情况 // ...&#125; 循环（Loops）for 循环的格式如下： 1for(初始化; 当条件成立时循环; 下一步操作) 例子： 123for (var i=0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; 当条件成立时while循环继续循环它的循环体。 123456// 和上面的for循环相等var i = 0;while (i &lt; arr.length) &#123; console.log(arr[i]); i++;&#125; 当条件成立时，do-while循环继续循环。由于条件位于循环体之后，所以循环体总是被至少至少执行一次。 123do &#123; // ...&#125; while(条件); 在所有的循环中： break中断循环 continue开始一个新的循环迭代 九、函数定义函数的一种方法是通过函数声明： 123function add(param1, param2) &#123; return param1 + param2;&#125; 上面的代码定义一个名称叫做add的函数，有两个参数param1和param2，并且返回参数的和。下面是如何调用这个函数： 12add(6, 1) //7add('a', 'b') //'ab' 另一种定义add()函数的方法是通过函数表达式： 123var add = function (param1, param2) &#123; return param1 + param2;&#125;; 函数表达式产生一个值，因此可以直接将函数作为参数传递给其他函数： 1someOtherFunction(function (p1, p2) &#123; ... &#125;); 函数声明提升函数声明会被提升，他们全被移动到当前作用域开始之处。这允许你在函数声明之前调用它们： 123456function foo() &#123; bar(); // 没问题，bar被提升 function bar() &#123; ... &#125;&#125; 注意：虽然变量声明也会被提升，但赋值的过程不会被提升： 123456function foo() &#123; bar(); // 有问题，bar是undefined var bar = function () &#123; // ... &#125;;&#125; 特殊变量参数在JavaScript中你可以调用任意函数并传递任意数量的参数——语言绝不会“抱怨”（参数检测）。都可以正常工作，然而，使所有参数可访问需要通过特殊变量arguments。arguments看起来像数组，但它没有数组的方法（称为类数组 array-like）。 1234function f() &#123; return arguments &#125;var args = f('a', 'b', 'c');args.length //3args[0] // 获取索引为0的元素,'a' 太多或太少参数让我们通过下面的函数探索JavaScript中传递太多或太少参数时如何处理 123function f(x, y) &#123; console.log(x, y);&#125; 多出的参数将被忽略（可以通过arguments访问）： 1f('a', 'b', 'c') //a b 缺少的参数将会是undefined： 12f('a') //a undefinedf() //undefined undefined 可选参数下面是一个常见模式，给参数设置默认值： 12345function pair(x, y) &#123; x = x || 0; // (*) y = y || 0; return [ x, y ];&#125; 在（*）这行，如果x是真值（除了：null，undefined 等）， 操作符返回x。否则，它返回第二个操作数。 123pair() //[ 0, 0 ]pair(3) //[ 3, 0 ]pair(3, 5) //[ 3, 5 ] 强制数量如果你想强制参数的数量，你可以检测arguments.length： 123456function pair(x, y) &#123; if (arguments.length !== 2) &#123; throw new Error('Need exactly 2 arguments'); &#125; ...&#125; 将arguments 转换为数组arguments不是一个数组，它仅仅是类数组（array-like）：它有一个length属性，并且你可以通过方括号索引方式访问它的元素。然而，你不能移除元素，或在它上面调用任何数组方法。因此，有时你需要将其转换为数组。这就是下面函数的作用。 123function toArray(arrayLikeObject) &#123; return [].slice.call(arrayLikeObject);&#125; 十、异常处理异常处理最常见的方式像下面这样： 12345678910function throwException() &#123; throw new Error('Problem!');&#125;try &#123; throwException();&#125; catch (e) &#123; console.log(e); // 错误：信息 console.log(e.stack); // 非标准，但大部分浏览器支持&#125; try分支包裹易出错的代码，如果try分支内部抛出异常，catch分支将会执行。 十一、严格模式严格模式开启检测和一些其他措施，使JavaScript变成更整洁的语言。推荐使用严格模式。为了开启严格模式，只需在JavaScript文件或script标签第一行添加如下语句： 1'use strict'; 你也可以在每个函数上选择性开启严格模式，只需将上面的代码放在函数的开头： 123function functionInStrictMode() &#123; 'use strict';&#125; 下面的两小节看下严格模式的三大好处。 明确错误让我们看一个例子，严格模式给我们明确的错误，否则JavaScript总是静默失败：下面的函数f() 执行一些非法操作，它试图更改所有字符串都有的只读属性——length： 123function f() &#123; 'abc'.length = 5;&#125; 当你调用上面的函数，它静默失败，赋值操作被简单忽略。让我们将f()在严格模式下运行： 1234function f_strict() &#123; 'use strict'; 'abc'.length = 5;&#125; 现在浏览器报给我们一些错误： 1f_strict() // TypeError: Cannot assign to read only property 'length' of abc 不是方法的函数中的this在严格模式下，不作为方法的函数中的this值是undefined： 12345function f_strict() &#123; 'use strict'; return this;&#125;console.log(f_strict() === undefined); // true 在非严格模式下，this的值是被称作全局对象（global object）（在浏览器里是window）： 1234function f() &#123; return this;&#125;console.log(f() === window); // true 不再自动创建全局变量在非严格模式下，如果你给不存在的变量赋值，JavaScript会自动创建一个全局变量： 123function f() &#123; foo = 5 &#125;f() // 不会报错foo // 5 在严格模式下，这会产生一个错误： 12function f_strict() &#123; 'use strict'; foo2 = 4; &#125;f_strict() // ReferenceError: foo2 is not defined 深入阅读 揭秘javascript中谜一样的this JavaScript中的this关键字 十二、变量作用域和闭包在JavaScript中，你必须使用变量之前，通过var声明变量： 123var x;x = 3;y = 4; // ReferenceError: y is not defined 你可以用一条var语句声明和初始化多个变量： 1var x = 1, y = 2, z = 3; 但我建议每个变量使用一条语句。因此，我将上面的语句重写为： 123var x = 1;var y = 2;var z = 3; 由于提升（见下文），最好在函数顶部声明变量。 变量和函数作用域变量的作用域总是整个函数（没有块级作用域）。例如： 12345678function foo() &#123; var x = -3; if (x &lt; 0) &#123; // (*) var tmp = -x; ... &#125; console.log(tmp); // 3&#125; 我们可以看到tmp变量不仅在（*）所在行的语句块存在，它在整个函数内都存在。 变量提升变量声明会被提升：声明会被移到函数的顶部，但赋值过程不会。举个例子，在下面的函数中（*）行位置声明了一个变量。 123456function foo() &#123; console.log(tmp); // undefined if (false) &#123; var tmp = 3; // (*) &#125;&#125; 在内部，上面的函数被执行像下面这样： 1234567function foo() &#123; var tmp; // declaration is hoisted console.log(tmp); if (false) &#123; tmp = 3; // assignment stays put &#125;&#125; 闭包每个函数保持和函数体内部变量的连接，甚至离开创建它的作用域之后。例如： 12345function createIncrementor(start) &#123; return function () &#123; // (*) return start++; &#125;&#125; 在（*）行开始的函数在它创建时保留上下文，并在内部保存一个start活动值： 1234var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 闭包是一个函数加上和其作用域链的链接。因此，createIncrementor()返回的是一个闭包。 IIFE：模拟块级作用域有时你想模拟一个块，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 IIFE(立即执行函数表达式(Immediately Invoked Function Expression))： 123(function () &#123; // 块开始 var tmp = ...; // 非全局变量&#125;()); // 块结束 上面你会看到函数表达式被立即执行。外面的括号用来阻止它被解析成函数声明；只有函数表达式能被立即调用。函数体产生一个新的作用域并使tmp变为局部变量。 闭包实现变量共享下面是个经典问题，如果你不知道，会让你费尽思量。因此，先浏览下，对问题有个大概的了解。 闭包保持和外部变量的连接，有时可能和你想像的行为不一致： 123456var result = [];for (var i=0; i &lt; 5; i++) &#123; result.push(function () &#123; return i &#125;); // (*)&#125;console.log(result[1]()); // 5 (不是 1)console.log(result[3]()); // 5 (不是 3) (*)行的返回值总是当前的i值，而不是当函数被创建时的i值。当循环结束后，i的值是5，这是为什么数组中的所有函数的返回值总是一样的。如果你想捕获当前变量的快照，你可以使用IIFE： 12345for (var i=0; i &lt; 5; i++) &#123; (function (i2) &#123; result.push(function () &#123; return i2 &#125;); &#125;(i)); // 复制当前的i&#125; 深入阅读 认识javascript中的作用域和上下文 JavaScript的作用域和提升机制 了解JavaScript的执行上下文 十三、对象和继承和所有的值类型一样，对象有属性。事实上，你可以将对象当作一组属性的集合，每个属性都是一对（键和值）。键是字符串，值可以是任意JavaScript值。到目前为止，我们仅仅见过键是标识符的属性，因为点操作符处理的键必须为标识符。在这节，你讲见到另一种访问属性的方法，能将任意字符串作为键。 单个对象在JavaScript中，你可以直接创建对象，通过对象字面量： 12345678var jane = &#123; name: 'Jane', describe: function () &#123; 'use strict'; return 'Person named '+this.name; &#125;&#125;; 上面的对象有两个属性：name和describe。你能读（“get”）和 写（“set”）属性： 123jane.name // get，'Jane'jane.name = 'John'; // setjane.newProperty = 'abc'; // 自动创建 属性是函数如describe可以被当作方法调用。当调用他们时可以在它们内部通过this引用对象。 123jane.describe() // 调用方法,'Person named John'jane.name = 'Jane';jane.describe() // 'Person named Jane' in操作符用来检测一个属性是否存在： 12'newProperty' in jane // true'foo' in jane // false 若读取一个不存在的属性，将会得到undefined值。因此上面的两个检查也可以像下面这样： 12jane.newProperty !== undefined // truejane.foo !== undefined // false delete操作符用来删除一个属性： 12delete jane.newProperty //true'newProperty' in jane //false 任意键属性属性的键可以是任意字符串。到目前为止，我们看到的对象字面量中的和点操作符后的属性关键字。按这种方法你只能使用标识符。如果你想用其他任意字符串作为键名，你必须在对象字面量里加上引号，并使用方括号获取和设置属性。 123var obj = &#123; 'not an identifier': 123 &#125;;obj['not an identifier'] //123obj['not an identifier'] = 456; 方括号允许你动态计算属性关键字： 123var x = 'name';jane[x]; // 'Jane'jane['na'+'me']; // 'Jane' 引用方法如果你引用一个方法，它将失去和对象的连接。就其本身而言，函数不是方法，其中的this值为undefined（严格模式下）。 12var func = jane.describe;func() // TypeError: Cannot read property 'name' of undefined 解决办法是使用函数内置的bind()方法。它创建一个新函数，其this值固定为给定的值。 12var func2 = jane.describe.bind(jane);func2() // 'Person named Jane' 方法内部的函数每个函数都有一个特殊变量this。如果你在方法内部嵌入函数是很不方便的，因为你不能从函数中访问方法的this。下面是一个例子，我们调用forEach循环一个数组： 1234567891011var jane = &#123; name: 'Jane', friends: [ 'Tarzan', 'Cheeta' ], logHiToFriends: function () &#123; 'use strict'; this.friends.forEach(function (friend) &#123; // 这里的“this”是undefined console.log(this.name + ' says hi to ' + friend); &#125;); &#125;&#125; 调用logHiToFriends会产生错误： 1jane.logHiToFriends() // TypeError: Cannot read property 'name' of undefined 有两种方法修复这问题。 将this存储在不同的变量。 1234567logHiToFriends: function () &#123; 'use strict'; var that = this; this.friends.forEach(function (friend) &#123; console.log(that.name + ' says hi to ' + friend); &#125;);&#125; forEach的第二个参数允许提供this值。 123456logHiToFriends: function () &#123; 'use strict'; this.friends.forEach(function (friend) &#123; console.log(this.name + ' says hi to ' + friend); &#125;, this);&#125; 在JavaScript中函数表达式经常被用作函数参数。时刻小心函数表达式中的this。 构造函数：对象工厂除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：如果通过new操作符调用，他们会变为构造函数，对象的工厂。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如： 123456789// 设置实例数据function Point(x, y) &#123; this.x = x; this.y = y;&#125;// 方法Point.prototype.dist = function () &#123; return Math.sqrt(this.x*this.x + this.y*this.y);&#125;; 我们看到构造函数分为两部分：首先，Point函数设置实例数据。其次，Point.prototype属性包含对象的方法。前者的数据是每个实例私有的，后面的数据是所有实例共享的。 我们通过new操作符调用Point： 123var p = new Point(3, 5);p.x //3p.dist(); //5.830951894845301 p是Point的一个实例： 12p instanceof Point //truetypeof p //'object' 深入阅读 Javascript继承 原型的陷阱 Javascript 封装问题 十四、数组数组是数组元素的序列，能通过整数索引方法数组元素，数组索引从0开始。 数组字面量数组字面量创建数组很方便： 1&gt; var arr = [ 'a', 'b', 'c' ]; 上面的数组有三个元素：分别是字符串“a”，“b”， “c”。你可以通过整数索引访问它们： 1234arr[0] //'a'arr[0] = 'x';arr// [ 'x', 'b', 'c' ] length属性总表示一个数组有多少项元素。 1arr.length //3 除此之外它也可以用来从数组上移除尾部元素： 12arr.length = 2; arr // [ 'x', 'b' ] in操作符也可以在数组上工作。 121 in arr // arr在索引为1处是否有元素？,true5 in arr // arr在索引为5处是否有元素？false 值得注意的是数组是对象，因此可以有对象属性： 12arr.foo = 123;arr.foo // 123 数组方法数组有许多方法。举些例子： 123456789101112131415161718192021222324var arr = [ 'a', 'b', 'c' ];arr.slice(1, 2) // 复制元素，[ 'b' ]arr.slice(1) // [ 'b', 'c' ]arr.push('x') // 在末尾添加一个元素，4arr // [ 'a', 'b', 'c', 'x' ]arr.pop() // 移除最后一个元素，'x'arr // [ 'a', 'b', 'c' ]arr.shift() // 移除第一个元素，'a'arr // [ 'b', 'c' ]arr.unshift('x') // 在前面添加一个元素，3arr // [ 'x', 'b', 'c' ]arr.indexOf('b') // 查找给定项在数组中的索引，若不存在返回-1，// 1arr.indexOf('y') // -1arr.join('-') // 将元素拼接为一个字符串，'x-b-c'arr.join('') // 'xbc'arr.join() // 'x,b,c' 遍历数组有几种方法可以遍历数组元素。其中两个最重要的是forEach和map。 forEach遍历整个数组，并将当前元素和它的索引传递给一个函数： 123[ 'a', 'b', 'c' ].forEach(function (elem, index) &#123; // (*) console.log(index + '. ' + elem);&#125;); 上面代码的输出 1230. a1. b2. c 注意（*）行的函数参数是可省略的。例如：它可以只有一个参数elem。 map创建一个新数组，通过给每个存在数组元素应用一个函数： 1234[1,2,3].map(function (x) &#123; return x*x &#125;);// [ 1, 4, 9 ] 深入阅读 有趣的javascript原生数组函数 十五、正则表达式JavaScript内建支持正则表达式。他们被双斜线分隔： 12/^abc$//[A-Za-z0-9]+/ 方法 test()：测试是否匹配12/^a+b+$/.test('aaab') // true/^a+b+$/.test('aaa') // false 方法 exec()：匹配和捕获组1/a(b+)a/.exec('_abbba_aba_') // [ 'abbba', 'bbb' ] 返回的数组第一项（索引为0）是完整匹配，捕获的第一个分组在第二项（索引为1），等。有一种方法可以反复调用获取所有匹配。 方法 replace()：搜索并替换1'&lt;a&gt; &lt;bbb&gt;'.replace(/&lt;(.*?)&gt;/g, '[$1]') // '[a] [bbb]' replace的第一个参数必须是正则表达式，并且开启全局搜索（/g标记），否则仅第一个匹配项会被替换。有一种方法使用一个函数来计算替换项。 十六、数学Math是一个有算数功能的对象。例如： 12345Math.abs(-2) // 2Math.pow(3, 2) // 3^2 = 9Math.max(2, -1, 5) //5Math.round(1.9) // 2Math.cos(Math.PI) // 预定义常量π，-1 十七、标准库的其他功能JavaScript标准库相对简单，但有很多其他东西你可以使用： Date：日期构造函数，主要功能有转换和创建日期字符串，访问日期组成部分（年，小时等）。JSON：一个对象，功能是转换和生成JSON数据。console.*方法：浏览器的具体方法，不是语言成分的部分，但他们也可以在Node.js中工作。 十八、下一步学什么？在你学会了这篇文章的基础教程后，你可以转到大部分章节末尾提到的高级教程。此外，我建议你看下面的资源： Style guides: I have written a guide to style guides Underscore.js: 一个弥补JavaScript标准库缺少的功能的库 JSbooks – free JavaScript books Frontend rescue: how to keep up to date on frontend technologies http://yanhaijing.com 当然还有我的博客也非常不错哦 http://yanhaijing.com/es5 如果你想成为高手，我建议阅读ecmascript规范 给javascript初学者的24条最佳实践 我希望我知道的七个JavaScript技巧 参考自原文：http://www.2ality.com/2013/06/basic-javascript.html参考自译文：http://yanhaijing.com/basejs/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons Collections包和简介]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%90%8E%E7%AB%AF%2FJava%2Fcommons%2FCommons%20Collections%E5%8C%85%E5%92%8C%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[背景介绍Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。 Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。 一、包结构介绍 注意：Commons Collections的最新版是4.1，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。 以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考Apache Commons Collections 3.2.2 API文档。 org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection –实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors –Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类 二、Map的一些介绍Collections包中的“Map”是在java.util.Map的基础上扩展的接口和类。有如下常用的Map: LinkedMap，可以维护条目顺序的map； BidiMap，即双向Map，可以通过key找到value，也可以通过value找到key。需要注意的是BidiMap中key和value都不可以重复； MultiMap，一个key指向的是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，实现了一对多； LazyMap，即Map中的键/值对一开始并不存在，当被调用到时才创建。 三、Collections中Map的使用示例1. Map迭代器之mapIteratorjdk中的Map接口很难进行迭代。api用户总是需要通过entryset或者keyset进行迭代。commons-collectons现在提供了一个新的接口 - mapIterator来允许对maps进行简单的迭代。示例如下： (1)、构造Map初始数据的方法： 1234567891011/** * 构建map初始数据 * @param map */private static Map buildMap(Map map) &#123; map.put("one", "1"); map.put("two", "2"); map.put("three", "3"); map.put("four", "4"); return map;&#125; (2)、使用MapIterator迭代数据的方法： 12345678910111213141516/** * map迭代器 * 遍历打印map,使用map.mapIterator() * @param map * @param mapName */private static void iteratorMap() &#123; Map map = this.buildMap(new HashMap()); // 遍历map,使用MapIterator MapIterator it = map.mapIterator(); while (it.hasNext()) &#123; Object key = it.next(); Object value = it.getValue(); System.out.println("iterator map key:" + key + ", value: " + value); &#125;&#125; 2. 有序map之LinkedMapLinkedMap是一个可以维护Map中条目顺序的Map实现，条目顺序由最初的数据插入时来决定。同时也增加上面所说的MapIterator功能和一些便利的方法，并允许进行双向迭代。相较于JDK1.4中的LinkedHashMap效率有所提高，它还实现了OrderedMap接口。此外，还提供了非接口方法通过索引来访问Map中的数据。需要注意的是LinkedMap不是同步的，不是线程安全的。如果你想使用LinkedMap的同时使用多个线程，您必须使用适当的同步操作。最简单的方法是使用Collections.synchronizedMap(Map)来包装LinkedMap。如果不使用同步操作，当并发线程访问这个类时可能会抛出异常。 LinkedMap的一些代码示例代码如下： 12345678910111213/** * 有序map之LinkedMap */private static void linkedMapTest() &#123; OrderedMap orderMap = this.buildMap(new LinkedMap()); // 获取map中相应的值 System.out.println("LinkedMap firstKey:" + orderMap.firstKey()); System.out.println("LinkedMap previous key:" + orderMap.previousKey("four")); System.out.println("LinkedMap next key:" + orderMap.nextKey("two")); System.out.println("LinkedMap last key:" + orderMap.lastKey()); System.out.println("LinkedMap map Size:" + orderMap.size());&#125; 3. 双向Map之BidiMap所谓BidiMap，直译就是双向Map，可以通过key找到value，也可以通过value找到key，这在我们日常的代码-名称匹配的时候很方便：因为我们除了需要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当中不光key不能重复，value也不可以重复。基本使用示例如下： 1234567891011121314151617181920212223/** * BidiMap,是双向Map * 通过key得到value * 通过value得到key * 注意的是BidiMap,当中不光key不能重复，value也不可以。 */private static void bidiMapTest() &#123; BidiMap bidiMap = this.buildMap(new TreeBidiMap()); // 有相同值的，只有最后一个生效 bidiMap.put("san", "3"); loopMap(bidiMap, "BidiMap"); // 获取map中相应的值 System.out.println("BidiMap getKey:" + bidiMap.getKey("2")); System.out.println("BidiMap getMoreSameKey:" + bidiMap.getKey("3")); // 移除map的value bidiMap.removeValue("3"); System.out.println("BidiMap getMoreSameKey2:" + bidiMap.getKey("3")); // 交换map的key和value BidiMap inversMap = bidiMap.inverseBidiMap();&#125; 4. 多值Map之MultiMap所谓MultiMap，就是说单个key可以对应多个value,在put或remove时和普通Map没有区别,但当get时将返回多个value,所以返回一个collections,利用MultiMap，我们就可以很方便的往一个key上放数量不定的对象，也就实现了一对多。在3.2.1版本中MultiHashMap已被废除,请使用MultiValueMap。简单的使用示例如下： 12345678private static void multiMapTest() &#123; MultiMap multiMap = new MultiValueMap(); multiMap = multibuildMap(multiMap); multiMap.put("three", "5"); List&lt;String&gt; list = (List&lt;String&gt;) multiMap.get("three"); // 会打印: list:[3, 5] System.out.println("list:" + list);&#125; 5. “懒加载”Map之LazyMap所谓LazyMap，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才会创建，这样的解释初听上去是不是有点不可思议，这样的LazyMap有用吗？我们这样来理解：我们需要一个Map，但是由于创建成员的方法很“重”（比如数据库访问），或者我们只有在调用get()时才知道如何创建，或者Map中出现的可能性很多很多，我们无法在get()之前添加所有可能出现的键/值对，或者任何其它解释得通的原因，我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据生成的话，LazyMap就变得很有用了。简单的使用示例如下： 12345678910111213141516171819202122232425/** * LazyMap.类似与Hibenrate的懒加载,在声明的时候并不会创建, * 而是在使用(get)的时候,才创建集合的内容,返回Factory的返回值 * 实现懒加载,当我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据可以使用LazyMap * 有LazyList与LazyMap对应 */private static void lazyMapTest() &#123; //创建一个工厂，实现create方法 Factory factory = new Factory() &#123; @Override public Object create() &#123; // 创建的默认值 return "这是LazyMap get()不到时创建的默认值"; &#125; &#125;; Map lazyMap = LazyMap.decorate(new HashMap(), factory); System.out.println("map:" + lazyMap); //当此lazyMap调用get(key)时，如果无此key则返回varFactory里create方法返回的值 System.out.println("map:" + lazyMap.get("hello")); // 有key对应的值时,返回123 lazyMap.put("hello", "123"); System.out.println("map:" + lazyMap.get("hello"));&#125; Apache Commons Collections中的基本map的接口类型和使用方法，不仅有上面这些，还有很多细分的、拥有不同功能或者各功能会有交叉的map，等着我们在自己工作中去使用挖掘吧！]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中关于日期和时间API的20个使用示例]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%90%8E%E7%AB%AF%2FJava%2FJava%208%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API%E7%9A%8420%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[一、前言随着lambda表达式、streams以及一系列小优化，Java8推出了全新的日期时间API，在一下的指南中我们将通过一些简单的示例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。Java也意识到需要一个更好的API来满足社区中已经习惯了使用JodaTime API的人们。全新API的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、期间（duration）、日期、时间、时区和周期。同时继承了Joda库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。下面是新版API中java.time包里的一些关键类： Instant：瞬时实例。 LocalDate：本地日期，不包含具体时间。例如：2014-01-14可以用来记录生日、纪念日、加盟日等。 LocalTime：本地时间，不包含日期。 LocalDateTime：组合了日期和时间，但不包含时差和时区信息。 ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。 新API还引入了ZoneOffSet和ZoneId类，使得解决时区问题更为简便。解析和格式化时间的DateTimeFormatter类也全部重新设计。注意，这篇文章是翻译自Java 8 - 20 Examples of Date and Time API，以下示例代码我做过一些简单的修改，当运行这些例子时会返回你当前的时间。 二、在Java8中如何处理日期和时间常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探索。这对Java8新日期时间API也不例外。我创建了20个基于任务的实例来学习Java8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单日、保费到期日、信用卡过期日等。 示例 1、在Java8中获取今天的日期Java8中的LocalDate用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。 1234LocalDate today = LocalDate.now();System.out.println("今天的日期是：" + today);// 今天的日期是：2016-04-18 上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的Date类打印出一堆没有格式化的信息。 示例 2、在Java8中获取当前的年、月、日信息LocalDate类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖java.util.Calendar类了。 1234567LocalDate today = LocalDate.now();int year = today.getYear();int month = today.getMonthValue();int day = today.getDayOfMonth();System.out.printf("当前的年 : %d 月 : %d 日 : %d%n", year, month, day);// 当前的年 : 2016 月 : 4 日 : 18 看到了吧，在Java8中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前Java是怎么处理年月日信息的吧。 示例 3、在Java8中获取特定日期在第一个例子里，我们通过静态工厂方法now()非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法LocalDate.of()创建任意日期，该方法需要传入年、月、日做参数，返回对应的LocalDate实例。这个方法的好处是没再犯老API的设计错误，比如年度起始于1900，月份是从0开始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。 1234LocalDate dateOfBirth = LocalDate.of(2016, 4, 18);System.out.println("你的出生日期是：" + dateOfBirth);// 你的出生日期是：2016-04-18 可以看到创建的日期完全符合预期，与你写入的2016年4月18日完全一致。 示例 4、在Java8中判断两个日期是否相等现实生活中有一类时间处理就是判断两个日期是否相等。你常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定日期做比较，例如判断这一天是否是假期。下面这个例子会帮助你用Java8的方式去解决，你肯定已经想到了，LocalDate重载了equal方法，请看下面的例子： 1234567LocalDate today = LocalDate.now();LocalDate date1 = LocalDate.of(2016, 4, 18);if (date1.equals(today)) &#123; System.out.printf("今天 %s 和 date1 %s 是同一天!%n", today, date1);&#125;// 今天 2016-04-18 和 date1 2016-04-18 是同一天! 这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比Java老的日期比较方式，你会感到清风拂面。 示例 5、在Java8中检查像生日这种周期性事件Java中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI日或保险缴费日这些周期性事件。如果你在电子商务网站工作，那么一定会有一个模块用来在圣诞节、感恩节这种节日时向客户发送问候邮件。Java中如何检查这些节日或其它周期性事件呢？答案就是MonthDay类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个YearMonth类。这些类也都是不可变并且线程安全的值类型。下面我们通过MonthDay来检查周期性事件： 123456789101112LocalDate today = LocalDate.now();LocalDate dateOfBirth = LocalDate.of(2016, 4, 18);MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());MonthDay currentMonthDay = MonthDay.from(today);if(currentMonthDay.equals(birthday))&#123; System.out.println("好高兴今天是您的生日!!");&#125;else&#123; System.out.println("对不起，今天不是您的生日!!");&#125;// 好高兴今天是您的生日!! 只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。 示例 6、在Java8中获取当前时间与Java8获取日期的例子很像，获取时间使用的是LocalTime类，一个只有时间没有日期的LocalDate的近亲。可以调用静态工厂方法now()来获取当前时间。默认的格式是hh:mm:ss:nnn。对比一下Java8之前获取当前时间的方式。 1234LocalTime time = LocalTime.now();System.out.println("当前时间是:" + time);// 当前时间是:23:43:42.200 可以看到当前时间就只包含时间信息，没有日期。 示例 7、如何在现有的时间上增加小时通过增加小时、分、秒来计算将来的时间很常见。Java8除了不变类型和线程安全的好处之外，还提供了更好的plusHours()方法替换add()，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。 12345LocalTime time = LocalTime.now();LocalTime newTime = time.plusHours(2); // 添加两小时System.out.println("当前时间:" + time + ",两小时后的时间: " + newTime);// 当前时间:23:50:56.195,两小时后的时间: 01:50:56.195 可以看到，新的时间在当前时间23:50:56.195的基础上增加了2个小时。和旧版Java的增减时间的处理方式对比一下，看看哪种更好。 示例 8、如何计算一周后的日期和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。LocalDate日期不包含时间信息，它的plus()方法用来增加天、周、月，ChronoUnit类声明了这些时间单位。由于LocalDate也是不变类型，返回后一定要用变量赋值。 12345LocalDate today = LocalDate.now();LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);System.out.println("今天是:" + today + ",一周以后的日期: " + nextWeek);// 今天是:2016-04-18,一周以后的日期: 2016-04-25 可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看Java 8 API中的ChronoUnit类。 示例 9、计算一年前或一年后的日期继续上面的例子，上个例子中我们通过LocalDate的plus()方法增加天数、周数或月数，这个例子我们利用minus()方法计算一年前的日期。 123456LocalDate today = LocalDate.now();LocalDate preYear = today.minus(1, ChronoUnit.YEARS);LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);System.out.println("今天是:" + today + ",一年前的日期: " + preYear + ",一年后的日期: " + nextYear);// 今天是:2016-04-18,一年前的日期: 2015-04-18,一年后的日期: 2017-04-18 例子结果中得到了两个日期，一个2015年、一个2017年、分别是2016年的前一年和后一年。 示例 10、使用Java8的Clock时钟类Java8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis()和TimeZone.getDefault()的地方都可用Clock替换。 12345678910// 得到UTC的时区的日期时间clock对象Clock clock = Clock.systemUTC();System.out.println("Clock : " + clock);// Clock : SystemClock[Z]// 得到基于当前时区的日期时间clock对象Clock defaultClock = Clock.systemDefaultZone();System.out.println("Clock : " + clock);// Clock : SystemClock[Z] 还可以针对clock时钟做比较，像下面这个例子： 12345678910public class MyClass &#123; // 依赖注入 private Clock clock; ... public void process(LocalDate eventDate) &#123; if (eventDate.isBefore(LocalDate.now(clock)) &#123; ... &#125; &#125;&#125; 这种方式在不同时区下处理日期时会非常管用。 示例 11、如何用Java判断日期是早于还是晚于另一个日期另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。调用isBefore()方法时，如果给定日期小于当前日期则返回true。 12345678910111213LocalDate today = LocalDate.now();LocalDate tomorrow = LocalDate.of(2016, 4, 19);if (tomorrow.isAfter(today)) &#123; System.out.println("明天晚于今天！");&#125;// 明天晚于今天！LocalDate yesterday = today.minus(1, ChronoUnit.DAYS);if (yesterday.isBefore(today)) &#123; System.out.println("昨天先于今天！");&#125;// 昨天先于今天！ 在Java 8中比较日期非常方便，不需要使用额外的Calendar类来做这些基础工作了。 示例 12、在Java8中处理时区Java8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java8以前都是GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。 1234567// Java 8中某时区下的日期和时间ZoneId america = ZoneId.of("America/New_York");LocalDateTime localtDateAndTime = LocalDateTime.now();ZonedDateTime dateAndTimeInNewYork = ZonedDateTime.of(localtDateAndTime, america );System.out.println("Current date and time in a particular timezone : " + dateAndTimeInNewYork);// Current date and time in a particular timezone : 2016-04-19T23:10:09.251-04:00[America/New_York] 和以前使用GMT的方式转换本地时间对比一下。注意，在Java8以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常： 123456Exception in thread "main" java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272) at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227) at java.time.ZoneRegion.ofId(ZoneRegion.java:120) at java.time.ZoneId.of(ZoneId.java:403) at java.time.ZoneId.of(ZoneId.java:351) 示例 13、如何表示信用卡到期这类固定日期，答案就在YearMonth与MonthDay检查重复事件的例子相似，YearMonth是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，YearMonth实例的lengthOfMonth()方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。 1234567YearMonth currentYearMonth = YearMonth.now();System.out.printf("该月的天数 %s: %d%n", currentYearMonth, currentYearMonth.lengthOfMonth());// 该月的天数 2016-04: 30YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY);System.out.printf("您的信用卡到期是： %s%n", creditCardExpiry);// 您的信用卡到期是： 2018-02 根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。 示例 14、如何在Java8中检查闰年LocalDate类有一个很实用的方法isLeapYear()判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯Java逻辑编写的判断闰年的程序。 12345678LocalDate today = LocalDate.now();if (today.isLeapYear()) &#123; System.out.println("今年是闰年！");&#125; else &#123; System.out.println("今年不是闰年！");&#125;// 今年是闰年！ 你可以多写几个日期来验证是否是闰年，最好是写JUnit单元测试做判断。 示例 15、计算两个日期之间的天数和月数有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java8中可以用java.time.Period类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。 123456LocalDate today = LocalDate.now();LocalDate java8Release = LocalDate.of(2016, Month.APRIL, 21);Period periodToNext = Period.between(today, java8Release);System.out.println("2016年4月21日距离今天的天数：" + periodToNext.getDays() );// 2016年4月21日距离今天的天数：3 从上面可以看到现在是一月，Java8的中计算的当前日期是4月18日，中间相隔3天。 示例 16、包含时差信息的日期和时间在Java8中，ZoneOffset类用来表示时区，举例来说印度与GMT或UTC标准时区相差+05:30，可以通过ZoneOffset.of()静态方法来 获取对应的时区。一旦得到了时差就可以通过传入LocalDateTime和ZoneOffset来创建一个OffSetDateTime对象。 123456LocalDateTime datetime = LocalDateTime.of(2016, Month.APRIL, 19, 23, 35);ZoneOffset offset = ZoneOffset.of("+05:30");OffsetDateTime date = OffsetDateTime.of(datetime, offset);System.out.println("包含时差信息的日期和时间 : " + date);//包含时差信息的日期和时间 : 2016-04-19T23:35+05:30 现在的时间信息里已经包含了时区信息了。注意：OffSetDateTime是对计算机友好的，ZoneDateTime则对人更友好。 示例 17、在Java8中获取当前的时间戳如果你还记得Java8以前是如何获得当前时间戳，那么现在你终于解脱了。Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示： 1234Instant timestamp = Instant.now();System.out.println("时间戳是：" + timestamp);// 时间戳是：2016-04-18T15:41:06.876Z 时间戳信息里同时包含了日期和时间，这和java.util.Date很像。实际上Instant类确实等同于Java8之前的Date类，你可以使用Date类和Instant类各自的转换方法互相转换，例如：Date.from(Instant) 将Instant转换成java.util.Date，Date.toInstant()则是将Date类转换成Instant类。 示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期在Java8以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类SimpleDateFormat也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了BASIC_ISO_DATE格式化工具将2016年4月18日格式化成20160418。 12345String day = "20160418";LocalDate formatted = LocalDate.parse(day, DateTimeFormatter.BASIC_ISO_DATE);System.out.printf("从字符串中解析的日期: %s 是 %s %n", day, formatted);// 从字符串中解析的日期: 20160418 是 2016-04-18 很明显的看出得到的日期和给出的日期是同一天，但是格式不同。 示例 19、如何在Java中使用自定义格式化工具解析日期上个例子使用了Java内置的格式化工具去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用DateTimeFormatter的ofPattern()静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，M代表月，m代表分。如果格式不规范会抛出DateTimeParseException异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。 1234567891011String day = "2016 04 18";try &#123; DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy MM dd"); LocalDate holiday = LocalDate.parse(day, formatter); System.out.printf("成功解析字符串：%s, 时间是：%s%n", day, holiday);&#125; catch (DateTimeParseException ex) &#123; System.out.printf("%s 解析失败!", day); ex.printStackTrace();&#125;// 成功解析字符串：2016 04 18, 时间是：2016-04-18 日期值与传入的字符串是匹配的，只是格式不同而已。 示例 20、在Java8中如何把日期转换成字符串上 两个例子都用到了DateTimeFormatter类，主要是从字符串解析日期。现在我们反过来，把LocalDateTime日期实例转换成特定格式的字符串。这是迄今为止Java日期转字符串最为简单的方式了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建DateTimeFormatter实例并传入格式，但这回调用的是format()方法，而非parse()方法。这个方法会把传入的日期转化成指定格式的字符串。 1234567891011LocalDateTime arrivalDate = LocalDateTime.now();try &#123; DateTimeFormatter format = DateTimeFormatter.ofPattern("MMM dd yyyy hh:mm a"); String landing = arrivalDate.format(format); System.out.printf("格式化的日期时间: %s %n", landing);&#125; catch (DateTimeException ex) &#123; System.out.printf("%s 不能格式化!%n", arrivalDate); ex.printStackTrace();&#125;// 格式化的日期时间: 四月 19 2016 12:02 上午 当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。 Java 8日期时间API的重点通过这些例子，你肯定已经掌握了Java8日期时间API的新知识点。现在我们来回顾一下这个优雅API的使用要点： 提供了javax.time.ZoneId获取时区。 提供了LocalDate`和LocalTime`类。 Java8的所有日期和时间API都是不可变类并且线程安全，而现有的Date和Calendar API中的java.util.Date和SimpleDateFormat是非线程安全的。 主包是java.time,包含了表示日期、时间、时间间隔的一些类。里面有两个子包java.time.format用于格式化， java.time.temporal用于更底层的操作。 时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或UTC的时差。例如：东京的时差是+09:00。 OffsetDateTime类实际上组合了LocalDateTime类和ZoneOffset类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。 DateTimeFormatter类用来格式化和解析时间。与SimpleDateFormat不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。DateTimeFormatter类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了parse()将字符串解析成日期，如果解析出错会抛出DateTimeParseException。DateTimeFormatter类同时还有format()用来格式化日期，如果出错会抛出DateTimeException异常。 再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。 如何使用Java8的全新日期时间API就介绍到这了。这些简单的例子对帮助理解新API非常有用。由于这些例子都基于真实任务，你在做Java日期编程时不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖Joda Time第三方库。新API可以作为处理日期时间操作的标准。 如果你喜欢这个教程并希望看到更多关于Java 8的教程，下面这些精彩的文章都值得一看： 如何在Java8中用一行代码搞定文件读取？(示例) 学习Java8的十大教程（教程） 免费的Java8教程和图书 （资源） Java 8 Comparator例子 （示例） 如何使用Java8的Map函数（示例） 你准备好学习Java8的认证了吗 （更多） 如何使用Java8的默认方法。（看这里） 开始Java8之前需要温习的十个Java 7特性（更多） Java8学习Stream API十例（示例） 如何在匿名类中使用Lambda表达式（答案） 如何使用Java8的Predicates类过滤Collection？（答案） Java中如何随即访问文件？（答案）]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
